/*
 * grid.cc
 *
 *  Last edited on Nov 14, 2013
 *  by Trong Nguyen
 *
 *  1. Using Grid Online algorithm to detect the hole as a gird
 *  2. Each adjust cell of hole election a Pivot node
 */

#include "config.h"

#include "griddynamic.h"
#include "griddynamic_packet.h"

#include "wsn/gridoffline/gridoffline_packet_data.h"
#include "wsn/boundhole/boundhole_packet_data.h"
#include "wsn/geomathhelper/geo_math_helper.h"

#include "../include/tcl.h"

#define MIN(a, b) ((a) < (b) ? (a) : (b))

int hdr_griddynamic::offset_;

static class GridDynamicHeaderClass : public PacketHeaderClass
{
public:
	GridDynamicHeaderClass() : PacketHeaderClass("PacketHeader/GRIDDYNAMIC", sizeof(hdr_griddynamic))
	{
		bind_offset(&hdr_griddynamic::offset_);
	}
}class_griddynamichdr;

static class GridDynamicAgentClass : public TclClass
{
	public:
		GridDynamicAgentClass() : TclClass("Agent/GRIDDYNAMIC") {}
		TclObject* create(int, const char*const*)
		{
			return (new GridDynamicAgent());
		}
}class_grid;

void
GridDynamicTimer::expire(Event *e) {
	(a_->*firing_)();
}

// ------------------------ Agent ------------------------ //

GridDynamicAgent::GridDynamicAgent() : GPSRAgent(),
		findStuck_timer_(this, &GridDynamicAgent::findStuckAngle),
		boundhole_timer_(this, &GridDynamicAgent::sendBoundHole),
		updateSta_timer_(this, &GridDynamicAgent::checkState)
{
	isBoundary = false;
	stuck_angle_ = NULL;
	hole_ = NULL;
	pivot.id_ = -1;
	bind("range_", &range_);
	bind("limit_", &limit_);
	bind("r_", &r_);
	bind("limit_boundhole_hop_", &limit_boundhole_hop_);
	bind("limit_x_", &limit_x_);
	bind("limit_y_", &limit_y_);
//	bind("update_period_", &update_period_);
}

int
GridDynamicAgent::command(int argc, const char*const* argv)
{
	if (argc == 2)
	{
		if (strcasecmp(argv[1], "start") == 0)
		{
			startUp();
		}
		if (strcasecmp(argv[1], "boundhole") == 0)
		{
			boundhole_timer_.resched(randSend_.uniform(0.0, 5));
			return TCL_OK;
		}
		if (strcasecmp(argv[1], "nodeoff") == 0)
		{
			boundhole_timer_.force_cancel();
			findStuck_timer_.force_cancel();
		}
	}

	return GPSRAgent::command(argc,argv);
}

// handle the receive packet just of type PT_GRID
void
GridDynamicAgent::recv(Packet *p, Handler *h)
{
	hdr_cmn *cmh = HDR_CMN(p);
	hdr_ip	*iph = HDR_IP(p);

	switch (cmh->ptype())
	{
		case PT_HELLO:
			GPSRAgent::recv(p, h);
			break;

		case PT_GRID:
			recvBoundHole(p);
			break;

		case PT_GRIDDYNAMIC:
			recvGridDynamic(p);
			break;

		case PT_CBR:
			if (iph->saddr() == my_id_)				// a packet generated by myself
			{
				if (cmh->num_forwards() == 0)		// a new packet
				{
					sendData(p);
				}
				else	//(cmh->num_forwards() > 0)	// routing loop -> drop
				{
					drop(p, DROP_RTR_ROUTE_LOOP);
					return;
				}
			}

			if (iph->ttl_-- <= 0)
			{
				drop(p, DROP_RTR_TTL);
				return;
			}
			recvData(p);
			break;

		default:
			drop(p, " UnknowType");
			break;
	}
}

void
GridDynamicAgent::startUp()
{
	// printf("%f - startUp\n", Scheduler::instance().clock());

	pivot.id_ = -1;

	findStuck_timer_.resched(20);

	// clear trace file
	FILE *fp;
//	fp = fopen("Area.tr", 			"w");	fclose(fp);
	fp = fopen("GridHole.tr", 		"w");	fclose(fp);
	fp = fopen("Election.tr", 		"w");	fclose(fp);
	fp = fopen("Alarm.tr",			"w");	fclose(fp);
	fp = fopen("PolygonHole.tr", 	"w");	fclose(fp);
}

void
GridDynamicAgent::recvGridDynamic(Packet* p)
{
	// printf("%f - recvGridDynamic\n", Scheduler::instance().clock());

	hdr_griddynamic* hgd = HDR_GRIDDYNAMIC(p);
	switch (hgd->type_)
	{
		case GRID_BROADCAST:	recvBroadcast(p);	break;
		case GRID_ELECTION:		recvElection(p);	break;
		//case GRID_UPDATE:		recvUpdate(p);		break;
		case GRID_ALARM:		recvAlarm(p);		break;
	}
}

// region ------------------------ Bound hole ------------------------ //

void
GridDynamicAgent::findStuckAngle()
{
	// printf("%f - findStruckAngle\n", Scheduler::instance().clock());

	if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL)
	{
		stuck_angle_ = NULL;
		return;
	}

	node *nb1 = neighbor_list_;
	node *nb2 = neighbor_list_->next_;

	while (nb2)
	{
		Circle circle = G::circumcenter(this, nb1, nb2);
		Angle a = G::angle(this, nb1, this, &circle);
		Angle b = G::angle(this, nb1, this, nb2);
		Angle c = G::angle(this, &circle, this, nb2);

		// if O is outside range of node, nb1 and nb2 create a stuck angle with node
		if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
		{
			stuckangle* new_angle = new stuckangle();
			new_angle->a_ = nb1;
			new_angle->b_ = nb2;
			new_angle->next_ = stuck_angle_;
			stuck_angle_ = new_angle;
		}

		nb1 = nb1->next_;
		nb2 = nb1->next_;
	}

	nb2 = neighbor_list_;
	Circle circle = G::circumcenter(this, nb1, nb2);
	Angle a = G::angle(this, nb1, this, &circle);
	Angle b = G::angle(this, nb1, this, nb2);
	Angle c = G::angle(this, &circle, this, nb2);

	// if O is outside range of node, nb1 and nb2 create a stuck angle with node
	if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
	{
		stuckangle* new_angle = new stuckangle();
		new_angle->a_ = nb1;
		new_angle->b_ = nb2;
		new_angle->next_ = stuck_angle_;
		stuck_angle_ = new_angle;
	}
}

void
GridDynamicAgent::sendBoundHole()
{
	// printf("%f - sendBoundHole\n", Scheduler::instance().clock());

	Packet		*p;
	hdr_cmn		*cmh;
	hdr_ip		*iph;
	hdr_grid	*bhh;

	for (stuckangle * sa = stuck_angle_; sa; sa = sa->next_)
	{
		p = allocpkt();

		p->setdata(new GridOfflinePacketData());

		cmh = HDR_CMN(p);
		iph = HDR_IP(p);
		bhh = HDR_GRID(p);

		cmh->ptype() 	 = PT_GRID;
		cmh->direction() = hdr_cmn::DOWN;
		cmh->size() 	+= IP_HDR_LEN + bhh->size();
		cmh->next_hop_	 = sa->a_->id_;
		cmh->last_hop_ 	 = my_id_;
		cmh->addr_type_  = NS_AF_INET;

		iph->saddr() = my_id_;
		iph->daddr() = sa->a_->id_;
		iph->sport() = RT_PORT;
		iph->dport() = RT_PORT;
		iph->ttl_ 	 = limit_boundhole_hop_;			// more than ttl_ hop => boundary => remove

		bhh->prev_ = *this;
		bhh->last_ = *(sa->b_);
		bhh->i_ = *this;

		send(p, 0);

		printf("%d\t- Send GridDynamic\n", my_id_);
	}
}

void
GridDynamicAgent::recvBoundHole(Packet *p)
{
	// printf("%f - recvBH\n", Scheduler::instance().clock());

	isBoundary = true;

	struct hdr_ip	*iph = HDR_IP(p);
	struct hdr_cmn 	*cmh = HDR_CMN(p);
	struct hdr_grid *bhh = HDR_GRID(p);

	// add data to packet
	addData(p);

	// if the grid packet has came back to the initial node
	if (iph->saddr() == my_id_)
	{
		if (iph->ttl_ > (limit_boundhole_hop_ - 5))
		{
			drop(p, " SmallHole");	// drop hole that have less than 5 hop
		}
		else
		{
			createGridHole(p, *this);
			hole_->hole_id_ = my_id_;
			hole_->dump();

			dumpBoundhole(hole_);
			//dumpArea();

			sendBroadcast(p);

			drop(p, "boundhole");
		}
		return;
	}

	// check to election
	if (!checkCell(bhh->prev_))
	{
		sendElection();	// <============================ election for a pivot node
	}

	// forward this packet
	if (iph->ttl_-- <= 0)
	{
		drop(p, DROP_RTR_TTL);
		return;
	}

	node* nb = getNeighborByBoundhole(&bhh->prev_, &bhh->last_);

	// no neighbor to forward, drop message. it means the network is not interconnected
	if (nb == NULL)
	{
		drop(p, DROP_RTR_NO_ROUTE);
		return;
	}

	// if neighbor already send grid message to that node
	if (iph->saddr() > my_id_)
	{
		for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_)
		{
			if (sa->a_->id_ == nb->id_)
			{
				drop(p, " REPEAT");
				return;
			}
		}
	}

	cmh->direction() = hdr_cmn::DOWN;
	cmh->next_hop_ = nb->id_;
	cmh->last_hop_ = my_id_;

	iph->daddr() = nb->id_;

	bhh->last_ = bhh->prev_;
	bhh->prev_ = *this;

	send(p, 0);
}

node*
GridDynamicAgent::getNeighborByBoundhole(Point * p, Point * prev)
{
	Angle max_angle = -1;
	node* nb = NULL;

	for (node * temp = neighbor_list_; temp; temp = temp->next_)
	{
		Angle a = G::angle(this, p, this, temp);
		if (a > max_angle && !G::is_intersect(this, temp, p, prev))
		{
			max_angle = a;
			nb = temp;
		}
	}

	return nb;
}

void
GridDynamicAgent::addData(Packet* p)
{
	struct hdr_cmn 	*cmh = HDR_CMN(p);
	struct hdr_grid *bhh = HDR_GRID(p);
	GridOfflinePacketData *data = (GridOfflinePacketData*)p->userdata();

	// Add data to packet
	if (cmh->num_forwards_ == 1)
	{
		if (fmod(bhh->i_.x_, r_) == 0)	// i lies in vertical line
		{
			if 		(this->x_ > bhh->i_.x_)	bhh->i_.x_ += r_ / 2;
			else if (this->x_ < bhh->i_.x_)	bhh->i_.x_ -= r_ / 2;
			else // (this->x_ == bhh->i_.x_)
			{
				if (this->y_ > bhh->i_.y_)	bhh->i_.x_ += r_ / 2;
				else 						bhh->i_.x_ -= r_ / 2;
			}
		}
		if (fmod(bhh->i_.y_, r_) == 0)	// i lies in h line
		{
			if 		(this->y_ > bhh->i_.y_)	bhh->i_.y_ += r_ / 2;
			else if (this->y_ < bhh->i_.y_)	bhh->i_.y_ -= r_ / 2;
			else // (this->y_ == bhh->i_.y_)
			{
				if (this->x_ > bhh->i_.x_)	bhh->i_.y_ -= r_ / 2;
				else 						bhh->i_.y_ += r_ / 2;
			}
		}

		bhh->i_.x_ = ((int)(bhh->i_.x_ / r_) + 0.5) * r_;
		bhh->i_.y_ = ((int)(bhh->i_.y_ / r_) + 0.5) * r_;
	}

	Point i[4];
	Line l = G::line(bhh->prev_, this);

	while ((fabs(this->x_ - bhh->i_.x_) > r_ / 2) || (fabs(this->y_ - bhh->i_.y_) > r_ / 2))
	{
		i[Up].x_ 	= bhh->i_.x_;		i[Up].y_ 	= bhh->i_.y_ + r_;
		i[Left].x_	= bhh->i_.x_ - r_;	i[Left].y_ 	= bhh->i_.y_;
		i[Down].x_	= bhh->i_.x_;		i[Down].y_ 	= bhh->i_.y_ - r_;
		i[Right].x_ = bhh->i_.x_ + r_;	i[Right].y_ = bhh->i_.y_;

		int m = this->x_ > bhh->prev_.x_ ? Right : Left;
		int n = this->y_ > bhh->prev_.y_ ? Up : Down;

		if (G::distance(i[m], l) > G::distance(i[n], l)) m = n;
		data->addData(m);
		bhh->i_ = i[m];
		cmh->size() = 68 + ceil((double)data->size() / 4);		// 68 bytes is default of cmh and iph header
	}
}

// ------------------------ Create PolygonHole ------------------------ //

void
GridDynamicAgent::createGridHole(Packet* p, Point point)
{
	// printf("%f - createGridHole\n", Scheduler::instance().clock());

	gridHole* newhole = new gridHole();
	newhole->next_ = hole_;
	hole_ = newhole;

	// get a, x0, y0
	GridOfflinePacketData* data = (GridOfflinePacketData*)p->userdata();

	int nx = ceil(limit_x_ / r_);
	int ny = ceil(limit_y_ / r_);

	newhole->a_ = (bool**)malloc((nx) * sizeof(bool*));
	for (int i = 0; i < nx; i++)
	{
		newhole->a_[i] = (bool*) malloc((ny) * sizeof(bool));
	}
	for (int i = 0; i < nx; i++)
	for (int j = 0; j < ny; j++)
	{
		newhole->a_[i][j] = 0;
	}

	int x = point.x_ / r_;
	int y = point.y_ / r_;
	newhole->a_[x][y] = 1;
	for (int i = 1; i <= data->size(); i++)
	{
		switch (data->getData(i))
		{
			case Up:	y++;	break;
			case Left:	x--;	break;
			case Down:	y--;	break;
			case Right:	x++;	break;
		}
		newhole->a_[x][y] = 1;
	}

	createPolygonHole(newhole);
}

bool
GridDynamicAgent::updateGridHole(Packet* p, gridHole* hole)
{
	// printf("%f - updateGridHole\n", Scheduler::instance().clock());

	hdr_griddynamic* hdg = HDR_GRIDDYNAMIC(p);
	GridOfflinePacketData* data = (GridOfflinePacketData*) p ->userdata();

	bool re = false;

	int x = hdg->p_.x_ / r_;
	int y = hdg->p_.y_ / r_;

	if (!hole->a_[x][y]) re = hole->a_[x][y] = 1;

	for (int i = 1; i <= data->size(); i++)
	{
		switch (data->getData(i))
		{
			case Up:	y++;	break;
			case Left:	x--;	break;
			case Down:	y--;	break;
			case Right:	x++;	break;
		}

		if (!hole->a_[x][y]) re = hole->a_[x][y] = 1;
	}

	if (re)
	{
		createPolygonHole(hole);
	}

	return re;
}

void
GridDynamicAgent::createPolygonHole(gridHole* hole)
{
	// printf("%f - createPolygonHole\n", Scheduler::instance().clock());

	hole->clearNodeList();

	int nx = ceil(limit_x_ / r_);
	int ny = ceil(limit_y_ / r_);

	// find the leftist cell that painted in the lowest row
	int y = 0;
	int x = nx - 1;
	do {
		x = nx - 1;
		while (x >= 0 && hole->a_[x][y] == 0) x--;
		if (x >= 0) break;
		y ++;
	} while (y < ny);

	node* sNode = new node();
	sNode->x_ = (x + 1) * r_;
	sNode->y_ = y * r_;
	sNode->next_ = hole->node_list_;
	hole->node_list_ = sNode;

	while (x >= 0 && hole->a_[x][y] == 1) x--; // find the end cell of serial painted cell from left to right in the lowest row
	x++;
	Point n, u;
	n.x_ = x * r_;
	n.y_ = y * r_;

	while (n.x_ != sNode->x_ || n.y_ != sNode->y_)
	{
		u = *(hole->node_list_);

		node* newNode = new node();
		newNode->x_ = n.x_;
		newNode->y_ = n.y_;
		newNode->next_ = hole->node_list_;
		hole->node_list_ = newNode;

		if (u.y_ == n.y_)
		{
			if (u.x_ < n.x_)		// >
			{
				if (y + 1 < ny && x + 1 < nx && hole->a_[x + 1][y + 1])
				{
					x += 1;
					y += 1;
					n.y_ += r_;
				}
				else if (x + 1 < nx && hole->a_[x + 1][y])
				{
					x += 1;
					n.x_ += r_;
					hole->node_list_ = newNode->next_;
					delete newNode;
				}
				else
				{
					n.y_ -= r_;
				}
			}
			else // u->x_ > v->x_			// <
			{
				if (y - 1 >= 0 && x - 1 >= 0 && hole->a_[x - 1][y - 1])
				{
					x -= 1;
					y -= 1;
					n.y_ -= r_;
				}
				else if (x - 1 >= 0 && hole->a_[x - 1][y])
				{
					x -= 1;
					n.x_ -= r_;
					hole->node_list_ = newNode->next_;
					delete newNode;
				}
				else
				{
					n.y_ += r_;
				}
			}
		}
		else	// u->x_ == v->x_
		{
			if (u.y_ < n.y_)		// ^
			{
				if (y + 1 < ny && x - 1 >= 0 && hole->a_[x - 1][y + 1])
				{
					x -= 1;
					y += 1;
					n.x_ -= r_;
				}
				else if (y + 1 < ny && hole->a_[x][y + 1])
				{
					y += 1;
					n.y_ += r_;
					hole->node_list_ = newNode->next_;
					delete newNode;
				}
				else
				{
					n.x_ += r_;
				}
			}
			else // u.x > n.x		// v
			{
				if (y - 1 >= 0 && x + 1 < nx && hole->a_[x + 1][y - 1])
				{
					x += 1;
					y -= 1;
					n.x_ += r_;
				}
				else if (y - 1 >= 0 && hole->a_[x][y - 1])
				{
					y -= 1;
					n.y_ -= r_;
					hole->node_list_ = newNode->next_;
					delete newNode;
				}
				else
				{
					n.x_ -= r_;
				}
			}
		}
	}

	// reduce polygon hole
	reducePolygonHole(hole);

	hole->circleNodeList();

	dumpBoundhole(hole);
}

void
GridDynamicAgent::reducePolygonHole(gridHole* h)
{
	// printf("%f - reducePolygonHole\n", Scheduler::instance().clock());

	if (limit_ >= 4)
	{
		int count = 0;
		for (node* n = h->node_list_; n != NULL; n = n->next_) count++;

		//h->circleNodeList();
		node* temp = h->node_list_;
		while (temp->next_ && temp->next_ != h->node_list_) temp = temp->next_;
		temp->next_ = h->node_list_;

		// reduce hole
		node* gmin;
		int min;
		Point r;

		for (; count > limit_; count-= 2)
		{
			min = MAXINT;

			node* g = h->node_list_;
			do
			{
				node* g1 = g->next_;
				node* g2 = g1->next_;
				node* g3 = g2->next_;

				if (G::angle(g2, g1, g2, g3) > M_PI)
				{
				//	int t = fabs(g3->x_ - g2->x_) + fabs(g2->y_ - g1->y_) + fabs(g3->y_ - g2->y_) + fabs(g2->x_ - g1->x_);	// conditional is boundary length
					int t = fabs(g3->x_ - g2->x_) * fabs(g2->y_ - g1->y_) + fabs(g3->y_ - g2->y_) * fabs(g2->x_ - g1->x_);	// conditional is area
					if (t < min)
					{
						gmin = g;
						min  = t;
						r.x_ = g1->x_ + g3->x_ - g2->x_;
						r.y_ = g1->y_ + g3->y_ - g2->y_;
					}
				}

				g = g1;
			}
			while (g != h->node_list_);

			if (r == *(gmin->next_->next_->next_->next_))
			{
				node* temp = gmin->next_;
				gmin->next_ = gmin->next_->next_->next_->next_->next_;

				delete temp->next_->next_->next_;
				delete temp->next_->next_;
				delete temp->next_;
				delete temp;

				count-= 2;
			}
			else
			{
				node* newNode = new node();
				newNode->x_ = r.x_;
				newNode->y_ = r.y_;
				newNode->next_ = gmin->next_->next_->next_->next_;

				delete gmin->next_->next_->next_;
				delete gmin->next_->next_;
				delete gmin->next_;

				gmin->next_ = newNode;
			}

			h->node_list_ = gmin;
		}
	}
}

// ------------------------ Broadcast hole -----------------------//

void
GridDynamicAgent::sendBroadcast(Packet* pa)
{
	// printf("%f - sendBroadcast\n", Scheduler::instance().clock());

	Packet			*p   = allocpkt();
	hdr_cmn			*cmh = HDR_CMN(p);
	hdr_ip			*iph = HDR_IP(p);
	hdr_griddynamic	*bhn = HDR_GRIDDYNAMIC(p);

	GridOfflinePacketData* data = (GridOfflinePacketData*) pa->userdata()->copy();
	p->setdata(data);

	cmh->ptype() 	 = PT_GRIDDYNAMIC;
	cmh->direction() = hdr_cmn::DOWN;
	cmh->size() 	+= IP_HDR_LEN + bhn->size() + ceil(data->size() / 8);
	cmh->next_hop_	 = IP_BROADCAST;
	cmh->last_hop_ 	 = my_id_;
	cmh->addr_type_  = NS_AF_INET;

	iph->daddr() = IP_BROADCAST;
	iph->sport() = RT_PORT;
	iph->dport() = RT_PORT;

	bhn->id_	= my_id_;
	bhn->p_.x_	= x_;
	bhn->p_.y_	= y_;
	bhn->type_	= GRID_BROADCAST;

	send(p, 0);
}

void
GridDynamicAgent::recvBroadcast(Packet* p)
{
	// printf("%f - recvBroadcast\n", Scheduler::instance().clock());

	hdr_cmn			*cmh = HDR_CMN(p);
	hdr_ip			*iph = HDR_IP(p);
	hdr_griddynamic	*hgd = HDR_GRIDDYNAMIC(p);

	gridHole* h = hole_;
	while (h != NULL && h->hole_id_ != hgd->id_)
	{
		h = h->next_;
	}

	bool forward = false;

	if (h == NULL)
	{
		// create new hole
		createGridHole(p, hgd->p_);
		hole_->hole_id_ = hgd->id_;

		forward = true;
	}
	else
	{
		// update hole
		forward = updateGridHole(p, h);
	}


	if (forward)
	{
		cmh->ptype() 	 = PT_GRIDDYNAMIC;
		cmh->direction() = hdr_cmn::DOWN;
		cmh->next_hop_	 = IP_BROADCAST;
		cmh->last_hop_ 	 = my_id_;
		cmh->addr_type_  = NS_AF_INET;

		iph->daddr() = IP_BROADCAST;
		iph->sport() = RT_PORT;
		iph->dport() = RT_PORT;

		send(p, 0);
	}
}

// ------------------------ Dynamic process --------------------------- //

void
GridDynamicAgent::checkState()
{
//	if (my_id_ == pivot.id_)
//	{
//		// printf("%f - checkState\n", Scheduler::instance().clock());
//
//		for (neighbor* n = neighbor_list_; n != NULL; n = (neighbor*)n->next_)
//		{
//			if ((Scheduler::instance().clock() - n->time_) > (3 * hello_period_))
//			{
//				sendAlarm();
//			}
//		}
//
//		updateSta_timer_.resched(hello_period_);
//	}
}

/* return true if point is in same cell with this node */
bool
GridDynamicAgent::checkCell(Point point)
{
	return ((int)(point.x_ / r_) == (int)(this->x_ / r_) && (int)(point.y_ / r_) == (int)(this->y_ / r_));
}

void
GridDynamicAgent::sendElection()
{
	// printf("%f - sendElection\n", Scheduler::instance().clock());
	dumpElection();

	pivot.id_	= this->my_id_;
	pivot.x_	= this->x_;
	pivot.y_	= this->y_;

	updateSta_timer_.resched(5 * hello_period_);

	Packet 				* p		= allocpkt();
	hdr_cmn				* cmh	= HDR_CMN(p);
	hdr_ip				* iph	= HDR_IP(p);
	hdr_griddynamic		* bhh	= HDR_GRIDDYNAMIC(p);
	BoundHolePacketData * data	= new BoundHolePacketData();

	p->setdata(data);

	data->add(my_id_, x_, y_);

	cmh->ptype() 	 = PT_GRIDDYNAMIC;
	cmh->direction() = hdr_cmn::DOWN;
	cmh->size() 	+= IP_HDR_LEN + bhh->size() + data->size();
	cmh->next_hop_	 = IP_BROADCAST;
	cmh->last_hop_ 	 = my_id_;
	cmh->addr_type_  = NS_AF_INET;

	iph->saddr() = my_id_;
	iph->daddr() = IP_BROADCAST;
	iph->sport() = RT_PORT;
	iph->dport() = RT_PORT;

	bhh->type_	= GRID_ELECTION;
	bhh->p_ 	= *this;
	bhh->id_ 	= this->my_id_;
	bhh->value_ = 0;

	send(p, 0);
}

void
GridDynamicAgent::recvElection(Packet* p)
{
	// printf("%f - recvElection\n", Scheduler::instance().clock());

	// can be more optimize by local minimum

	hdr_griddynamic		*hgd 	= HDR_GRIDDYNAMIC(p);
	BoundHolePacketData	*data 	= (BoundHolePacketData*)p->userdata();

	if (!checkCell(hgd->p_))
	{
		drop(p, "DIFFERENT_CELL");
		return;
	}

	bool forward = false;

	double s = 0;
	for (int i = 1; i <= data->size(); i++)
	{
		s += G::distance(data->get_data(i), this);
	}

	if (s > hgd->value_)
	{
		// update new pivot
		hgd->value_	= s;

		pivot.x_ 	= hgd->p_.x_ 	= this->x_;
		pivot.y_ 	= hgd->p_.y_ 	= this->y_;
		pivot.id_	= hgd->id_		= my_id_;

		updateSta_timer_.resched(5 * hello_period_);

		dumpElection();

		forward = true;
	}
	else if (pivot.id_ == -1)
	{
		pivot.x_ 	= hgd->p_.x_;
		pivot.y_ 	= hgd->p_.y_;
		pivot.id_	= hgd->id_;
		forward = true;
	}

	if (isBoundary && data->indexOf(my_id_, x_, y_) == -1)
	{
		data->add(my_id_, x_, y_);
		hgd->value_ += G::distance(hgd->p_, this);
		forward = true;
	}

	if (forward)
	{
		hdr_cmn	*cmh = HDR_CMN(p);
		hdr_ip	*iph = HDR_IP(p);

		cmh->direction() = hdr_cmn::DOWN;
		cmh->next_hop_	 = IP_BROADCAST;
		cmh->last_hop_ 	 = my_id_;
		cmh->addr_type_  = NS_AF_INET;
		cmh->size_		 = 68 + hgd->size() + data->size();

		iph->saddr() = my_id_;
		iph->daddr() = IP_BROADCAST;
		iph->sport() = RT_PORT;
		iph->dport() = RT_PORT;

		send(p, 0);
	}
}

void
GridDynamicAgent::sendAlarm()
{
	// printf("%f - sendAlarm\n", Scheduler::instance().clock());

	dumpAlarm();

	pivot.id_	= -1;

	Packet 				* p		= allocpkt();
	hdr_cmn				* cmh	= HDR_CMN(p);
	hdr_ip				* iph	= HDR_IP(p);
	hdr_griddynamic		* bhh	= HDR_GRIDDYNAMIC(p);

	cmh->ptype() 	 = PT_GRIDDYNAMIC;
	cmh->direction() = hdr_cmn::DOWN;
	cmh->size() 	+= IP_HDR_LEN + bhh->size();
	cmh->next_hop_	 = IP_BROADCAST;
	cmh->last_hop_ 	 = my_id_;
	cmh->addr_type_  = NS_AF_INET;

	iph->saddr() = my_id_;
	iph->daddr() = IP_BROADCAST;
	iph->sport() = RT_PORT;
	iph->dport() = RT_PORT;

	bhh->type_	= GRID_ALARM;
	bhh->p_		= *this;

	send(p, 0);
}

void
GridDynamicAgent::recvAlarm(Packet* p)
{
	// printf("%f - recvAlarm\n", Scheduler::instance().clock());

	hdr_griddynamic		* bhh	= HDR_GRIDDYNAMIC(p);

	if (checkCell(bhh->p_))
	{
		if (pivot.id_ == -1)
		{
			drop(p, "REAPEAD_ALARM");
		}
		else
		{
			pivot.id_	= -1;

			hdr_cmn	* cmh	= HDR_CMN(p);
			hdr_ip	* iph	= HDR_IP(p);

			cmh->direction() = hdr_cmn::DOWN;
			cmh->next_hop_	 = IP_BROADCAST;
			cmh->addr_type_  = NS_AF_INET;

			iph->daddr() = IP_BROADCAST;
			iph->sport() = RT_PORT;
			iph->dport() = RT_PORT;

			send(p, 0);
		}
	}
	else
	{
		sendElection();
		drop(p, "RECV_ALARM");
	}
}

// --------------------- Send data -------------------------------- //

void
GridDynamicAgent::sendData(Packet* p)
{
	// printf("%f - sendData\n", Scheduler::instance().clock());

	hdr_cmn*			cmh = HDR_CMN(p);
	hdr_ip*				iph = HDR_IP(p);
	hdr_griddynamic* 	edh = HDR_GRIDDYNAMIC(p);

	cmh->size() += IP_HDR_LEN + edh->size();
	cmh->direction_ = hdr_cmn::DOWN;

	edh->type_	= GRID_DATA;
	edh->id_ 	= iph->daddr();
	edh->p_		= *this;
	edh->d_		= *dest;

	iph->saddr() = my_id_;
	iph->daddr() = -1;
	iph->ttl_ 	 = 3 * IP_DEF_TTL;
}

void
GridDynamicAgent::recvData(Packet* p)
{
	// printf("%f - recvData\n", Scheduler::instance().clock());

	struct hdr_cmn*			cmh = HDR_CMN(p);
	struct hdr_griddynamic*	edh = HDR_GRIDDYNAMIC(p);

	if (cmh->direction() == hdr_cmn::UP	&& edh->id_ == my_id_)	// up to destination
	{
		dumpHopcount(p);
		port_dmux_->recv(p, 0);
		return;
	}
	else
	{
		node * nexthop = getNeighborByGreedy(edh->p_);

		if (nexthop == NULL)	// no neighbor close
		{
			edh->p_ = getAnchorPoint(edh->d_);
			nexthop = getNeighborByGreedy(edh->p_);

			if (nexthop == NULL)
			{
				drop(p, DROP_RTR_NO_ROUTE);
				return;
			}
		}

		cmh->direction() = hdr_cmn::DOWN;
		cmh->addr_type() = NS_AF_INET;
		cmh->last_hop_ = my_id_;
		cmh->next_hop_ = nexthop->id_;
		send(p, 0);
	}
}

Point
GridDynamicAgent::getAnchorPoint(Point dest)
{
	Point anchor = dest;

	gridHole* i = NULL;		// the nearest hole
	double m = MAXINT;		// distance to nearest hole

	for (gridHole* h = hole_; h != NULL; h = h->next_)
	{
		// check if line is intersection with hole => need to routing to avoid this hole
		int numIntersect = 0;
		node * n = h->node_list_;
		do
		{
			if (G::is_in_line(n, this, dest) && G::is_in_line(n->next_, this, dest)) break;
			if (G::is_intersect(n, n->next_, this, dest)) numIntersect++;
			n = n->next_;
		}
		while(n != h->node_list_ && numIntersect < 2);

		if (numIntersect > 1)
		{
			double d = 0;
			n = h->node_list_;

			do
			{
				double t = G::distance(n, this);
				if (t > d) d = t;

				n = n->next_;
			}
			while(n != h->node_list_);

			if (d > m)
			{
				m = d;
				i = h;
			}
		}
	}

	if (i != NULL)
	{
		// create routing table for packet p
		node* S1;	// min angle view of this node to hole
		node* S2;	// max angle view of this node to hole
		node* D1;	// min angle view of Dt node to hole
		node* D2;	// max angle view of Dt node to hole
		node* re;	// result point

		// ------------------- S1 S2 - view angle of this node to hole
		double Smax = 0;
		double Dmax = 0;

		node* n = i->node_list_;
		do {
			for (node* m = n->next_; m != i->node_list_; m = m->next_)
			{
				// S1 S2
				double angle = G::angle(this, n, m);
				if (angle > Smax)
				{
					Smax = angle;
					S1 = n;
					S2 = m;
				}
				// D1 D2
				angle = G::angle(dest, n, m);
				if (angle > Dmax)
				{
					Dmax = angle;
					D1 = n;
					D2 = m;
				}
			}
			n = n->next_;
		} while(n != i->node_list_);

		// if S1 and D1 are lie in different side of SD => switch D1 and D2
		Line SD = G::line(this, dest);
		if (G::position(S1, SD) != G::position(D1, SD))
		{
			node* temp = D1;
			D1 = D2;
			D2 = temp;
		}

		double min = DBL_MAX;
		// ------------------------------------------------- S S1 D1 D
		double dis = G::distance(this, S1);
		for (node * i = S1; i != D1; i = i-> next_)
		{
			dis += G::distance(i, i->next_);
		}
		dis += G::distance(D1, dest);
		if (dis < min)
		{
			min = dis;
			re = S1;
		}

		// ------------------------------------------------- S S2 D2 D
		dis = G::distance(this, S2);
		for (node * i = S2; i != D2; i = i->next_)
		{
			dis += G::distance(i, i->next_);
		}
		dis += G::distance(D2, dest);
		if (dis < min)
		{
			min = dis;
			re = S2;
		}

		// ------------------------------------------------- D D1 S1 S
		dis = G::distance(dest, D1);
		for (node * i = D1; i != S1; i = i->next_)
		{
			dis += G::distance(i, i->next_);
		}
		dis += G::distance(S1, this);
		if (dis < min)
		{
			min = dis;
			re = S1;
		}

		// ------------------------------------------------- D D2 S2 S
		dis = G::distance(dest, D2);
		for (node * i = D2; i != S2; i = i->next_)
		{
			dis += G::distance(i, i->next_);
		}
		dis += G::distance(S2, this);
		if (dis < min)
		{
			min = dis;
			re = S2;
		}

		anchor = *re;
	}

	return anchor;
}

// ------------------------ Dump ------------------------ //

void
GridDynamicAgent::dumpBoundhole(gridHole* p)
{
	FILE *fp = fopen("PolygonHole.tr", "a+");

	node* n = p->node_list_;
	do {
		fprintf(fp, "%f	%f\n", n->x_, n->y_);
		n = n->next_;
	} while (n && n != p->node_list_);

	fprintf(fp, "%f	%f\n\n", p->node_list_->x_, p->node_list_->y_);
	fclose(fp);
}

void
GridDynamicAgent::dumpArea(gridHole* hole)
{
	FILE * fp = fopen("Area.tr", "a+");
	fprintf(fp, "%f\t%f\n", Scheduler::instance().clock(), G::area(hole->node_list_));
	fclose(fp);
}

void GridDynamicAgent::dumpElection()
{
	FILE * fp = fopen("Election.tr", "a+");
	fprintf(fp, "%f\t%d\t%f\t%f\n", Scheduler::instance().clock(), my_id_, x_, y_);
	fclose(fp);
}

void GridDynamicAgent::dumpAlarm()
{
	FILE * fp = fopen("Alarm.tr", "a+");
	fprintf(fp, "%f\t%d\t%f\t%f\n", Scheduler::instance().clock(), my_id_, x_, y_);
	fclose(fp);
}
