#include <packet.h>
#include <stack>
#include "nhr_packet.h"
#include "nhr_packet_data.h"
#include <wsn/graph/voronoi/VoronoiDiagram.h>
#include <queue>

int hdr_nhr::offset_;

static class NHRHeaderClass : public PacketHeaderClass {
public:
    NHRHeaderClass() : PacketHeaderClass("PacketHeader/NHR", sizeof(hdr_nhr)) {
        bind_offset(&hdr_nhr::offset_);
    }
} class_nhrhdr;

static class NHRAgentClass : public TclClass {
public:
    NHRAgentClass() : TclClass("Agent/NHR") { }

    TclObject *create(int, const char *const *) {
        return (new NHRAgent());
    }
} class_nhr;

/*------------- Agent -------------*/
NHRAgent::NHRAgent() : BoundHoleAgent(), broadcast_timer_(this) {
    // initialize default value
    endpoint_.x_ = this->x_;
    endpoint_.y_ = this->y_; // default: endpoint of node is itself
    limit_angle_ = M_PI * 2 / 3;

    bind("limit_angle_", &limit_angle_);

    FILE *fp;
    fp = fopen("Neighbors.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastRegion.tr", "w");
    fclose(fp);
    fp = fopen("Dump.tr", "w");
    fclose(fp);
    fp = fopen("Voronoi.tr", "w");
    fclose(fp);
}

void NHRAgent::recv(Packet *p, Handler *h) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);

    switch (cmh->ptype()) {
        case PT_NHR:
            recvHCI(p);
            break;
        case PT_CBR:
            if (iph->saddr() == my_id_)                // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)        // a new packet
                {
                    sendData(p);
                }
                else    //(cmh->num_forwards() > 0)	// routing loop -> drop
                {
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                drop(p, DROP_RTR_TTL);
                return;
            }
            recvData(p);
            break;

        default:
            BoundHoleAgent::recv(p, h);
            break;
    }
}

int NHRAgent::command(int argc, const char *const *argv) {
    return BoundHoleAgent::command(argc, argv);
}

/*------------- Hole approximation -------------*/
void NHRAgent::createHole(Packet *p) {
    int i = 0;
    vector<BoundaryNode> convex;

    polygonHole *h = createPolygonHole(p);
    for (struct node *node_tmp = h->node_list_; node_tmp; node_tmp = node_tmp->next_) {
        BoundaryNode bn;
        bn.x_ = node_tmp->x_;
        bn.y_ = node_tmp->y_;
        bn.is_convex_hull_boundary_ = false;
        bn.id_ = node_tmp->id_;
        hole_.push_back(bn);
    }
    delete h;

    // 1. Determine convex hull of hole using Graham scan algorithm
    convex = determineConvexHull();

    // 2. Approximate hole
    approximateHole(convex);

    // 3. Determine caves - rotate hole list, i.e. the first element is convex hull boundary
    i = 0;
    while (!hole_[i].is_convex_hull_boundary_) i++;
    rotate(hole_.begin(), hole_.begin() + i, hole_.end());
    hole_.push_back(hole_[0]); // circulate the hole list

    dump();
}

vector<BoundaryNode> NHRAgent::determineConvexHull() {
    stack<BoundaryNode *> hull;
    vector<BoundaryNode> convex;
    vector<BoundaryNode *> clone_hole;

    for (std::vector<BoundaryNode>::iterator it = hole_.begin(); it != hole_.end(); ++it) {
        clone_hole.push_back(&(*it));
    }

    std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
    BoundaryNode *pivot = clone_hole.front();
    std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
    hull.push(clone_hole[0]);
    hull.push(clone_hole[1]);
    hull.push(clone_hole[2]);

    for (int i = 3; i < clone_hole.size(); i++) {
        BoundaryNode *top = hull.top();
        hull.pop();
        while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
            top = hull.top();
            hull.pop();
        }
        hull.push(top);
        hull.push(clone_hole[i]);
    }

    while (!hull.empty()) {
        BoundaryNode *top = hull.top();
        top->is_convex_hull_boundary_ = true;
        convex.push_back(*top);
        hull.pop();
    }

    return convex;
}

void NHRAgent::approximateHole(vector<BoundaryNode> convex) {
    /*
	 * define 8 lines for new approximate hole
	 *
	 * 		    ____[2]_________
	 * 		[02]	 			[21]______
	 * 	   /		 					  \
	 * 	[0] ----------------------------- [1]
	 * 	   \____                       ___/
	 * 			[30]____   ________[13]
	 * 					[3]
	 */
    int i, j;
    int n0, n1, n2, n3; // index of node h(p), h(q), h(k), h(j)
    Line bl;            // base line
    Line l0;            // line contain n0 and perpendicular with base line
    Line l1;            // line contain n1 and perpendicular with base line
    Line l2;            // line contain n2 and parallel with base line
    Line l3;            // line contain n3 and parallel with base line
    double longest_distance = 0;

    // find couple node that have maximum distance - n0, n1
    for (i = 0; i < convex.size(); i++) {
        for (j = i; j < convex.size(); j++) {
            double tmp_distance = G::distance(convex[i], convex[j]);
            if (longest_distance < tmp_distance) {
                longest_distance = tmp_distance;
                n0 = i;
                n1 = j;
            }
        }
    }

    bl = G::line(convex[n0], convex[n1]); // bl = H(p)H(q)
    l0 = G::perpendicular_line(convex[n0], bl);
    l1 = G::perpendicular_line(convex[n1], bl);

    // find n2 and n3 - with maximum distance from base line
    longest_distance = 0;
    for (i = 0; i < convex.size(); i++) {
        double tmp_distance = G::distance(convex[i], bl);
        if (tmp_distance > longest_distance) {
            longest_distance = tmp_distance;
            n2 = i;
        }
    }
    longest_distance = 0;
    for (i = 0; i < convex.size(); i++) {
        double tmp_distance = G::distance(convex[i], bl);
        if (tmp_distance > longest_distance && G::position(convex[n2], bl) * G::position(convex[i], bl) < 0) {
            longest_distance = tmp_distance;
            n3 = i;
        }
    }

    l2 = G::parallel_line(convex[n2], bl);
    l3 = G::parallel_line(convex[n3], bl);

    // approximate hole
    BoundaryNode itsp; // intersect point (tmp)
    Line itsl;  // intersect line (tmp)
    double mc;

    // l02 intersection l0 and l2
    G::intersection(l0, l2, itsp);
    itsl = G::angle_bisector(convex[n0], convex[n1], itsp);
    longest_distance = 0;
    mc = 0;
    for (i = 0; i < convex.size(); i++) {
        itsl.c_ = -(itsl.a_ * convex[i].x_ + itsl.b_ * convex[i].y_);
        double tmp_distance = G::distance(convex[n3], itsl);
        if (tmp_distance > longest_distance) {
            longest_distance = tmp_distance;
            mc = itsl.c_;
        }
    }
    itsl.c_ = mc;
    G::intersection(l0, itsl, itsp);
    octagon_hole_.push_back(itsp);
    G::intersection(l2, itsl, itsp);
    octagon_hole_.push_back(itsp);

    // l21 intersection l2 and l1
    G::intersection(l1, l2, itsp);
    itsl = G::angle_bisector(convex[n1], convex[n0], itsp);
    longest_distance = 0;
    mc = 0;
    for (i = 0; i < convex.size(); i++) {
        itsl.c_ = -(itsl.a_ * convex[i].x_ + itsl.b_ * convex[i].y_);
        double tmp_distance = G::distance(convex[n3], itsl);
        if (tmp_distance > longest_distance) {
            longest_distance = tmp_distance;
            mc = itsl.c_;
        }
    }
    itsl.c_ = mc;
    G::intersection(l2, itsl, itsp);
    octagon_hole_.push_back(itsp);
    G::intersection(l1, itsl, itsp);
    octagon_hole_.push_back(itsp);

    // l13 intersection l1 and l3
    G::intersection(l1, l3, itsp);
    itsl = G::angle_bisector(convex[n1], convex[n0], itsp);
    longest_distance = 0;
    mc = 0;
    for (i = 0; i < convex.size(); i++) {
        itsl.c_ = -(itsl.a_ * convex[i].x_ + itsl.b_ * convex[i].y_);
        double dis = G::distance(convex[n2], itsl);
        if (dis > longest_distance) {
            longest_distance = dis;
            mc = itsl.c_;
        }
    }
    itsl.c_ = mc;
    G::intersection(l1, itsl, itsp);
    octagon_hole_.push_back(itsp);
    G::intersection(l3, itsl, itsp);
    octagon_hole_.push_back(itsp);

    // l30 intersection l3 and l0
    G::intersection(l0, l3, itsp);
    itsl = G::angle_bisector(convex[n0], convex[n1], itsp);
    longest_distance = 0;
    mc = 0;
    for (i = 0; i < convex.size(); i++) {
        itsl.c_ = -(itsl.a_ * convex[i].x_ + itsl.b_ * convex[i].y_);
        double dis = G::distance(convex[n2], itsl);
        if (dis > longest_distance) {
            longest_distance = dis;
            mc = itsl.c_;
        }
    }
    itsl.c_ = mc;
    G::intersection(l3, itsl, itsp);
    octagon_hole_.push_back(itsp);
    G::intersection(l0, itsl, itsp);
    octagon_hole_.push_back(itsp);
}

/*------------- Broadcast phase -------------*/
void NHRAgent::broadcastHCI() {
    Packet *p = NULL;
    NHRPacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_nhr *hhr;

    if (hole_.empty())
        return;

    p = allocpkt();
    payload = new NHRPacketData();
    for (std::vector<BoundaryNode>::iterator it = octagon_hole_.begin(); it != octagon_hole_.end(); ++it) {
        payload->add(-1, (*it).x_, (*it).y_, false);
    }
    for (std::vector<BoundaryNode>::iterator it = hole_.begin(); it != hole_.end(); ++it) {
        payload->add((*it).id_, (*it).x_, (*it).y_, (*it).is_convex_hull_boundary_);
    }
    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hhr = HDR_NHR(p);

    cmh->ptype() = PT_NHR;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hhr->size();

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 4 * IP_DEF_TTL;

    constructGraph();

    send(p, 0);
}

void NHRAgent::recvHCI(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);

    // if the hci packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        drop(p, "LoopHCI");
        return;
    }
    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    // check if is really receive this hole's information
    if (!hole_.empty())    // already received
    {
        drop(p, "HciReceived");
        return;
    }

    // store hci
    NHRPacketData *data = (NHRPacketData *) p->userdata();
    for (int i = 1; i <= 8; i++) {
        BoundaryNode n = data->get_data(i);
        octagon_hole_.push_back(n);
    }
    for (int i = 9; i <= data->size(); i++) {
        BoundaryNode n = data->get_data(i);
        hole_.push_back(n);
    }

    if (!canBroadcast()) {
        drop(p, "OutsideRegion");
    }
    else {
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0.0, 5.0));
    }

    // construct graph
    constructGraph();

    dumpBroadcastRegion();
}

bool NHRAgent::canBroadcast() {
    vector<BoundaryNode *> convex;

    // construct temporary node list
    polygonHole *node_list = new polygonHole();
    node_list->node_list_ = NULL;
    node_list->next_ = NULL;

    for (int i = 0; i < hole_.size(); i++) {
        if (hole_[i].is_convex_hull_boundary_) {
            convex.push_back(&hole_[i]);
            node *tmp = new node();
            tmp->x_ = hole_[i].x_;
            tmp->y_ = hole_[i].y_;
            tmp->next_ = node_list->node_list_;
            node_list->node_list_ = tmp;
        }
    }

    if (G::isPointInsidePolygon(this, node_list->node_list_)) {
        delete node_list;
        return true;
    }
    delete node_list;

    BoundaryNode pivot;
    pivot.x_ = this->x_;
    pivot.y_ = this->y_;
    sort(convex.begin(), convex.end(), POLAR_ORDER(pivot));

    Angle angle = G::angle((convex[0]), this, (convex[convex.size() - 1]));
    return angle >= limit_angle_;
}

/*------------- Graph construction  phase -------------*/
void NHRAgent::constructGraph() {
    vector<BoundaryNode> cave;
    map<Point, vector<Point> > graph;
    int site_contains_node;
    Point gate_endpoint;
    set<Point> endpoints;

    // reconstruct caves & determine cave containing current node
    // NOTE: if the current node is the gate then return immediately
    for (unsigned int i = 0; i < hole_.size() - 1; i++) {
        if (hole_.at(i).is_convex_hull_boundary_ && this->x_ == hole_.at(i).x_ && this->y_ == hole_.at(i).y_)
            return;
        if (hole_.at(i).is_convex_hull_boundary_ && !hole_.at(i + 1).is_convex_hull_boundary_) {
            cave.push_back(hole_.at(i++));
            while (!hole_.at(i).is_convex_hull_boundary_) {
                cave.push_back(hole_.at(i++));
            }
            cave.push_back(hole_.at(i--));
            if (cave.size() >= MIN_CAVE_VERTEX) {
                polygonHole *node_list = new polygonHole();
                node_list->node_list_ = NULL;
                node_list->next_ = NULL;
                for (unsigned int j = 0; j < cave.size(); j++) {
                    node *tmp = new node();
                    tmp->x_ = cave.at(j).x_;
                    tmp->y_ = cave.at(j).y_;
                    tmp->next_ = node_list->node_list_;
                    node_list->node_list_ = tmp;
                }
                if (G::isPointInsidePolygon(this, node_list->node_list_)) {
                    delete node_list;
                    break;
                }
                vector<BoundaryNode>().swap(cave);
                delete node_list;
            }
        }
    }

    if (cave.empty()) return;

    // 1. check if perpendicular line from current node to gate line intersects with any edge of polygon (except gate) or not
    bool no_voronoi = true;
    Line gate_line = G::line(cave[0], cave[cave.size() - 1]);
    Line perpendicular_line = G::perpendicular_line(this, gate_line);
    Point perpendicular_point;
    G::intersection(gate_line, perpendicular_line, &perpendicular_point);
    for (int i = 0; i < cave.size() - 2; i++) {
        Point ins;
        if (G::lineSegmentIntersection(&cave[i], &cave[i + 1], perpendicular_line, ins) &&
            G::onSegment(this, &ins, &perpendicular_point)) {
            no_voronoi = false;
            break;
        }
    }

    if (no_voronoi) {
        endpoint_.x_ = perpendicular_point.x_;
        endpoint_.y_ = perpendicular_point.y_;
        return;
    }

    // 2. else find endpoint from voronoi graph
    double min_distance = G::distance(this, cave[0]);
    site_contains_node = 0;
    for (int i = 1; i < cave.size(); i++) {
        double tmp_distance = G::distance(this, cave[i]);
        if (min_distance > tmp_distance) {
            min_distance = tmp_distance;
            site_contains_node = cave[i].id_;
        }
    }

    // calculate voronoi diagram
    std::vector<voronoi::VoronoiSite *> sites;

    for (int i = 0; i < cave.size(); i++) {
        BoundaryNode p = cave[i];
        sites.push_back(new voronoi::VoronoiSite(p.id_, p.x_, p.y_));
    }

    voronoi::VoronoiDiagram *diagram = voronoi::VoronoiDiagram::create(sites);

    // validate voronoi vertices (i.e. remove vertices outside the polygon)
    // find rectangle boundary of polygon
    double min_x, max_x, min_y, max_y;
    min_x = cave[0].x_;
    max_x = cave[0].x_;
    min_y = cave[0].x_;
    max_y = cave[0].x_;
    for (int i = 1; i < cave.size(); i++) {
        if (cave[i].x_ < min_x) {
            min_x = cave[i].x_;
        } else if (cave[i].x_ > max_x) {
            max_x = cave[i].x_;
        }
        if (cave[i].y_ < min_y) {
            min_y = cave[i].y_;
        } else if (cave[i].y_ > max_y) {
            max_y = cave[i].y_;
        }
    }

    for (std::set<geometry::Point>::iterator it = diagram->vertices().begin(); it != diagram->vertices().end();) {
        Point tmp_point;
        tmp_point.x_ = (*it).x();
        tmp_point.y_ = (*it).y();
        if (!validateVoronoiVertex(tmp_point, cave, min_x, max_x, min_y, max_y)) {
            diagram->vertices().erase(it++);
        } else {
            ++it;
        }
    }

    // construct graph
    for (std::vector<voronoi::VoronoiEdge *>::iterator it = diagram->edges().begin();
         it != diagram->edges().end(); ++it) {
        Point p1, p2;
        p1.x_ = (*it)->edge().startPoint().x();
        p1.y_ = (*it)->edge().startPoint().y();
        p2.x_ = (*it)->edge().endPoint().x();
        p2.y_ = (*it)->edge().endPoint().y();
        bool b1 = diagram->vertices().find((*it)->edge().startPoint()) != diagram->vertices().end();
        bool b2 = diagram->vertices().find((*it)->edge().endPoint()) != diagram->vertices().end();
        if (b1 && b2) {
            if ((*it)->leftSite().id() == site_contains_node || (*it)->rightSite().id() == site_contains_node) {
                endpoints.insert(p1);
                endpoints.insert(p2);
            }
            addVertexToGraph(graph, p1, p2);
        } else if (b1 || b2) { // determine gate point
            Line pp = G::line(p1, p2);
            Point ins;
            if (G::lineSegmentIntersection(&cave[0], &cave[cave.size() - 1], pp, ins) &&
                G::onSegment(p1, ins, p2)) {
                addVertexToGraph(graph, b1 ? p1 : p2, ins);
                gate_endpoint.x_ = ins.x_;
                gate_endpoint.y_ = ins.y_;
            }
        }
    }
    delete diagram;
    findShortestPath(graph, gate_endpoint, endpoints);
    dumpVoronoi(cave, graph);
}

bool NHRAgent::validateVoronoiVertex(Point p, vector<BoundaryNode> polygon,
                                     double min_x, double max_x, double min_y, double max_y) {
    if (p.x_ < min_x || p.x_ > max_x || p.y_ < min_y || p.y_ > max_y)
        return false;

    bool odd = false;
    int i, j;

    for (i = 0, j = (int) polygon.size() - 1; i < polygon.size(); j = i++) {
        if (((polygon[i].y_ > p.y_) != (polygon[j].y_ > p.y_)) &&
            (p.x_ < (polygon[j].x_ - polygon[i].x_) * (p.y_ - polygon[i].y_) / (polygon[j].y_ - polygon[i].y_) +
                    polygon[i].x_))
            odd = !odd;
    }

    return odd;
}

void NHRAgent::addVertexToGraph(std::map<Point, vector<Point> > &graph, Point v1, Point v2) {
    std::map<Point, vector<Point> >::iterator it;
    it = graph.find(v1);
    if (it != graph.end()) {
        it->second.push_back(v2);
    } else {
        vector<Point> val;
        val.push_back(v2);
        graph.insert(std::pair<Point, vector<Point> >(v1, val));
    }
    it = graph.find(v2);
    if (it != graph.end()) {
        it->second.push_back(v1);
    } else {
        vector<Point> val;
        val.push_back(v1);
        graph.insert(std::pair<Point, vector<Point> >(v2, val));
    }
}

void NHRAgent::findShortestPath(std::map<Point, vector<Point> > &graph, Point gate, set<Point> endpoints) {
    if (endpoints.size() == 0)
        return;
    map<Point, Point> trace;
    map<Point, int> level;
    std::queue<Point> queue;
    int n_level = 0;
    std::map<Point, vector<Point> >::iterator root;
    root = graph.find(gate);
    queue.push(root->first);
    trace.insert(std::pair<Point, Point>(root->first, root->first));
    level.insert(std::pair<Point, int>(root->first, n_level));

    while (!queue.empty()) {
        n_level++;
        Point p = queue.front();
        queue.pop();
        std::vector<Point> tmp = graph.find(p)->second;
        for (std::vector<Point>::iterator it = tmp.begin(); it != tmp.end(); ++it) {
            if (trace.find((*it)) == trace.end()) {
                trace.insert(std::pair<Point, Point>((*it), p));
                level.insert(std::pair<Point, int>((*it), n_level));
                queue.push((*it));
            }
        }
    }

    Point closet_endpoint;
    int closet_level = INT_MAX;
    for (std::set<Point>::iterator it = endpoints.begin(); it != endpoints.end(); ++it) {
        int level_tmp = level.find(*it)->second;
        if (level_tmp < closet_level) {
            closet_level = level_tmp;
            closet_endpoint.x_ = (*it).x_;
            closet_endpoint.y_ = (*it).y_;
        }
    }

    endpoint_ = trace.find(closet_endpoint)->second;
}

/*------------- Sending Data -------------*/
void NHRAgent::sendData(Packet *p) {

}

void NHRAgent::recvData(Packet *p) {

}

void NHRAgent::dump() {
    FILE *fp = fopen("Dump.tr", "a+");
    for (std::vector<BoundaryNode>::iterator it = hole_.begin(); it != hole_.end(); ++it)
        fprintf(fp, "%d\t%f\t%f\t%d\n", (*it).id_, (*it).x_, (*it).y_, (*it).is_convex_hull_boundary_);
    for (std::vector<BoundaryNode>::iterator it = octagon_hole_.begin(); it != octagon_hole_.end(); ++it) {
        fprintf(fp, "%f\t%f\n", (*it).x_, (*it).y_);
    }
    fclose(fp);
}

void NHRAgent::dumpBroadcastRegion() {
    FILE *fp = fopen("BroadcastRegion.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\n", my_id_, x_, y_);
    fclose(fp);
}

void NHRAgent::dumpVoronoi(vector<BoundaryNode> polygon, map<Point, vector<Point> > vertices) {
    if (my_id_ != 303)
        return;
    FILE *fp = fopen("Voronoi.tr", "a+");
    for (std::vector<BoundaryNode>::iterator it = polygon.begin(); it != polygon.end(); ++it)
        fprintf(fp, "%d\t%f\t%f\n", my_id_, (*it).x_, (*it).y_);
    for (map<Point, vector<Point> >::iterator it = vertices.begin(); it != vertices.end(); ++it) {
        for (vector<Point>::iterator it2 = it->second.begin(); it2 != it->second.end(); ++it2) {
            fprintf(fp, "==%d\t%f\t%f\n", my_id_, (*it).first.x_, (*it).first.y_);
            fprintf(fp, "==%d\t%f\t%f\n\n", my_id_, (*it2).x_, (*it2).y_);
        }
    }
    fclose(fp);
}
