#include <packet.h>
#include <algorithm>
#include <stack>
#include <wsn/versatilerouting_v1/graph/o_graph.h>
#include <wsn/common/struct.h>
#include <wsn/versatilerouting_v1/graph/i_graph.h>
#include "vr1.h"
#include "vr1_packet_data.h"


#define ALPHA_ M_PI/6

int hdr_vr1::offset_;

// data packet header
static class VR1HeaderClass : public PacketHeaderClass {
public:
    VR1HeaderClass() : PacketHeaderClass("PacketHeader/VR1", sizeof(hdr_all_vr1)) {
        bind_offset(&hdr_vr1::offset_);
    }
} class_vr1hdr;


// each sensor node
static class VR1AgentClass : public TclClass {
public:
    VR1AgentClass() : TclClass("Agent/VR1") {}

    TclObject *create(int, const char *const *) {
        return (new VR1Agent());
    }
} class_vr1;

void VR1Timer::expire(Event *e) {
    (a_->*firing_)();
}

/*
 * Agent - initialize all parameters of a sensor
 */
VR1Agent::VR1Agent() : GPSRAgent(),
                       findStuck_timer_(this, &VR1Agent::findStuckAngle),
                       boundhole_timer_(this, &VR1Agent::sendBoundHole),
                       broadcast_timer_(this) {

    stuck_angle_ = NULL;
    range_ = 40;
    limit_min_hop_ = 10;
    limit_max_hop_ = 80;
    n_ = 8;
    epsilon_o_ = 0.5;
    epsilon_i_ = 0.5;
    core_polygon_set = NULL;
    already_dump_energy_ = false;

    bind("range_", &range_);
    bind("n_", &n_);
    bind("k_n_", &k_n_);
    bind("limit_boundhole_hop_", &limit_max_hop_);
    bind("min_boundhole_hop_", &limit_min_hop_);
    bind("epsilon_", &epsilon_o_);
    bind("epsilon_", &epsilon_i_);
    bind("net_width_", &network_width_);
    bind("net_height_", &network_height_);

    theta_n = 2 * M_PI / (n_ * (k_n_ + ALPHA_));
}

int VR1Agent::command(int argc, const char *const *argv) {
    if (argc == 2) {
        if (strcasecmp(argv[1], "start") == 0) {
            startUp();
        }
        if (strcasecmp(argv[1], "boundhole") == 0) {
            boundhole_timer_.resched(0.02 * my_id_);
            return TCL_OK;
        }
        if (strcasecmp(argv[1], "dumpBroadcast") == 0) {
            dumpBroadcastRegion();
            dumpNodeInfo();
            return TCL_OK;
        }
    }
    return GPSRAgent::command(argc, argv);
}

void VR1Agent::recv(Packet *p, Handler *h) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);

    switch (cmh->ptype()) {
        case PT_HELLO:
            GPSRAgent::recv(p, h);
            break;

        case PT_VR1:
            recvVR1(p, h);
            break;

        case PT_CBR:
            printf("%d recv data\n", this->my_id_);
            if (iph->saddr() == my_id_)     // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)   // a new packet
                {
                    sendData(p);
                } else      // (cmh->num_forwards() > 0) - routing loop -> drop
                {
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                drop(p, DROP_RTR_TTL);
                return;
            }
            recvData(p);
            break;

        default:
            drop(p, "UnknownType");
            break;
    }
}

/*
 * Routing phase
 */
void VR1Agent::sendData(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_vr1_data *hdc = HDR_VR1_DATA(p);

    cmh->size() += IP_HDR_LEN + hdc->size();
    cmh->direction_ = hdr_cmn::DOWN;

    hdc->apIndex = 0;
    hdc->dest = *dest;
    hdc->hopCount = 0;
    hdc->source_id_ = this->my_id_;

    // todo: sua lai cho chuan hon, neu co bug thi co the la vi o day
    for (int i = 0; i < 30; i++)
        hdc->path[i] = *dest;

    std::vector<Point> path;

    if (!holes.empty()) {
        path = findPath(*this, *dest);
    }
    if (!path.empty()) {
        for (int i = 0; i < path.size(); i++)
            hdc->path[i] = path.at(i);
    }

    iph->saddr() = my_id_;
    iph->daddr() = -1;
    iph->ttl_ = 4 * IP_DEF_TTL;
}

void VR1Agent::recvData(Packet *p) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_vr1_data *edh = HDR_VR1_DATA(p);


    /*
     * dump exhausted energy
     */
    if (node_->energy_model()->energy() < 0.05 && !already_dump_energy_) {
        already_dump_energy_ = true;
        FILE *fp = fopen("DiedEnergy.tr", "a+");
        fprintf(fp, "%f\t%d\t%f\t%f\t%f\n", NOW, this->my_id_, this->x_, this->y_, node_->energy_model()->energy());
        fclose(fp);
    }

    if (cmh->direction() == hdr_cmn::UP && edh->dest == *this) {  // up to destination
        dumpHopCount(edh);
        port_dmux_->recv(p, 0);
        return;
    }

    node *nexthop = NULL;

//    int pth_len = getPathArraySize(edh->path);
    if (edh->path[0] != edh->dest) {       // da xac dinh duoc duong di
        nexthop = getNeighborByGreedy(edh->path[edh->apIndex]);

        // neu nexthop == NULL -> da di den anchor point -> tim anchor point tiep theo
        while (nexthop == NULL && edh->apIndex < 29) {
            edh->apIndex += 1;
            nexthop = getNeighborByGreedy(edh->path[edh->apIndex]);
        }
    } else {                        // chua xac dinh duoc duong di
        if (holes.empty()) {
            nexthop = getNeighborByGreedy(edh->dest);
        } else {
            std::vector<Point> path = findPath(*this, edh->dest);
            if (path.empty())
                return;
            for (int i = 0; i < path.size(); i++)
                edh->path[i] = path.at(i);
            edh->apIndex = 0;
            nexthop = getNeighborByGreedy(edh->path[edh->apIndex]);
        }
    }

    if (nexthop == NULL) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    } else {
        cmh->direction() = hdr_cmn::DOWN;
        cmh->addr_type() = NS_AF_INET;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = nexthop->id_;
        edh->hopCount++;
        send(p, 0);
        data_pkt_counter_++;
    }

    // debug
//    FILE *fp = fopen("Path.tr", "a+");
//    fprintf(fp, "%d\t%d\n", HDR_IP(p)->fid_, this->my_id_);
//    fclose(fp);
}

void VR1Agent::recvVR1(Packet *p, Handler *h) {
    hdr_vr1_ha *bhh = HDR_VR1_HA(p);
    if (bhh->type_ == VR1_BOUNDHOLE) {
        recvBoundHole(p);
    } else if (bhh->type_ == VR1_HBA) {
        recvHBA(p);
    } else if (bhh->type_ == VR1_BROADCAST) {
        recvHCI(p);
    }
}

void VR1Agent::startUp() {
    findStuck_timer_.resched(65);

    FILE *fp;
    fp = fopen("Neighbors.tr", "w");
    fclose(fp);
    fp = fopen("NodeList.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("CorePolygon.tr", "w");
    fclose(fp);
    fp = fopen("Debug.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastRegion.tr", "w");
    fclose(fp);
    fp = fopen("DynamicScaleHole.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastEnergy.tr", "w");
    fclose(fp);
    fp = fopen("BigForbiddenArea.tr", "w");
    fclose(fp);
    fp = fopen("HopCount.tr", "w");
    fclose(fp);
    fp = fopen("Path.tr", "w");
    fclose(fp);
}

/*
 * Boundhole phase
 */
void VR1Agent::findStuckAngle() {
    if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL) {
        stuck_angle_ = NULL;
        return;
    }

//    printf("find stuck angle %d\n", this->my_id_);

    node *nb1 = neighbor_list_; //u
    node *nb2 = neighbor_list_->next_; //v

    while (nb2) {
        Circle circle = G::circumcenter(this, nb1, nb2);
        Angle a = G::angle(this, nb1, this, &circle); // upO
        Angle b = G::angle(this, nb1, this, nb2); // upv
        Angle c = G::angle(this, &circle, this, nb2); //Opv

        // if O is outside range of node, nb1 and nb2 create a stuck angle with node
        if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
            stuckangle *new_angle = new stuckangle();
            new_angle->a_ = nb1;
            new_angle->b_ = nb2;
            new_angle->next_ = stuck_angle_;
            stuck_angle_ = new_angle;
        }

        nb1 = nb1->next_;
        nb2 = nb1->next_;
    }

    nb2 = neighbor_list_;
    Circle circle = G::circumcenter(this, nb1, nb2);
    Angle a = G::angle(this, nb1, this, &circle);
    Angle b = G::angle(this, nb1, this, nb2);
    Angle c = G::angle(this, &circle, this, nb2);

    // if O is outside range of node, nb1 and nb2 create a stuck angle with node
    if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
        stuckangle *new_angle = new stuckangle();
        new_angle->a_ = nb1;
        new_angle->b_ = nb2;
        new_angle->next_ = stuck_angle_;
        stuck_angle_ = new_angle;
    }
}

void VR1Agent::sendBoundHole() {
    Packet *p;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_vr1_ha *bhh;

    for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
        p = allocpkt();

        VR1PacketData *bhpkt_data = new VR1PacketData();
        bhpkt_data->add(sa->b_->id_, sa->b_->x_, sa->b_->y_);
        bhpkt_data->add(my_id_, this->x_, this->y_);
        p->setdata(bhpkt_data);

        cmh = HDR_CMN(p);
        iph = HDR_IP(p);
        bhh = HDR_VR1_HA(p);

        cmh->ptype() = PT_VR1;
        cmh->direction() = hdr_cmn::DOWN;
        cmh->size() += IP_HDR_LEN + bhh->size() + bhpkt_data->data_len_;
        cmh->next_hop_ = sa->a_->id_;
        cmh->last_hop_ = my_id_;
        cmh->addr_type_ = NS_AF_INET;

        iph->saddr() = my_id_;
        iph->daddr() = sa->a_->id_;
        iph->sport() = RT_PORT;
        iph->dport() = RT_PORT;
        iph->ttl_ = limit_max_hop_;            // more than ttl_ hop => boundary => remove

        bhh->prev_ = *this;
        bhh->type_ = VR1_BOUNDHOLE;

        send(p, 0);
        boundhole_pkt_counter_++;
//        printf("send boundhole: %d\n", this->my_id_);
    }
}

void VR1Agent::recvBoundHole(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_vr1_ha *bhh = HDR_VR1_HA(p);

    VR1PacketData *data = (VR1PacketData *) p->userdata();

    // if the boundhole packet has came back to the initial node
    if (iph->saddr() == my_id_) {
//        printf("%d came back\n", this->my_id_);
        if (iph->ttl_ > (limit_max_hop_ - limit_min_hop_)) {
            drop(p, "SmallHole");
        } else {
            createHole(p);
            data->dump();
            // start sending HBA to hole boundary
            sendHBA(p);
        }
        return;
    }

    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    node n = data->get_data(1);
    if (n.id_ != iph->saddr()) {
        data->rmv_data(1);
    } else {
        // get the entry at index n-1
        n = data->get_data(data->size() - 1);
    }

    node *nb = getNeighborByBoundHole(&bhh->prev_, &n);

    // no neighbor to forward, drop message
    // it means the network is not interconnected
    if (nb == NULL) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    }

    // drop message for loop way
    node temp, next;

    for (int i = 1; i < data->size(); i++) {
        temp = data->get_data(i);
        next = data->get_data(i + 1);

        if (G::is_intersect2(this, nb, temp, next)) {
            if (G::distance(temp, nb) < range_) {
                while (data->size() >= (i + 1)) {
                    data->rmv_data(i + 1);
                }

                data->add(nb->id_, nb->x_, nb->y_);
                nb = getNeighborByBoundHole(nb, &temp);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            } else {
                nb = getNeighbor(next.id_);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            }
        }
    }


    // if neighbor already send boundhole message to that node
    if (iph->saddr() > my_id_) {
        for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
            if (sa->a_->id_ == nb->id_) {
                drop(p, "BOUNDHOLE_REPEAT");
                return;
            }
        }
    }

    data->add(my_id_, this->x_, this->y_);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = nb->id_;
    cmh->last_hop_ = my_id_;
    iph->daddr() = nb->id_;
    bhh->prev_ = *this;

    send(p, 0);
    boundhole_pkt_counter_++;

//    printf("%d recv boundhole\n", this->my_id_);
}

void VR1Agent::createHole(Packet *p) {
    VR1PacketData *data = (VR1PacketData *) p->userdata();

    BoundaryNode tmp = BoundaryNode();
    for (int i = 1; i <= data->size(); i++) {
        node n = data->get_data(i);
        tmp.x_ = n.x_;
        tmp.y_ = n.y_;
        tmp.id_ = n.id_;
        tmp.is_convex_hull_boundary_ = false;
        hole.node_vector_.push_back(tmp);
    }
    holes.push_back(hole);
}

node *VR1Agent::getNeighborByBoundHole(Point *p, Point *prev) {
    Angle max_angle = -1;
    node *nb = NULL;

    for (node *temp = neighbor_list_; temp; temp = temp->next_) {
        Angle a = G::angle(this, p, this, temp);
        if (a > max_angle && (!G::is_intersect(this, temp, p, prev) ||
                              (temp->x_ == p->x_ && temp->y_ == p->y_) ||
                              (this->x_ == prev->x_ && this->y_ == prev->y_))) {
            max_angle = a;
            nb = temp;
        }
    }

    return nb;
}

/*
 * HBA phase
 */
void VR1Agent::sendHBA(Packet *p) {
    VR1PacketData *data = (VR1PacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_vr1_ha *bhh = HDR_VR1_HA(p);

    // update data payload - alloc memory for set of B(i) nodes
    data->add(my_id_, x_, y_); // add back H0 to end of array
    data->addHBA(n_, k_n_);
    // we need to call this function twice since there is a special case:
    // a node is belong to 2 edges of core polygon, i.e. this node is a vertex of core polygon
    isNodeStayOnBoundaryOfCorePolygon(p);
    isNodeStayOnBoundaryOfCorePolygon(p);

    node n = data->get_data(2);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = n.id_;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->ptype() = PT_VR1;
    cmh->num_forwards() = 0;
    cmh->size() += IP_HDR_LEN + bhh->size() + data->data_len_;

    iph->saddr() = my_id_;
    iph->daddr() = n.id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = IP_DEF_TTL;

    bhh->type_ = VR1_HBA;
    bhh->index_ = 2;

    send(p, 0);
    HBA_counter_++;

//    printf("%d send HBA\n", this->my_id_);
}

void VR1Agent::recvHBA(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_vr1_ha *bhh = HDR_VR1_HA(p);

    VR1PacketData *data = (VR1PacketData *) p->userdata();

//    createHole(p);

//    printf("%d recv HBA\n", this->my_id_);

    int i = bhh->index_;
    if (i < data->size() - (n_ + 1) * k_n_) {
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        nsaddr_t next_id = data->get_data(i + 1).id_;

        hdr_cmn *cmh = HDR_CMN(p);
        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = next_id;

        iph->daddr() = next_id;
        bhh->index_++;

        send(p, 0);
        HBA_counter_++;
    } else { // back to H0
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        constructCorePolygonSet(p);
        drop(p, "BOUNDHOLE_HBA");

        // broadcast HCI
        broadcastHCI();
    }
}

void VR1Agent::constructCorePolygonSet(Packet *p) {
    VR1PacketData *data = (VR1PacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    corePolygon *tmp_choose = new corePolygon();
    double area = DBL_MAX, tmp_area = 0;

    for (int i = 1; i <= k_n_; i++) {
        corePolygon *new_core = new corePolygon();
        new_core->id_ = i;

        for (int j = 1; j <= n_; j++) {
            int j_1 = j == n_ ? 1 : j + 1;

            off = data_size + (n_ + 1) * (i - 1) + j;
            node b_j = data->get_Bi_data(off);
            off = data_size + (n_ + 1) * (i - 1) + j_1;
            node b_j_1 = data->get_Bi_data(off);

            Angle b_j_angle = (i - 1) * theta_n + (j - 1) * 2 * M_PI / n_;
            Angle b_j_1_angle = (i - 1) * theta_n + (j_1 - 1) * 2 * M_PI / n_;

            Line l_i_j = G::line(b_j, b_j_angle);
            Line l_i_j_1 = G::line(b_j_1, b_j_1_angle);

            Point intersection;
            if (G::intersection(l_i_j, l_i_j_1, intersection)) {
                addCorePolygonNode(intersection, new_core);
            }
        }

        if (areaCorePolygon(new_core) < area) {
            tmp_choose = new_core;
            area = areaCorePolygon(new_core);
        }
    }
    tmp_choose->next_ = core_polygon_set;
    core_polygon_set = tmp_choose;
    dumpCorePolygon();
}

double VR1Agent::areaCorePolygon(corePolygon *tmp) {
    node *node_tmp = tmp->node_;
    Point array_tmp[n_];
    double sum = 0, sum_a = 0, sum_b = 0;
    for (int i = 0; i < n_; i++) {
        array_tmp[i] = *node_tmp;
        node_tmp = node_tmp->next_;
    }
    for (int i = 0; i < n_ - 1; i++) {
        sum_a = sum_a + array_tmp[i].x_ * array_tmp[i + 1].y_;
        sum_b = sum_b + array_tmp[i + 1].x_ * array_tmp[i].y_;
    }
    sum_a = sum_a + array_tmp[n_ - 1].x_ * array_tmp[0].y_;
    sum_b = sum_b + array_tmp[1].x_ * array_tmp[n_ - 1].y_;
    sum = (sum_a - sum_b) / 2;
    if (sum < 0) {
        sum = 0 - sum;
    }
    return sum;
}

void VR1Agent::addCorePolygonNode(Point newPoint, corePolygon *corePolygon) {
    node *newNode = new node();
    newNode->x_ = newPoint.x_;
    newNode->y_ = newPoint.y_;
    newNode->next_ = NULL;
    node *tmp = corePolygon->node_;
    while (tmp && tmp->next_) { tmp = tmp->next_; }
    if (tmp == NULL) corePolygon->node_ = newNode;
    else tmp->next_ = newNode;
}

// check if this node is on boundary of a core polygon
// if true then update the packet data payload for each (i,j) immediately
void VR1Agent::isNodeStayOnBoundaryOfCorePolygon(Packet *p) {
    VR1PacketData *data = (VR1PacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    int i;
    for (i = 1; i <= k_n_; i++) {
        bool first_time = false;
        // get next index of this B(i)

        off = data_size + (n_ + 1) * (i - 1);
        int next_index = data->get_next_index_of_Bi(off);

        if (next_index == 1) {
            next_index = n_ + 1;
        } else if (next_index == 0) {
            next_index = n_ + 1;
            first_time = true;
        }

        while (true) {
            next_index--;
            bool flag = false;
            double angle = (i - 1) * theta_n + (next_index - 1) * 2 * M_PI / n_;
            // draw line goes through this node and make with x-axis angle: mx + n = y
            Line l_n = G::line(this, angle);

            node tmp1, tmp2;
            int index;

            tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
            for (index = 1; index <= data_size; index++) {
                tmp2 = data->get_data(index);
                if (tmp2.id_ == my_id_) continue;
                if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                    flag = true;
                    break;
                }
            }

            if (next_index <= 0) break;
            if (flag && !first_time) break;
            if (flag) continue;

            first_time = false;
            // add N to set B(i, j)
            off = (i - 1) * (n_ + 1) + next_index + data_size;
            data->addBiNode(off, my_id_, x_, y_);
            off = data_size + (i - 1) * (n_ + 1);
            data->update_next_index_of_Bi(off, next_index);
            dump(angle, i, next_index, l_n);

            // check if next_index = 1 is valid
            if (next_index == n_) {
                flag = false;
                angle = (i - 1) * theta_n;
                // draw line goes through this node and make with x-axis angle: mx + n = y
                l_n = G::line(this, angle);

                tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
                for (index = 1; index <= data_size; index++) {
                    tmp2 = data->get_data(index);
                    if (tmp2.id_ == my_id_) continue;
                    if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                        flag = true;
                        break;
                    }
                }

                if (!flag) {
                    // add N to set B(i, j) but dont update next_index
                    off = (i - 1) * (n_ + 1) + 1 + data_size;
                    data->addBiNode(off, my_id_, x_, y_);
                    dump(angle, i, 1, l_n);
                }
            }
        }
    }
}
/*
 * Broadcast phase
 */
// broadcast hole's & core polygons's information
void VR1Agent::broadcastHCI() {
    Packet *p = NULL;
    VR1PacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_vr1_ha *hdc;

    if (holes.empty() || core_polygon_set == NULL)
        return;

    p = allocpkt();
    payload = new VR1PacketData();

    // todo: kiem tra xem co can gui ca core_polygon_set va holes vao packet ko
    // add core polygon nodes of this node to broadcast packet
    corePolygon *my_self_core_ = core_polygon_set;
    for (node *node = my_self_core_->node_; node != NULL; node = node->next_) {
        payload->add(-1, node->x_, node->y_);
    }

    // add hole nodes of this node to broadcast packet
    for (int i = 0; i < hole.node_vector_.size(); i++) {
        payload->add(i, hole.node_vector_[i].x_, hole.node_vector_[i].y_);
    }

    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hdc = HDR_VR1_HA(p);

    cmh->ptype() = PT_VR1;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hdc->size();

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 256;

    hdc->type_ = VR1_BROADCAST;

    dumpCorePolygon();

    send(p, 0);
    HCI_counter_++;
}

void VR1Agent::recvHCI(Packet *p) {

    struct hdr_ip *iph = HDR_IP(p);
//    VR1PacketData *data = (VR1PacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);

    // if the hci packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        drop(p, "VR1LoopHCI");
        return;
    }
    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    // store corepolygons and holes
    corePolygon *diffCores = storeCorePolygons(p);
    if (diffCores == NULL) {
        drop(p, "HciReceived");
        return;
    }

    // continue broadcasting message
    cmh->direction_ = hdr_cmn::DOWN;
    cmh->last_hop_ = my_id_;

    iph->ttl_--;
    if (iph->ttl_ <= 0) drop(p, "Limit");
    else {
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0.0, 0.5));
        HCI_counter_++;
    }
}

// core polygon selection & update payload data
corePolygon *VR1Agent::storeCorePolygons(Packet *p) {
    VR1PacketData *data = (VR1PacketData *) p->userdata();
    int offset = 0;

    // check if we already have this core polygon
    corePolygon *newCore = new corePolygon();
    for (int j = 0; j < n_; j++) {
        offset = j;
        node newPoint = data->get_Bi_data(offset);
        addCorePolygonNode(newPoint, newCore);
    }
//    if (!newCore) {
//        int a = 0;
//        return NULL;
//    }

    bool has_corepolygon_ = false;
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        node *nn = cg->node_;
        bool flag = true;
        for (node *n = newCore->node_; n; n = n->next_) {
            if (n->x_ != nn->x_ || n->y_ != nn->y_) {
                flag = false;
                break;
            }
            nn = nn->next_;
        }
        if (flag) {
            has_corepolygon_ = true;
            delete newCore;
            break;
        }
    }

    // store new cg
    if (!has_corepolygon_) {
        newCore->next_ = core_polygon_set;
        core_polygon_set = newCore;
        if (core_polygon_set != NULL) {
            if (core_polygon_set->next_ != NULL) {
                if (core_polygon_set->next_->next_ != NULL) {
                    dumpCorePolygon();
                }
            }
        }
    }

    // store holes' info
    offset += 1;

    HoleSt new_hole_;
    while (offset < data->size()) {
        node n = data->get_Bi_data(offset);
        BoundaryNode *np = new BoundaryNode();
        np->x_ = n.x_;
        np->y_ = n.y_;
        new_hole_.node_vector_.push_back(*np);
        offset++;
    }

    // check if node already has this hole's info
    bool flag = false;
    for (std::vector<HoleSt>::iterator it = holes.begin(); it != holes.end(); it++) {
        if (isSamePolygon(*it, new_hole_)) {
            flag = true;
            break;
        }
    }
    if (!flag)
        holes.push_back(new_hole_);

    return has_corepolygon_ ? NULL : newCore;
}

bool VR1Agent::isSamePolygon(HoleSt p1, HoleSt p2) {
    bool flag = true;
    if (p1.node_vector_.size() != p2.node_vector_.size())
        return false;
    else {
        for (int i = 0; i < p1.node_vector_.size(); i++)
            if (p1.node_vector_[i].x_ != p2.node_vector_[i].x_ || p1.node_vector_[i].x_ != p2.node_vector_[i].x_) {
                flag = false;
                break;
            }
    }
    return flag;
}

std::vector<Point> VR1Agent::findPath(Point s, Point d) {
// 0. chuyen core_polygon_set ve dang vector
    std::vector<CorePolygon> core_pols;
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        CorePolygon *cp = new CorePolygon();
        for (node *n = cg->node_; n != NULL; n = n->next_)
            cp->vertices.push_back(Point(n->x_, n->y_));
        core_pols.push_back(*cp);
    }

// 1. check xem dest hay source co nam trong core polygon nao khong
    CorePolygon source_core_;
    CorePolygon dest_core_;

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(s, core_pols[i].vertices)) {
            source_core_ = core_pols[i];
            break;
        }
    }

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(d, core_pols[i].vertices)) {
            dest_core_ = core_pols[i];
            break;
        }
    }

    std::vector<Point> final_path_;

// 3.
// TH1: ca source va dest deu nam ngoai
    if (source_core_.vertices.empty() && dest_core_.vertices.empty()) {
        // 2. xac dinh obs - cac core polygon cat st & find tangents between them
        std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s, d);

        OGraph graph = OGraph(obs);     // dung do thi
        std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_,
                                                                              n_);   // base_paths_ bao gom ca shortest path

        std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

        // chon 1 duong bat ky dua vao priority index
        int m;
        double prob = fwdProb_.uniform(0.0, 1.0);
        for (int i = 0; i < base_paths_.size(); i++) {
            if (prob <= priority_indexes_[i]) {
                m = i;
                break;
            }
        }
        std::vector<BasePathPoint> chosed_path_ = base_paths_[m];

        // vi tu duong di
        double stp_length = graph.shortestPathLength();
        double bp_length = Geo::pathLength(chosed_path_);

        double theta = bp_length / stp_length;
        double gama = (1 + epsilon_o_) * sin((n_ - 2) * M_PI / (2 * n_));

        final_path_ = scaleOutsidePath(chosed_path_, theta, gama, obs);
    }


// TH2: source nam trong core polygon, dest nam ngoai
    else if (!source_core_.vertices.empty() && dest_core_.vertices.empty()) {

        // tim ho cua s
        std::vector<BoundaryNode> s_hole_;
        std::vector<BoundaryNode> s_convex_;
        std::vector<std::vector<BoundaryNode>> convex_hull_set_ = determineConvexHullSet();
        for (int i = 0; i < convex_hull_set_.size(); i++) {
            if (Geo::isPointReallyInsidePolygon(s, convex_hull_set_[i])) {
                s_hole_ = holes[i].node_vector_;
                s_convex_ = convex_hull_set_[i];
            }
        }

        // tim duong di ngan nhat tu s den gate-point
        std::vector<Point> s_cave_ = determineCaveContainingNode(s, s_convex_, s_hole_);
        if (s_cave_.empty())
            return final_path_;
        IGraph *in_graph_ = new IGraph(s_cave_);

        int ra = (rand() > RAND_MAX / 2) ? 0 : s_cave_.size() - 1;

        std::vector<Point> sp = in_graph_->shortestPath(s, s_cave_[ra]);


        // vi tu duong di ngan nhat
        double scale_ratio_i_;
        Point I = findScaleCenter(sp, epsilon_i_, scale_ratio_i_);
        for (unsigned int i = 1; i < sp.size(); i++) {
            Point anchor = Point(scale_ratio_i_ * sp[i].x_ + (1 - scale_ratio_i_) * I.x_,
                                 scale_ratio_i_ * sp[i].y_ + (1 - scale_ratio_i_) * I.y_);
            final_path_.push_back(anchor);
        }

        // tim duong di ngan nhat ben ngoai core polygon
        // tim vertex co khoang cach ngan nhat den gate-point cua s
        double min_dis_ = DBL_MAX;
        double min_index_ = 0;
        for (int i = 0; i < source_core_.vertices.size(); i++) {
            double tmp_dis_ = G::distance(source_core_.vertices[i], s_cave_[ra]);
            min_dis_ = min_dis_ < tmp_dis_ ? min_dis_ : tmp_dis_;
            min_index_ = i;
        }

        final_path_.push_back(source_core_.vertices[min_index_]);

        std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, source_core_.vertices[min_index_], d);

        OGraph graph = OGraph(obs);     // dung do thi
        std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_,
                                                                              n_);   // base_paths_ bao gom ca shortest path

        std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

        // chon 1 duong bat ky dua vao priority index
        int m;
        double prob = fwdProb_.uniform(0.0, 1.0);
        for (int i = 0; i < base_paths_.size(); i++) {
            if (prob <= priority_indexes_[i]) {
                m = i;
                break;
            }
        }
        std::vector<BasePathPoint> chosed_path_ = base_paths_[m];

        // vi tu duong di
        double stp_length = graph.shortestPathLength();
        double bp_length = Geo::pathLength(chosed_path_);

        double theta = bp_length / stp_length;
        double gama = (1 + epsilon_o_) * sin((n_ - 2) * M_PI / (2 * n_));

        std::vector<Point> outside_path_ = scaleOutsidePath(chosed_path_, theta, gama, obs);

        final_path_.insert(final_path_.end(), outside_path_.begin(), outside_path_.end());

    }

// TH3: source nam ngoai, dest nam trong
    else if (source_core_.vertices.empty() && !dest_core_.vertices.empty()) {

        // tim duong di ben ngoai core polygon

        // tim ho chua dest
        std::vector<BoundaryNode> d_hole_;
        std::vector<BoundaryNode> d_convex_;
        std::vector<std::vector<BoundaryNode>> convex_hull_set_ = determineConvexHullSet();
        for (int i = 0; i < convex_hull_set_.size(); i++) {
            if (Geo::isPointReallyInsidePolygon(d, convex_hull_set_[i])) {
                d_hole_ = holes[i].node_vector_;
                d_convex_ = convex_hull_set_[i];
            }
        }

        // tim duong di ngan nhat tu gate-point den d
        std::vector<Point> d_cave_ = determineCaveContainingNode(d, d_convex_, d_hole_);
        if (d_cave_.empty())
            return final_path_;
        IGraph *in_graph_ = new IGraph(d_cave_);

        int ra = (rand() > RAND_MAX / 2) ? 0 : d_cave_.size() - 1;

        std::vector<Point> sp = in_graph_->shortestPath(d_cave_[ra], d);


        // vi tu duong di ngan nhat
        std::vector<Point> inside_path_;
        double scale_ratio_i_;
        Point I = findScaleCenter(sp, epsilon_i_, scale_ratio_i_);
        for (unsigned int i = 1; i < sp.size(); i++) {
            Point anchor = Point(scale_ratio_i_ * sp[i].x_ + (1 - scale_ratio_i_) * I.x_,
                                 scale_ratio_i_ * sp[i].y_ + (1 - scale_ratio_i_) * I.y_);
            inside_path_.push_back(anchor);
        }

        // tim duong di ngan nhat ben ngoai core polygon
        // tim vertex co khoang cach ngan nhat den gate-point cua d
        double min_dis_ = DBL_MAX;
        double min_index_ = 0;
        for (int i = 0; i < dest_core_.vertices.size(); i++) {
            double tmp_dis_ = G::distance(dest_core_.vertices[i], d_cave_[ra]);
            min_dis_ = min_dis_ < tmp_dis_ ? min_dis_ : tmp_dis_;
            min_index_ = i;
        }


        std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s, dest_core_.vertices[min_index_]);

        OGraph graph = OGraph(obs);     // dung do thi
        std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_,
                                                                              n_);   // base_paths_ bao gom ca shortest path

        std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

        // chon 1 duong bat ky dua vao priority index
        int m;
        double prob = fwdProb_.uniform(0.0, 1.0);
        for (int i = 0; i < base_paths_.size(); i++) {
            if (prob <= priority_indexes_[i]) {
                m = i;
                break;

            }
        }
        std::vector<BasePathPoint> chosed_path_ = base_paths_[m];

        // vi tu duong di
        double stp_length = graph.shortestPathLength();
        double bp_length = Geo::pathLength(chosed_path_);

        double theta = bp_length / stp_length;
        double gama = (1 + epsilon_o_) * sin((n_ - 2) * M_PI / (2 * n_));

        std::vector<Point> outside_path_ = scaleOutsidePath(chosed_path_, theta, gama, obs);

        final_path_.insert(final_path_.end(), outside_path_.begin(), outside_path_.end());
        final_path_.push_back(dest_core_.vertices[min_index_]);
        final_path_.insert(final_path_.end(), inside_path_.begin(), inside_path_.end());
        final_path_.push_back(d);
    }

// TH4: ca source va dest deu nam trong
    else if (!source_core_.vertices.empty() && !dest_core_.vertices.empty()) {

        // tim duong di ngan nhat tu s toi gate-point -> vi tu
        // tim ho cua s
        std::vector<BoundaryNode> s_hole_;
        std::vector<BoundaryNode> s_convex_;
        std::vector<std::vector<BoundaryNode>> convex_hull_set_ = determineConvexHullSet();
        for (int i = 0; i < convex_hull_set_.size(); i++) {
            if (Geo::isPointReallyInsidePolygon(s, convex_hull_set_[i])) {
                s_hole_.insert(s_hole_.end(), holes[i].node_vector_.begin(),
                               holes[i].node_vector_.end()); // todo: bug's here!!!
                s_convex_.insert(s_convex_.end(), convex_hull_set_[i].begin(), convex_hull_set_[i].end());
            }
        }

        // tim ho chua dest
        std::vector<BoundaryNode> d_hole_;
        std::vector<BoundaryNode> d_convex_;
        for (int i = 0; i < convex_hull_set_.size(); i++) {
            if (Geo::isPointReallyInsidePolygon(d, convex_hull_set_[i])) {
                d_hole_.insert(d_hole_.end(), holes[i].node_vector_.begin(), holes[i].node_vector_.end());
                d_convex_.insert(d_convex_.end(), convex_hull_set_[i].begin(), convex_hull_set_[i].end());
            }
        }

        // tim duong di ngan nhat tu s den gate-point
        std::vector<Point> s_cave_ = determineCaveContainingNode(s, s_convex_, s_hole_);
        if (s_cave_.empty())
            return final_path_;
        IGraph *s_in_graph_ = new IGraph(s_cave_);

        int ra = (rand() > RAND_MAX / 2) ? 0 : s_cave_.size() - 1;

        std::vector<Point> sp = s_in_graph_->shortestPath(s, s_cave_[ra]);

        // vi tu duong di ngan nhat
        double scale_ratio_i_;
        if (sp.size() > 2) {
            Point I = findScaleCenter(sp, epsilon_i_, scale_ratio_i_);
            for (unsigned int i = 1; i < sp.size(); i++) {
                Point anchor = Point(scale_ratio_i_ * sp[i].x_ + (1 - scale_ratio_i_) * I.x_,
                                     scale_ratio_i_ * sp[i].y_ + (1 - scale_ratio_i_) * I.y_);
                final_path_.push_back(anchor);
            }
        } else {
            final_path_.push_back(s_cave_[ra]);
        }

        // tim duong di ngan nhat ben ngoai core polygon
        // tim vertex co khoang cach ngan nhat den gate-point cua s
//        double min_dis_ = DBL_MAX;
//        double min_index_ = 0;
//        for (int i = 0; i < source_core_.vertices.size(); i++) {
//            double tmp_dis_ = G::distance(source_core_.vertices[i], s_cave_[ra]);
//            min_dis_ = min_dis_ < tmp_dis_ ? min_dis_ : tmp_dis_;
//            min_index_ = i;
//        }
//        Point s_gate_point_ = final_path_[final_path_.size() - 1];
//        Point s_gate_point_ = source_core_.vertices[min_index_];
        Point s_gate_point_ = final_path_[final_path_.size() - 1];
//        final_path_.push_back(s_gate_point_);          // todo: ko can thiet phai push vao day

        // tim duong di ngan nhat tu gate-point den d -> vi tu
        // tim duong di ngan nhat tu gate-point den d
        std::vector<Point> d_cave_ = determineCaveContainingNode(d, d_convex_, d_hole_);
        if (d_cave_.empty())
            return final_path_;
        IGraph *d_in_graph_ = new IGraph(d_cave_);

        ra = (rand() > RAND_MAX / 2) ? 0 : d_cave_.size() - 1;

        std::vector<Point> d_sp = d_in_graph_->shortestPath(d_cave_[ra], d);


        // vi tu duong di ngan nhat
        std::vector<Point> inside_path_;

        if (d_sp.size() > 2) {
            Point I = findScaleCenter(d_sp, epsilon_i_, scale_ratio_i_);
            for (unsigned int i = 0; i < d_sp.size() - 1; i++) {
                Point anchor = Point(scale_ratio_i_ * d_sp[i].x_ + (1 - scale_ratio_i_) * I.x_,
                                     scale_ratio_i_ * d_sp[i].y_ + (1 - scale_ratio_i_) * I.y_);
                inside_path_.push_back(anchor);
            }
        } else {
            inside_path_.push_back(d);
        }

        // tim duong ngan nhat giua cac core polygon -> vi tu
//        for (int i = 0; i < dest_core_.vertices.size(); i++) {
//            double tmp_dis_ = G::distance(dest_core_.vertices[i], d_cave_[ra]);
//            min_dis_ = min_dis_ < tmp_dis_ ? min_dis_ : tmp_dis_;
//            min_index_ = i;
//        }
////        Point d_gate_point_ = inside_path_[0];
//        Point d_gate_point_ = dest_core_.vertices[min_index_];
        Point d_gate_point_ = inside_path_[0];

        std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s_gate_point_, d_gate_point_);

        OGraph graph = OGraph(obs);     // dung do thi
        // base_paths_ bao gom ca shortest path
        std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_, n_);

        std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

        // chon 1 duong bat ky dua vao priority index
        srand(time(0));
        int m = rand() % base_paths_.size();
        double prob = fwdProb_.uniform(0.0, 1.0);
        for (int i = 0; i < base_paths_.size(); i++) {
            if (prob <= priority_indexes_[i]) {
                m = i;
                break;

            }
        }
        std::vector<BasePathPoint> chosed_path_ = base_paths_[m];

        // vi tu duong di
        double stp_length = graph.shortestPathLength();
        double bp_length = Geo::pathLength(chosed_path_);

        double theta = bp_length / stp_length;
        double gama = (1 + epsilon_o_) * sin((n_ - 2) * M_PI / (2 * n_));

        std::vector<Point> outside_path_ = scaleOutsidePath(chosed_path_, theta, gama, obs);

        final_path_.insert(final_path_.end(), outside_path_.begin(), outside_path_.end());
        final_path_.insert(final_path_.end(), inside_path_.begin(), inside_path_.end());
        final_path_.push_back(d);

    }

    return final_path_;
}

std::vector<Point>
VR1Agent::determineCaveContainingNode(Point s, std::vector<BoundaryNode> convex, std::vector<BoundaryNode> hole) {

    // todo: neu minh dung con tro cho xac dinh convex, thi ko can lam buoc nay
    for (int i = 0; i < convex.size(); i++) {
        for (int k = 0; k < hole.size(); k++) {
            if (hole[k].x_ == convex[i].x_ && hole[k].y_ == convex[i].y_)
                hole[k].is_convex_hull_boundary_ = true;
        }
    }

    // rotate hole list, i.e. the first element is convex hull boundary
    int j = 0;
    while (!hole[j].is_convex_hull_boundary_)
        j++;
    rotate(hole.begin(), hole.begin() + j, hole.end());

    // determine cave containing s
    std::vector<Point> cave;
    for (unsigned int i = 0; i < hole.size() - 1; i++) {
        if (hole.at(i).is_convex_hull_boundary_ && s.x_ == hole.at(i).x_ && s.y_ == hole.at(i).y_) {
            break; // s is gate of cave & lies on convex hull's boundary
        }
        if (hole.at(i).is_convex_hull_boundary_ && !hole.at(i + 1).is_convex_hull_boundary_) {
            cave.push_back(hole.at(i++));
            while (!hole.at(i).is_convex_hull_boundary_) {
                cave.push_back(hole.at(i++));
                if (i == hole.size() - 1)
                    break;
            }
            cave.push_back(hole.at(i--));
            if (i == hole.size() - 2)
                cave.push_back(hole.at(0));
            if (cave.size() >= MIN_CAVE_VERTICES) {
                if (G::isPointInsidePolygon(s, cave))
                    break;
            }
            cave.clear();
        }
    }
    return cave;

}

Point VR1Agent::findScaleCenter(std::vector<Point> v, double lambda, double &k) {
    Point I = Point(0, 0);
    double fr = 0;
    for (auto it : v) {
//        srand(time(NULL));
        int ra = randSend_.uniform(1, 10 ^ 6);
        I.x_ += it.x_ * ra;
        I.y_ += it.y_ * ra;
        fr += ra;
    }
    I.x_ = I.x_ / fr;
    I.y_ = I.y_ / fr;

    // calculate scale ratio
    double dis = G::distance(I, v[0]);
    double l = Geo::pathLength(v);
    dis += l;
    dis += G::distance(I, v[v.size() - 1]);
    k = 1 + lambda * l / dis;

    return I;
}

std::vector<std::vector<BoundaryNode>> VR1Agent::determineConvexHullSet() {
    std::vector<std::vector<BoundaryNode>> result;

    for (int i = 0; i < holes.size(); i++) {
        std::stack<BoundaryNode *> hull;
        std::vector<BoundaryNode> convex;
        std::vector<BoundaryNode *> clone_hole;

        std::vector<BoundaryNode> h = holes[i].node_vector_;
        for (std::vector<BoundaryNode>::iterator it = h.begin(); it != h.end(); it++) {
            clone_hole.push_back(&(*it));
        }
        std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
        BoundaryNode *pivot = clone_hole.front();
        std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
        hull.push(clone_hole[0]);
        hull.push(clone_hole[1]);
        hull.push(clone_hole[2]);

        for (int i = 3; i < clone_hole.size(); i++) {
            BoundaryNode *top = hull.top();
            hull.pop();
            while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
                top = hull.top();
                hull.pop();
            }
            hull.push(top);
            hull.push(clone_hole[i]);
        }

        while (!hull.empty()) {
            BoundaryNode *top = hull.top();
            top->is_convex_hull_boundary_ = true;
            convex.push_back(*top);
            hull.pop();
        }

        result.push_back(convex);
    }
    return result;
}

std::vector<Point>
VR1Agent::scaleOutsidePath(std::vector<BasePathPoint> bp, double theta, double gama, std::vector<CorePolygon> obs) {

    if (bp.size() == 0)
        return std::vector<Point>();

    std::vector<Point> result;

    // remove source node from path
    Point source = bp[0];
    bp.erase(bp.begin());

    // lay diem dest ra, ko vi tu
    Point dest = bp[bp.size() - 1];
    bp.erase(bp.end());

    // in case bp has only 2 elements
    if (bp.size() == 0) {
        result.push_back(source);
        result.push_back(dest);
        return result;
    }

    // chia duong di thanh cac doan con nam tren cung 1 core polygon
    std::vector<std::vector<BasePathPoint>> sub_path_set_;

    int k = 1;
    std::vector<BasePathPoint> tmp;
    for (int i = 0; i < bp.size(); i++) {
        if (bp[i].hole_id_ == k) {
            tmp.push_back(bp[i]);
        } else {
            sub_path_set_.push_back(tmp);
            k += 1;
            tmp.clear();
            tmp.push_back(bp[i]);
        }
    }
    sub_path_set_.push_back(tmp);   // push tmp cuoi cung
    tmp.clear();

    for (int i = 0; i < sub_path_set_.size(); i++) {
        tmp = sub_path_set_[i];
        int core_pol_id_ = sub_path_set_[i][0].hole_id_;

        // chon tam vi tu I bat ky nam trong core polygon
        Point I = Point(0, 0);
        double fr = 0;

        for (int j = 0; j < obs[core_pol_id_].vertices.size(); j++) {
            int ra = rand();
            I.x_ += obs[core_pol_id_].vertices[j].x_ * ra;
            I.y_ += obs[core_pol_id_].vertices[j].y_ * ra;
            fr += ra;
        }
        I.x_ = I.x_ / fr;
        I.y_ = I.y_ / fr;

        double x_i_ = Geo::pathLength(tmp);
        double y_i_ = G::distance(I, tmp[0]) + G::distance(I, tmp[tmp.size() - 1]);

        double z_i_ = 0;


        if (sub_path_set_.size() == 1) {
            z_i_ = G::distance(source, tmp[0]) + G::distance(dest, tmp[tmp.size() - 1]);
        } else {
            if (i == 0) {
                std::vector<BasePathPoint> tmp1 = sub_path_set_[i + 1];
                z_i_ = G::distance(source, tmp[0]) + (1 / 2) * G::distance(tmp[tmp.size() - 1], tmp1[0]);
            } else if (i == sub_path_set_.size() - 1) {
                std::vector<BasePathPoint> tmp1 = sub_path_set_[i - 1];
                z_i_ = G::distance(dest, tmp[tmp.size() - 1]) +
                       (1 / 2) * G::distance(tmp1[tmp1.size() - 1], tmp[0]);
            } else {
                std::vector<BasePathPoint> tmp1 = sub_path_set_[i + 1];
                std::vector<BasePathPoint> tmp2 = sub_path_set_[i - 1];
                z_i_ = (1 / 2) *
                       (G::distance(tmp1[0], tmp[tmp.size() - 1]) + G::distance(tmp2[tmp2.size() - 1], tmp[0]));
            }
        }

        double scale_ratio_ = (epsilon_o_ * theta * x_i_ + y_i_ + (epsilon_o_ * theta - 1) * z_i_) / (x_i_ + y_);

        for (int m = 0; m < tmp.size(); m++) {
            tmp[i].x_ = tmp[i].x_ * scale_ratio_ + I.x_ * (1 - scale_ratio_);
            tmp[i].y_ = tmp[i].y_ * scale_ratio_ + I.y_ * (1 - scale_ratio_);
            result.push_back(tmp[i]);
        }
        tmp.clear();
    }
    result.push_back(dest);
    return result;
}

std::vector<double> VR1Agent::findBasePathPriorityIndex(std::vector<std::vector<BasePathPoint>> bps) {
    std::vector<Point> C = convexHullOfAllCorePolygons();
    std::vector<double> result;
    int k = 0;  // number of bp's vertices staying outside of C's interior
    for (int i = 0; i < bps.size(); i++) {
        for (int j = 0; j < bps[i].size(); j++) {
            if (!G::isPointInsidePolygon(bps[i][j], C))
                k++;
        }
        result.push_back((double) (k + 2) / (double) (bps.size() + 2));
        k = 0;
    }

    double amountspeed = 0.0;

    for (int i = 0; i < bps.size(); i++) {
        amountspeed += result[i];
        result[i] = amountspeed;
    }

    for (int i = 0; i < bps.size(); i++) {
        if (amountspeed == 0.0)
            result[i] = (double) 1.0 / (double) bps.size();
        else
            result[i] = result[i] / amountspeed;
    }

    return result;
}

std::vector<Point> VR1Agent::convexHullOfAllCorePolygons() {
    std::vector<Point> convex;
    std::stack<BoundaryNode *> hull;
    std::vector<BoundaryNode *> clone_hole;

    for (corePolygon *it = core_polygon_set; it != NULL; it = it->next_) {
        for (node *n = it->node_; n != NULL; n = n->next_) {
            BoundaryNode *t = new BoundaryNode();
            t->x_ = n->x_;
            t->y_ = n->y_;
            clone_hole.push_back(t);
        }
    }

    std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
    BoundaryNode *pivot = clone_hole.front();
    std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
    hull.push(clone_hole[0]);
    hull.push(clone_hole[1]);
    hull.push(clone_hole[2]);

    for (int i = 3; i < clone_hole.size(); i++) {
        BoundaryNode *top = hull.top();
        hull.pop();
        while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
            top = hull.top();
            hull.pop();
        }
        hull.push(top);
        hull.push(clone_hole[i]);
    }

    while (!hull.empty()) {
        BoundaryNode *top = hull.top();
        convex.push_back(*top);
        hull.pop();
    }

    return convex;
}

int VR1Agent::getPathArraySize(Point *pth) {
    int i = 0;
    while (pth[i].x_ != 0 && pth[i].y_ != 0)
        i++;
    return i;
}

/*
 * Dump
 */
void VR1Agent::dumpCorePolygon() {
    FILE *fp = fopen("CorePolygon.tr", "a+");

    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        fprintf(fp, "%d\n", tmp->id_);
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            fprintf(fp, "%f\t%f\n", node->x_, node->y_);
        }
    }
    fclose(fp);
}

void VR1Agent::dump(Angle a, int i, int j, Line ln) {
    FILE *fp = fopen("Debug.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\t%f\t%d\t%d\t%f\t%f\t%f\t\n", my_id_, x_, y_, a, i, j, ln.a_, ln.b_, ln.c_);
    fclose(fp);
}

void VR1Agent::dumpBroadcastRegion() {
    FILE *fp = fopen("BroadcastRegion.tr", "a+");

    fprintf(fp, "%d\t%f\t%f\t", my_id_, x_, y_);
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        fprintf(fp, "%f\t%f\t", cg->node_->x_, cg->node_->y_);
    }
    fprintf(fp, "\n");
    fclose(fp);
}

void VR1Agent::dumpNodeInfo() {
    FILE *fp = fopen("NodeList.tr", "a+");

    fprintf(fp, "%g\t%g\n", this->x_, this->y_);
    fclose(fp);
}

void VR1Agent::dumpHopCount(hdr_vr1_data *hdr) {
    FILE *fp = fopen("HopCount.tr", "a+");
    fprintf(fp, "%d\t%d\n", hdr->source_id_, hdr->hopCount);
    fclose(fp);
}