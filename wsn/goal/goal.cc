#include <packet.h>
#include <algorithm>
#include <stack>
#include <wsn/goal/graph/goal_o_graph.h>
#include <wsn/versatilerouting_v1/graph/i_graph.h>
#include <wsn/goal/graph/goal_i_graph.h>
#include "goal.h"
#include "goal_packet_data.h"

using namespace std;

int hdr_goal::offset_;

// data packet header
static class GoalHeaderClass : public PacketHeaderClass {
public:
    GoalHeaderClass() : PacketHeaderClass("PacketHeader/GOAL", sizeof(hdr_all_goal)) {
        bind_offset(&hdr_goal::offset_);
    }
} class_goalhdr;


// each sensor node
static class GoalAgentClass : public TclClass {
public:
    GoalAgentClass() : TclClass("Agent/GOAL") {}

    TclObject *create(int, const char *const *) {
        return (new GoalAgent());
    }
} class_goal;

/*
 * Agent - initialize all parameters of a sensor
 */
GoalAgent::GoalAgent() : BoundHoleAgent(),
                         broadcast_timer_(this) {
    already_dump_energy_ = false;
    FILE *fp;
    fp = fopen("Neighbor.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("Dump.tr", "w");
    fclose(fp);
    fp = fopen("Debug.tr", "w");
    fclose(fp);
    fp = fopen("DebugGlobal.tr", "w");
    fclose(fp);
    fp = fopen("DebugConvex.tr", "w");
    fclose(fp);
    fp = fopen("DebugLocal.tr", "w");
    fclose(fp);
    fp = fopen("HopCount.tr", "w");
    fclose(fp);
}

int GoalAgent::command(int argc, const char *const *argv) {
    return BoundHoleAgent::command(argc, argv);
}

void GoalAgent::recv(Packet *p, Handler *h) {

    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);

    switch (cmh->ptype()) {
        case PT_GOAL:
            recvHCI(p);
            break;

        case PT_CBR:
            printf("%d recv data\n", this->my_id_);
            if (iph->saddr() == my_id_)     // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)   // a new packet
                {
                    sendData(p);
                } else      // (cmh->num_forwards() > 0) - routing loop -> drop
                {
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                drop(p, DROP_RTR_TTL);
                return;
            }
            recvData(p);
            break;

        default:
            BoundHoleAgent::recv(p, h);
            break;
    }
}

/*
 * Routing phase
 */
void GoalAgent::sendData(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_goal_data *hdc = HDR_GOAL_DATA(p);

    cmh->size() += IP_HDR_LEN + hdc->size();
    cmh->direction_ = hdr_cmn::DOWN;

    hdc->dest = *dest;
    hdc->hopCount = 0;
    hdc->source_id_ = this->my_id_;

    Point anchor = findNextAnchor(*this, *dest);
    hdc->anchor = anchor;

    iph->saddr() = my_id_;
    iph->daddr() = -1;
    iph->ttl_ = 4 * IP_DEF_TTL;
}

void GoalAgent::recvData(Packet *p) {
//    if (this->my_id_ == 830)
//        printf("here");

    /*
     * dump exhausted energy
     */
    if (node_->energy_model()->energy() < 1 && !already_dump_energy_) {
        already_dump_energy_ = true;
        FILE *fp = fopen("DiedEnergy.tr", "a+");
        fprintf(fp, "%f\t%d\t%f\t%f\t%f\n", NOW, this->my_id_, this->x_, this->y_, node_->energy_model()->energy());
        fclose(fp);
    }

    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_goal_data *edh = HDR_GOAL_DATA(p);

//    dumpEnergyByTime();

    if (cmh->direction() == hdr_cmn::UP && edh->dest == *this) {  // up to destination
        dumpHopCount(edh);
        port_dmux_->recv(p, 0);
        return;
    }

    node *nexthop = getNeighborByGreedy(edh->anchor);

    Point next_anchor_;

    while (nexthop == NULL) {
        next_anchor_ = findNextAnchor(edh->anchor, edh->dest);
        nexthop = getNeighborByGreedy(next_anchor_);
        edh->anchor = next_anchor_;
    }

    if (std::isnan(next_anchor_.x_)) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    } else {
        cmh->direction() = hdr_cmn::DOWN;
        cmh->addr_type() = NS_AF_INET;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = nexthop->id_;
        edh->hopCount++;
        send(p, 0);
        data_pkt_counter_++;
    }
}

void GoalAgent::createHole(Packet *p) {
    polygonHole *h = createPolygonHole(p);
    for (struct node *node_tmp = h->node_list_; node_tmp; node_tmp = node_tmp->next_) {
        BoundaryNode bn;
        bn.x_ = node_tmp->x_;
        bn.y_ = node_tmp->y_;
        bn.is_convex_hull_boundary_ = false;
        bn.id_ = node_tmp->id_;
        hole.push_back(bn);
    }
    delete h;
}

/*
 * Broadcast phase
 */
// broadcast hole's & core polygons's information
void GoalAgent::broadcastHCI() {
    Packet *p = NULL;
    GoalPacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_goal_ha *hdc;

    if (hole.empty())
        return;

    p = allocpkt();
    payload = new GoalPacketData();

    // add hole's nodes to local packet
    for (int i = 0; i < hole.size(); i++) {
        payload->add(hole[i].id_, hole[i].x_, hole[i].y_, false);
    }
    std::vector<BoundaryNode> convex = determineConvexHull(hole);
    convex_set_.push_back(convex);

    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hdc = HDR_GOAL_HA(p);

    cmh->ptype() = PT_GOAL;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hdc->size();

    hdc->type_ = GOAL_LOCAL;

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 8 * IP_DEF_TTL;

    send(p, 0);
    HCI_counter_ += 1;
}

// broadcast hole's info to all network
void GoalAgent::recvHCI(Packet *p) {

    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_goal_ha *bhh = HDR_GOAL_HA(p);
    hdr_cmn *cmh = HDR_CMN(p);

    // if the hci packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        drop(p, "LoopHCI");
        return;
    }


    GoalPacketData *data = (GoalPacketData *) p->userdata();

    std::vector<BoundaryNode> recv_data_;
    for (int i = 1; i <= data->size(); i++) {
        BoundaryNode n = data->get_data(i);
        recv_data_.push_back(n);
    }


    if (bhh->type_ == GOAL_LOCAL) {   // recv hole's information
        FILE *fp = fopen("DebugLocal.tr", "a+");
        fprintf(fp, "%g\t%g\t%g\n", p->time_, this->x_, this->y_);
        fclose(fp);

        std::vector<BoundaryNode> convex = determineConvexHull(recv_data_);

//        if (this->my_id_ == 1325)
//            printf("here");

        // check to push convex to convex_set_;
        bool flag = true;
        for (int i = 0; i < convex_set_.size(); i++) {
            if (convex_set_[i][0] == convex[0]) {
                flag = false;
                break;
            }
        }
        if (flag)
            convex_set_.push_back(convex);

        if (!Geo::isPointInsidePolygon(*this, convex)) {
            updatePayload(p, convex);
            bhh->type_ = GOAL_GLOBAL;

        } else {
            if (!hole.empty()) {
                drop(p, "HoleRedundant");
                return;
            } else
                hole.insert(hole.end(), recv_data_.begin(), recv_data_.end());
        }


        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0, 0.5));
        HCI_counter_++;


    } else if (bhh->type_ == GOAL_GLOBAL) {    // recv convex's information

        FILE *fp = fopen("DebugGlobal.tr", "a+");
        fprintf(fp, "%g\t%g\t%g\n", p->time_, this->x_, this->y_);
        fclose(fp);

//        if (Geo::isPointInsidePolygon(*this, recv_data_)) {
//            drop(p, "Inside_Hole_Dont_Recv_Convex");
//            return;
//        }

        bool flag = true;
        for (int i = 0; i < convex_set_.size(); i++) {
            if (convex_set_[i][0] == recv_data_[0]) {
                flag = false;
                break;
            }
        }
        if (flag)
            convex_set_.push_back(recv_data_);
        else {
            drop(p, "Convex_Redundant");
            return;
        }

        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0, 0.5));
        HCI_counter_++;

    } else {
        drop(p, "Unknown_Goal_Type");
        return;
    }
}

void GoalAgent::updatePayload(Packet *p, std::vector<BoundaryNode> convex) {
    GoalPacketData *data = (GoalPacketData *) p->userdata();
    int k = data->size();
    for (int i = k; i > 0; i--)
        data->rmv_data(i);

    for (int i = 0; i < convex.size(); i++)
        data->add(convex[i].id_, convex[i].x_, convex[i].y_, true);
}

std::vector<BoundaryNode> GoalAgent::determineConvexHull(std::vector<BoundaryNode> hole_) {
    std::stack<BoundaryNode *> hull;
    std::vector<BoundaryNode> convex;
    std::vector<BoundaryNode *> clone_hole;

    for (std::vector<BoundaryNode>::iterator it = hole_.begin(); it != hole_.end(); ++it) {
        clone_hole.push_back(&(*it));
    }

    std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
    BoundaryNode *pivot = clone_hole.front();
    std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
    hull.push(clone_hole[0]);
    hull.push(clone_hole[1]);
    hull.push(clone_hole[2]);

    for (int i = 3; i < clone_hole.size(); i++) {
        BoundaryNode *top = hull.top();
        hull.pop();
        while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
            top = hull.top();
            hull.pop();
        }
        hull.push(top);
        hull.push(clone_hole[i]);
    }

    while (!hull.empty()) {
        BoundaryNode *top = hull.top();
        top->is_convex_hull_boundary_ = true;
        convex.push_back(*top);
        hull.pop();
    }

    return convex;
}

Point GoalAgent::findNextAnchor(Point s, Point d) {

    if (convex_set_.size() == 0)
        return d;
    int s_convex_index = -1, d_convex_index = -1;

    for (int i = 0; i < convex_set_.size(); i++) {
        if (Geo::isPointReallyInsidePolygon(s, convex_set_[i]))
            s_convex_index = i;
        if (Geo::isPointReallyInsidePolygon(d, convex_set_[i]))
            d_convex_index = i;
    }

//    if (this->my_id_ == 1325)
//        printf("here");

    if (s_convex_index != -1) {       // source nam trong convex hull
        std::vector<BoundaryNode> convex = determineConvexHull(hole);

        std::vector<Point> s_cave = determineCaveContainingNode(s, convex, hole);

        // get gate-point of s that shorter to d
        int gate_index_ = G::distance(s_cave[0], d) < G::distance(s_cave[s_cave.size() - 1], d) ? 0 : s_cave.size() - 1;

        GoalIGraph *graph = new GoalIGraph(s_cave);

        std::vector<Point> st_paths_;

        if (s_convex_index == d_convex_index)      // source & dest nam cung trong 1 convex hull
            st_paths_ = graph->shortestPath(s, d);
        else
            st_paths_ = graph->shortestPath(s, s_cave[gate_index_]);

        return st_paths_.size() == 0 ? d : st_paths_[1];     // st_paths_[0] chinh la source

    } else {                    // source nam ngoai hoac tren bien convex hull

        // 0. chuyen hole_set_ ve dang CorePolygon - muc dich de su dung lai source cua versatile routing
        std::vector<CorePolygon> core_pols;

        for (int i = 0; i < convex_set_.size(); i++) {
            CorePolygon *cp = new CorePolygon();
            for (int j = 0; j < convex_set_[i].size(); j++)
                cp->vertices.push_back(Point(convex_set_[i][j].x_, convex_set_[i][j].y_));
            core_pols.push_back(*cp);
        }

//        // 1. check xem dest co nam trong core polygon nao khong
//        CorePolygon dest_core_;
//        int dest_core_index_;
//
//        for (int i = 0; i < core_pols.size(); i++) {
//            if (G::isPointReallyInsidePolygon(d, core_pols[i].vertices)) {
//                dest_core_ = core_pols[i];
//                dest_core_index_ = i;
//                break;
//            }
//        }

        if (d_convex_index == -1) {         // neu d nam ngoai convex hull
            std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s, d);

            GoalOGraph graph = GoalOGraph(obs);     // dung do thi
            std::vector<BasePathPoint> st_paths_ = graph.shortestPath();   // shortest path

            return st_paths_.size() == 0 ? d : st_paths_[0];
        } else {    // d nam trong
            int gate_index_;
            std::vector<BoundaryNode> d_core_ = convex_set_[d_convex_index];
            for (int i = 0; i < d_core_.size() - 1; i++)
                gate_index_ = G::distance(d_core_[i], d) < G::distance(d_core_[i + 1], d) ? i : (i + 1);

            if (Geo::isPointInsidePolygon(s, d_core_)) {   // s nam trong hoac tren bien convex cua d
                std::vector<Point> d_cave_ = determineCaveContainingNode(d, d_core_, hole);
                if (Geo::isVertexOfPolygon(s, d_cave_) || Geo::isPointReallyInsidePolygon(s, d_core_)) {
                    GoalIGraph *graph = new GoalIGraph(d_cave_);
                    std::vector<Point> st_paths_ = graph->shortestPath(s, d);
                    return st_paths_.size() == 0 ? d : st_paths_[1];
                } else {
                    int min_index_ = G::distance(d, d_cave_[0]) < G::distance(d, d_cave_[d_cave_.size() - 1]) ? 0 :
                                     d_cave_.size() - 1;
                    std::vector<Point> st_paths_ = Geo::boundaryPath(s, d_cave_[min_index_], d_core_);

                    return st_paths_.size() == 0 ? d : st_paths_[1];
                }
            } else {                     // s nam ngoai cave cua d
                std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s, d_core_[gate_index_]);
                if (obs.size() == 2)        // obs chi chua source va dest
                    return obs[1].vertices[0];
                GoalOGraph graph = GoalOGraph(obs);

                std::vector<BasePathPoint> st_paths_ = graph.shortestPath();
                return st_paths_.size() == 0 ? d : st_paths_[0];
            }

        }

    }
}

std::vector<Point>
GoalAgent::determineCaveContainingNode(Point s, std::vector<BoundaryNode> convex, std::vector<BoundaryNode> hole) {
    if (hole.empty())
        return std::vector<Point>();

    // todo: neu minh dung con tro cho xac dinh convex, thi ko can lam buoc nay
    for (int i = 0; i < convex.size(); i++) {
        for (int k = 0; k < hole.size(); k++) {
            if (hole[k].x_ == convex[i].x_ && hole[k].y_ == convex[i].y_)
                hole[k].is_convex_hull_boundary_ = true;
        }
    }

    // rotate hole list, i.e. the first element is convex hull boundary
    int j = 0;
    while (!hole[j].is_convex_hull_boundary_)
        j++;
    rotate(hole.begin(), hole.begin() + j, hole.end());

    // determine cave containing s
    std::vector<Point> cave;
    for (unsigned int i = 0; i < hole.size() - 1; i++) {
        if (hole.at(i).is_convex_hull_boundary_ && s.x_ == hole.at(i).x_ && s.y_ == hole.at(i).y_) {
            break; // s is gate of cave & lies on convex hull's boundary
        }
        if (hole.at(i).is_convex_hull_boundary_ && !hole.at(i + 1).is_convex_hull_boundary_) {
            cave.push_back(hole.at(i++));
            while (!hole.at(i).is_convex_hull_boundary_) {
                cave.push_back(hole.at(i++));
                if (i == hole.size() - 1)
                    break;
            }
            cave.push_back(hole.at(i--));
            if (i == hole.size() - 2)
                cave.push_back(hole.at(0));
            if (cave.size() >= MIN_CAVE_VERTICES) {
                if (G::isPointInsidePolygon(s, cave))
                    break;
            }
            cave.clear();
        }
    }
    return cave;

}

/*
 * Dump
 */
void GoalAgent::dumpHopCount(hdr_goal_data *hdr) {
    FILE *fp = fopen("HopCount.tr", "a+");
    fprintf(fp, "%d\t%d\n", hdr->source_id_, hdr->hopCount);
    fclose(fp);
}