#include <packet.h>
#include "corbal_packet.h"
#include "corbal.h"
#include "corbal_packet_data.h"

#define ALPHA_  M_PI/6

int hdr_corbal::offset_;

static class CorbalHeaderClass : public PacketHeaderClass {
public:
    CorbalHeaderClass() : PacketHeaderClass("PacketHeader/CORBAL", sizeof(hdr_all_corbal)) {
        bind_offset(&hdr_corbal::offset_);
    }
} class_corbalhdr;

static class CorbalAgentClass : public TclClass {
public:
    CorbalAgentClass() : TclClass("Agent/CORBAL") {}

    TclObject *create(int, const char *const *) {
        return (new CorbalAgent());
    }
} class_corbal;

void
CorbalTimer::expire(Event *e) {
    (a_->*firing_)();
}

/**
 * Agent Implementatoion
 */
CorbalAgent::CorbalAgent() : GPSRAgent(),
                             findStuck_timer_(this, &CorbalAgent::findStuckAngle),
                             boundhole_timer_(this, &CorbalAgent::sendBoundHole),
                             broadcast_timer_(this) {
    stuck_angle_ = NULL;
    range_ = 40;
    limit_min_hop_ = 10;
    limit_max_hop_ = 80;
    n_ = 8;
    core_polygon_set = NULL;
    hole_ = NULL;
    epsilon_ = 0.95;
    sub_count = 0;
    num_array_ = 0;
    boundary_vertices_num = 0;
    boundhole_counter_ = 0;
    broadcast_counter_ = 0;
    fwd_counter_ = 0;

    bind("range_", &range_);
    bind("limit_boundhole_hop_", &limit_max_hop_);
    bind("min_boundhole_hop_", &limit_min_hop_);
    bind("n_", &n_);
    bind("epsilon_", &epsilon_);
    bind("net_width_", &network_width_);
    bind("net_height_", &network_height_);
    bind("k_n_", &k_n_);

    theta_n = 2 * M_PI / (n_ * (k_n_ + ALPHA_));
    sin_ = sin((n_ - 2) * M_PI / (2 * n_));
    gama_ = (1 + epsilon_) * sin_;
}

int
CorbalAgent::command(int argc, const char *const *argv) {
    if (argc == 2) {
        if (strcasecmp(argv[1], "start") == 0) {
            startUp();
        }
        if (strcasecmp(argv[1], "boundhole") == 0) {
            boundhole_timer_.resched(0.02 * my_id_);
//            boundhole_timer_.resched(randSend_.uniform(0.0, 5));
            return TCL_OK;
        }
        if (strcasecmp(argv[1], "dumpBroadcast") == 0) {
            dumpBroadcastRegion();
            return TCL_OK;
        }
    }

    return GPSRAgent::command(argc, argv);
}

void
CorbalAgent::recv(Packet *p, Handler *h) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);

    if (my_id_ == 125){
        int a= 0;
    }
    switch (cmh->ptype()) {
        case PT_HELLO:
            GPSRAgent::recv(p, h);
            break;

        case PT_CORBAL:
            recvCORBAL(p, h);
            break;

        case PT_CBR:
            if (iph->saddr() == my_id_)                // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)        // a new packet
                {
                    sendData(p);
                } else    //(cmh->num_forwards() > 0)	// routing loop -> drop
                {
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                drop(p, DROP_RTR_TTL);
                dumpDrop(iph, 0);
                return;
            }
            recvData(p);
            break;

        default:
            drop(p, " UnknowType");
            break;
    }
}

void CorbalAgent::recvCORBAL(Packet *p, Handler *h) {
    hdr_corbal_ha *bhh = HDR_CORBAL_HA(p);
    if (bhh->type_ == CORBAL_BOUNDHOLE) {
        recvBoundHole(p);
    } else if (bhh->type_ == CORBAL_HBA) // bhh->type_ == CORBAL_HBA
    {
        recvHBA(p);
    } else if (bhh->type_ == CORBAL_BROADCAST) {
        recvHCI(p);
    }
}

void
CorbalAgent::startUp() {
    findStuck_timer_.resched(65);

    // clear trace file
    FILE *fp;
    fp = fopen("Neighbors.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("CorePolygon.tr", "w");
    fclose(fp);
    fp = fopen("debug.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastRegion.tr", "w");
    fclose(fp);
    fp = fopen("DynamicScaleHole.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastEnergy.tr", "w");
    fclose(fp);
    fp = fopen("BigForbiddenArea.tr", "w");
    fclose(fp);
    fp = fopen("BI.tr", "w");
    fclose(fp);
    fp = fopen("helloCounter.tr", "w");
    fclose(fp);
    fp = fopen("boundholeCounter.tr", "w");
    fclose(fp);
    fp = fopen("broadcastCounter.tr", "w");
    fclose(fp);
    fp = fopen("Hopcounts.tr", "w");
    fclose(fp);
    fp = fopen("Drop.tr", "w");
    fclose(fp);
    fp = fopen("Path.tr", "w");
    fclose(fp);
}

/*
 * Boundhole phase
 */
void
CorbalAgent::findStuckAngle() {
    if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL) {
        stuck_angle_ = NULL;
        return;
    }

    node *nb1 = neighbor_list_; //u
    node *nb2 = neighbor_list_->next_; //v

    while (nb2) {
        Circle circle = G::circumcenter(this, nb1, nb2);
        Angle a = G::angle(this, nb1, this, &circle); // upO
        Angle b = G::angle(this, nb1, this, nb2); // upv
        Angle c = G::angle(this, &circle, this, nb2); //Opv

        // if O is outside range of node, nb1 and nb2 create a stuck angle with node
        if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
            stuckangle *new_angle = new stuckangle();
            new_angle->a_ = nb1;
            new_angle->b_ = nb2;
            new_angle->next_ = stuck_angle_;
            stuck_angle_ = new_angle;
        }

        nb1 = nb1->next_;
        nb2 = nb1->next_;
    }

    nb2 = neighbor_list_;
    Circle circle = G::circumcenter(this, nb1, nb2);
    Angle a = G::angle(this, nb1, this, &circle);
    Angle b = G::angle(this, nb1, this, nb2);
    Angle c = G::angle(this, &circle, this, nb2);

    // if O is outside range of node, nb1 and nb2 create a stuck angle with node
    if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
        stuckangle *new_angle = new stuckangle();
        new_angle->a_ = nb1;
        new_angle->b_ = nb2;
        new_angle->next_ = stuck_angle_;
        stuck_angle_ = new_angle;
    }
}

void CorbalAgent::sendBoundHole() {
    Packet *p;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_corbal_ha *bhh;

    for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
        p = allocpkt();

        CorbalPacketData *bhpkt_data = new CorbalPacketData();
        bhpkt_data->add(sa->b_->id_, sa->b_->x_, sa->b_->y_);
        bhpkt_data->add(my_id_, this->x_, this->y_);
        p->setdata(bhpkt_data);

        cmh = HDR_CMN(p);
        iph = HDR_IP(p);
        bhh = HDR_CORBAL_HA(p);

        cmh->ptype() = PT_CORBAL;
        cmh->direction() = hdr_cmn::DOWN;
        cmh->size() += IP_HDR_LEN + bhh->size() + bhpkt_data->data_len_;
        cmh->next_hop_ = sa->a_->id_;
        cmh->last_hop_ = my_id_;
        cmh->addr_type_ = NS_AF_INET;

        iph->saddr() = my_id_;
        iph->daddr() = sa->a_->id_;
        iph->sport() = RT_PORT;
        iph->dport() = RT_PORT;
        iph->ttl_ = limit_max_hop_;            // more than ttl_ hop => boundary => remove

        bhh->prev_ = *this;
        bhh->type_ = CORBAL_BOUNDHOLE;

        send(p, 0);
        boundhole_counter_ ++;
    }
}

void CorbalAgent::recvBoundHole(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_corbal_ha *bhh = HDR_CORBAL_HA(p);

    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    // if the boundhole packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        if (iph->ttl_ > (limit_max_hop_ - limit_min_hop_)) {
            drop(p, " SmallHole");    // drop hole that have less than limit_min_hop_ hop
        } else {
            hole_ = createPolygonHole(p);
            data->dump();
            if (cmh->uid_ == 1798 || cmh->uid_ == 1857){
                int a =0;
            }
            // starting sending HBA to hole boundary
            sendHBA(p);

        }
        return;
    }

    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

//	int lastcount = data->data_len_;

    node n = data->get_data(1);
    if (n.id_ != iph->saddr()) {
        // if this is second hop => remove "b"
        data->rmv_data(1);
    } else {
        // get the entry at index n-1
        n = data->get_data(data->size() - 1);
    }

    node *nb = getNeighborByBoundHole(&bhh->prev_, &n);

    // no neighbor to forward, drop message
    // it means the network is not interconnected
    if (nb == NULL) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    }

    // drop message for loop way
    node temp, next;

    for (int i = 1; i < data->size(); i++) {
        temp = data->get_data(i);
        next = data->get_data(i + 1);

        if (G::is_intersect2(this, nb, temp, next)) {
            if (G::distance(temp, nb) < range_) {
                while (data->size() >= (i + 1)) {
                    data->rmv_data(i + 1);
                }

                data->add(nb->id_, nb->x_, nb->y_);
                nb = getNeighborByBoundHole(nb, &temp);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            } else {
                nb = getNeighbor(next.id_);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            }
        }
    }

    // if neighbor already send boundhole message to that node
    if (iph->saddr() > my_id_) {
        for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
            if (sa->a_->id_ == nb->id_) {
                drop(p, "BOUNDHOLE_REPEAT");
                return;
            }
        }
    }

    data->add(my_id_, this->x_, this->y_);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = nb->id_;
    cmh->last_hop_ = my_id_;
//	cmh->size_ += (data->data_len_ - lastcount) * data->element_size_;

    iph->daddr() = nb->id_;

    bhh->prev_ = *this;

    send(p, 0);
    boundhole_counter_ ++;
}

node *CorbalAgent::getNeighborByBoundHole(Point *p, Point *prev) {
    Angle max_angle = -1;
    node *nb = NULL;

    for (node *temp = neighbor_list_; temp; temp = temp->next_) {
        Angle a = G::angle(this, p, this, temp);
        if (a > max_angle && (!G::is_intersect(this, temp, p, prev) ||
                              (temp->x_ == p->x_ && temp->y_ == p->y_) ||
                              (this->x_ == prev->x_ && this->y_ == prev->y_))) {
            max_angle = a;
            nb = temp;
        }
    }

    return nb;
}

/*
 * HBA phase
 */
void CorbalAgent::sendHBA(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_corbal_ha *bhh = HDR_CORBAL_HA(p);

    // update data payload - alloc memory for set of B(i) nodes
    data->add(my_id_, x_, y_); // add back H0 to end of array
    data->addHBA(n_, k_n_);
    // we need to call this function twice since there is a special case:
    // a node is belong to 2 edges of core polygon, i.e. this node is a vertex of core polygon
    isNodeStayOnBoundaryOfCorePolygon(p);
    isNodeStayOnBoundaryOfCorePolygon(p);

    node n = data->get_data(2);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = n.id_;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->ptype() = PT_CORBAL;
    cmh->num_forwards() = 0;
    cmh->size() += IP_HDR_LEN + bhh->size() + data->data_len_;

    iph->saddr() = my_id_;
    iph->daddr() = n.id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = IP_DEF_TTL;

    bhh->type_ = CORBAL_HBA;
    bhh->index_ = 2;

    send(p, 0);
    boundhole_counter_ ++;
}

void CorbalAgent::recvHBA(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_corbal_ha *bhh = HDR_CORBAL_HA(p);
    hdr_cmn *cmh = HDR_CMN(p);

    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    if (cmh->uid_ == 1798 || cmh->uid_ == 1857){
        int a =0;
    }
    hole_ = createPolygonHole(p);
    int i = bhh->index_;

    if (i < data->size() - (n_ + 1) * k_n_) {
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        nsaddr_t next_id = data->get_data(i + 1).id_;

        hdr_cmn *cmh = HDR_CMN(p);
        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = next_id;

        iph->daddr() = next_id;
        bhh->index_++;

        send(p, 0);
        boundhole_counter_ ++;
    } else { // back to H0
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        contructCorePolygonSet(p);
        if (cmh->uid_ == 1798 || cmh->uid_ == 1857){
            int a =0;
        }
        drop(p, "BOUNDHOLE_HBA");

        // broadcast HCI
        broadcastHCI();
    }
}

void CorbalAgent::contructCorePolygonSet(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    corePolygon *tmp_choose = new corePolygon();
    double area = 9999999, tmp_area = 0;

    for (int i = 1; i <= k_n_; i++) {
        corePolygon *new_core = new corePolygon();
        new_core->id_ = i;

        for (int j = 1; j <= n_; j++) {
            int j_1 = j == n_ ? 1 : j + 1;

            off = data_size + (n_ + 1) * (i - 1) + j;
            node b_j = data->get_Bi_data(off);
            off = data_size + (n_ + 1) * (i - 1) + j_1;
            node b_j_1 = data->get_Bi_data(off);

            Angle b_j_angle = (i - 1) * theta_n + (j - 1) * 2 * M_PI / n_;
            Angle b_j_1_angle = (i - 1) * theta_n + (j_1 - 1) * 2 * M_PI / n_;

            Line l_i_j = G::line(b_j, b_j_angle);
            Line l_i_j_1 = G::line(b_j_1, b_j_1_angle);

            Point intersection;
            if (G::intersection(l_i_j, l_i_j_1, intersection)) {
                addCorePolygonNode(intersection, new_core);
            }
        }

        if(areaCorePolygon(new_core) < area){
            tmp_choose = new_core;
            area = areaCorePolygon(new_core);
        }
        //new_core->next_ = core_polygon_set;
        //core_polygon_set = new_core;
    }
    tmp_choose->next_ = core_polygon_set;
    core_polygon_set = tmp_choose;

    /*corePolygon *tmp = NULL;
    corePolygon *tmp_choose = NULL;

    double area = 9999999, tmp_area = 0;
    tmp = core_polygon_set;
    while (tmp){
        tmp_area = areaCorePolygon(tmp);
        if (area > tmp_area){
            tmp_choose = tmp;
            area = tmp_area;
        }
        tmp = tmp->next_;
    }

    core_polygon_set = NULL;
    tmp_choose->next_ = core_polygon_set;
    core_polygon_set = tmp_choose;
     */
    //dumpCorePolygon();
}
double CorbalAgent::areaCorePolygon(corePolygon *tmp){
    node* node_tmp = tmp->node_;
    Point array_tmp[n_];
    double sum = 0, sum_a = 0, sum_b = 0;
    for (int i = 0; i < n_; i++){
        array_tmp[i] = *node_tmp;
        node_tmp = node_tmp->next_;
    }
    for (int i = 0; i < n_ - 1;i++){
        sum_a = sum_a + array_tmp[i].x_ * array_tmp[i+1].y_;
        sum_b = sum_b + array_tmp[i+1].x_ * array_tmp[i].y_;
    }
    sum_a = sum_a + array_tmp[n_-1].x_ * array_tmp[0].y_;
    sum_b = sum_b + array_tmp[1].x_ * array_tmp[n_ -1].y_;
    sum = (sum_a - sum_b)/2;
    if (sum < 0){
        sum = 0 - sum;
    }
    return  sum;
}

void CorbalAgent::addCorePolygonNode(Point newPoint, corePolygon *corePolygon) {
    node *newNode = new node();
    newNode->x_ = newPoint.x_;
    newNode->y_ = newPoint.y_;
    newNode->next_ = NULL;
    node *tmp = corePolygon->node_;
    while (tmp && tmp->next_) { tmp = tmp->next_; }
    if (tmp == NULL) corePolygon->node_ = newNode;
    else tmp->next_ = newNode;
}
// check if this node is on boundary of a core polygon
// if true then update the packet data payload for each (i,j) immediately
void CorbalAgent::isNodeStayOnBoundaryOfCorePolygon(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    int i;
    for (i = 1; i <= k_n_; i++) {
        bool first_time = false;
        // get next index of this B(i)

        off = data_size + (n_ + 1) * (i - 1);
        int next_index = data->get_next_index_of_Bi(off);

        if (next_index == 1) {
            next_index = n_ + 1;
        } else if (next_index == 0) {
            next_index = n_ + 1;
            first_time = true;
        }

        while (true) {
            next_index--;
            bool flag = false;
            double angle = (i - 1) * theta_n + (next_index - 1) * 2 * M_PI / n_;
            // draw line goes through this node and make with x-axis angle: mx + n = y
            Line l_n = G::line(this, angle);

            node tmp1, tmp2;
            int index;

            tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
            for (index = 1; index <= data_size; index++) {
                tmp2 = data->get_data(index);
                if (tmp2.id_ == my_id_) continue;
                if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                    flag = true;
                    break;
                }
            }

            if (next_index <= 0) break;
            if (flag && !first_time) break;
            if (flag) continue;

            first_time = false;
            // add N to set B(i, j)
            off = (i - 1) * (n_ + 1) + next_index + data_size;
            data->addBiNode(off, my_id_, x_, y_);
            off = data_size + (i - 1) * (n_ + 1);
            data->update_next_index_of_Bi(off, next_index);
            dump(angle, i, next_index, l_n);

            // check if next_index = 1 is valid
            if (next_index == n_) {
                flag = false;
                angle = (i - 1) * theta_n;
                // draw line goes through this node and make with x-axis angle: mx + n = y
                l_n = G::line(this, angle);

                tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
                for (index = 1; index <= data_size; index++) {
                    tmp2 = data->get_data(index);
                    if (tmp2.id_ == my_id_) continue;
                    if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                        flag = true;
                        break;
                    }
                }

                if (!flag) {
                    // add N to set B(i, j) but dont update next_index
                    off = (i - 1) * (n_ + 1) + 1 + data_size;
                    data->addBiNode(off, my_id_, x_, y_);
                    dump(angle, i, 1, l_n);
                }
            }
        }
    }
}

polygonHole *CorbalAgent::createPolygonHole(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    // create hole item
    polygonHole *hole_item = new polygonHole();
    hole_item->hole_id_ = my_id_;
    hole_item->node_list_ = NULL;

    // add node info to hole item
    struct node *item;

    for (int i = 1; i <= data->size(); i++) {
        node n = data->get_data(i);

        item = new node();
        item->x_ = n.x_;
        item->y_ = n.y_;
        item->next_ = hole_item->node_list_;
        hole_item->node_list_ = item;
    }

    return hole_item;
}

/*
 * HCI broadcast phase
 */
void CorbalAgent::broadcastHCI() {
    Packet *p = NULL;
    CorbalPacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_corbal_ha *hdc;

    /*   if (hole_ == NULL)
           return;*/

    p = allocpkt();
    payload = new CorbalPacketData();
    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            payload->add(-1, node->x_, node->y_);
        }
    }
    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hdc = HDR_CORBAL_HA(p);

    cmh->ptype() = PT_CORBAL;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hdc->size();

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 200;

    hdc->type_ = CORBAL_BROADCAST;

    dumpCorePolygon();

    send(p, 0);
    broadcast_counter_ ++ ;
}

void CorbalAgent::recvHCI(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);


    /*if (my_id_ == 1578) {
        int a = 1;
    }*/
    int offset = 0;
    /*if (cmh->uid_ == 1865){
        int a= 1;
        corePolygon *newCore = new corePolygon();
        // check if we already have this cg
        for (int j = 0; j < n_; j++) {
            offset = j;
            node newPoint = data->get_Bi_data(offset);
            addCorePolygonNode(newPoint, newCore);
        }

    }*/
    // if the hci packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        drop(p, "CorbalLoopHCI");
        return;
    }
    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    // store core polygon(s)
    corePolygon *diffCores = storeCorePolygons(p);
    if (diffCores == NULL) {
        drop(p, "HciReceived");
        return;
    }
/*
    if (hole_ == NULL) { // if not in hole boundary and received multi core polygons
        corePolygon *cg = chooseRandomCorePolygon(diffCores);
        updatePayload(p, cg);
        if (canBroadcast(cg)) {
            broadcast_timer_.setParameter(p);
            broadcast_timer_.resched(randSend_.uniform(0.0, 0.5));
            return;
        }
    } else {
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0.0, 0.5));
        return;
    }
    drop(p, "CorbalRegion_IsOutside");*/
    // broadcast message
    cmh->direction_ = hdr_cmn::DOWN;
    cmh->last_hop_  = my_id_;

    iph->ttl_--;
    if (iph->ttl_ <= 0)	drop(p, "Limit");
    else{
        //send(p, 0);
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0.0, 0.5));
        broadcast_counter_ ++;
    }
}

// core polygon selection & update payload data
corePolygon *CorbalAgent::storeCorePolygons(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int offset = 0;

    corePolygon *newCore = new corePolygon();
    // check if we already have this cg
    for (int j = 0; j < n_; j++) {
        offset = j;
        node newPoint = data->get_Bi_data(offset);
        addCorePolygonNode(newPoint, newCore);
    }

    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        node *nn = cg->node_;
        bool flag = true;
        for (node *n = newCore->node_; n; n = n->next_) {
            if (n->x_ != nn->x_ || n->y_ != nn->y_) {
                flag = false;
                break;
            }
            nn = nn->next_;
        }
        if (flag) {
            delete newCore;
            return NULL;
        }
    }


    // store new cg
    newCore->next_ = core_polygon_set;
    core_polygon_set = newCore;
    if (core_polygon_set != NULL){
        if (core_polygon_set->next_ != NULL){
            if (core_polygon_set->next_->next_ != NULL){
                int a= 0;
                //  dumpCorePolygon();
            }
        }
    }
    return newCore;
}

/*
corePolygon *CorbalAgent::chooseRandomCorePolygon(corePolygon* cg) {
    int num = 0;
    for (corePolygon *tmp = cg; tmp != NULL; tmp = tmp->next_) {
        num++;
    }
    RNG rand_;
    int selection = rand_.uniform(num);
    num = 0;
    for (corePolygon *tmp = cg; tmp != NULL; tmp = tmp->next_) {
        if (num == selection) {
            return tmp;
        }
        num++;
    }
    return cg;
}

// return true if it can continue broadcast or false if the broadcast range has reached
bool CorbalAgent::canBroadcast(corePolygon * cg) {
    // if node is inside polygon or in hole boundary, simply return
    if (hole_ || G::isPointInsidePolygon(this, cg->node_)) {
        return true;
    }

    node *pi, *pj;
    findViewLimitVertex(this, cg, &pi, &pj);

    double alpha = fabs(G::directedAngle(pi, this, pj)); // get absolute angle
    double l_c_n = g_min(G::distance(pi, this), G::distance(pj, this));
    // double l_c_n_ = distanceToPolygon(this, my_core_polygon);
    node *i = cg->node_;
    double p_c = 0;
    do {
        node *j = i->next_ == NULL ? cg->node_ : i->next_;
        p_c += G::distance(i, j);
        i = j;
    } while (i != cg->node_);

    double left_side = cos(alpha / 2);
    double right_side1 = 1 / (1 + epsilon_) + p_c * (1 - sin_) / l_c_n;
    double right_side2 = 1 / ((1 + epsilon_) * sin_);

    //double left_side = p_c_ / l_c_n_ * (0.3 / cos(alpha_ / 2) + 1) + 1 / cos(alpha_ / 2);
    //double right_side = s_;

 //   return !(left_side > right_side1 || left_side > right_side2);
	return !(left_side > right_side1);
}*/

void CorbalAgent::updatePayload(Packet *p, corePolygon *cg) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    for (int i = n_ * k_n_; i > 0; i--) {
        data->rmv_data(i);
    }
    for (node *node = cg->node_; node != NULL; node = node->next_) {
        data->add(-1, node->x_, node->y_);
    }
}

void CorbalAgent::findViewLimitVertex(Point *N, corePolygon *polygon, node **right, node **left) {
    node *pi, *pj, *tmp;
    pi = polygon->node_;
    pj = polygon->node_;
    tmp = polygon->node_;

    do {
        if (G::directedAngle(pi, N, tmp) > 0) {
            pi = tmp;
        }
        if (G::directedAngle(pj, N, tmp) < 0) {
            pj = tmp;
        }
        tmp = tmp->next_;
    } while (tmp && tmp != polygon->node_);

    *right = pi;
    *left = pj;
}

double CorbalAgent::distanceToPolygon(Point *p, corePolygon *polygon) {
    double distance = 0;
    node *i = polygon->node_;
    do {
        double len = G::distance(p, i);
        i = i->next_ == NULL ? polygon->node_ : i->next_;
        distance = distance > len ? distance : len;
    } while (i != polygon->node_);

    return distance;
}

/**
 * Routing phase
 */
void CorbalAgent::sendData(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_corbal_data *hdc = HDR_CORBAL_DATA(p);

    cmh->size() += IP_HDR_LEN + hdc->size();
    cmh->direction_ = hdr_cmn::DOWN;

    hdc->type_ = CORBAL_CBR_GREEDY;
    hdc->source = *this;
    hdc->routing_table[0] = *dest;
    hdc->sub = hdc->routing_table[0];
    hdc->routing_index = 1;
    hdc->hopcount_ = 0;

    iph->saddr() = my_id_;
    iph->ttl_ = 4 * IP_DEF_TTL;
    hdc->gprs_type_ = GPSR_GPSR;

    corePolygon *tmp = core_polygon_set;
    // Noi vong cho cac danh sach node cua cac core
    while(tmp){
        tmp->circleNodeList();
        tmp = tmp->next_;
    }

    if (core_list_st_.size() == 0){
        findHolelist(*this, *dest); //Tim danh sach cac holes nam tren doan thang st
    }

    if(iph->saddr() == 2524)
        printf("here");

    if (core_list_st_.size() > 0)
    {
        if (b_list_.size() == 0) { //Neu la lan phat goi tin dau tien,
            routing(hdc);
            edge tmp_b[40];
            int z = 0;
            for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++){
                tmp_b[z] = *iter;
                z++;
            }


            // select only base path whose all segments make a obstute angles with st
            double tmp_angle = 0;
            for (int i = 0; i < num_array_; i++){
                for (int j = 0; j < 19; j++){
                    tmp_angle = G::angle(*this, *dest, sub_node_final_array[i][j], sub_node_final_array[i][j+1]);
                    if (tmp_angle > M_PI/2 && tmp_angle < 3*M_PI/2){
                        for (int k = 0; k < 20; k++){
                            sub_node_final_array[i][k] = sub_node_final_array[num_array_-1][k];
                            sub_node_array[i][k] = sub_node_array[num_array_-1][k];
                        }
                        cost_sub[i] = cost_sub[num_array_ -1];
                        num_array_--;
                        i--;
                        break;
                    }
                }
            }

            for (int i = 0; i < 20; i++) {
                sub_node_array[num_array_][i] = sub_node[i];
                sub_node_final_array[num_array_][i] = sub_node_final[i];
            }
            cost_sub[num_array_] = cost_shortest_path_;
            num_array_++;

            //delete the base path that contains sub-path
            bool flag;
            for (int p = 0; p <num_array_; p++){ //xet [p][]
                for (int q = 0; q <num_array_; q++){ //duyet toan bo [q][]
                    if (p != q){
                        for (int x = 0; x < 20; x++){ //phan tu [q][x]
                            flag = false;
                            for (int y = 0; y < 20; y++){
                                if ((sub_node_final_array[q][x].x_ == sub_node_final_array[p][y].x_)
                                    || (sub_node_final_array[q][x].y_ == sub_node_final_array[p][y].y_ )){
                                    flag = true;
                                    break;
                                }
                            }
                            if (flag == false){
                                break;
                            }
                        }

                        if (flag){
                            for (int k = 0; k < 20; k++){
                                sub_node_final_array[p][k] = sub_node_final_array[num_array_-1][k];
                                sub_node_array[p][k] = sub_node_array[num_array_-1][k];
                            }
                            cost_sub[p] = cost_sub[num_array_ -1];
                            num_array_--;
                            p--;
                            break;
                        }
                        //   flag = true;
                    }
                }
            }

            // calculate priority index of each base path
            for (int i = 0; i < num_array_; i++){
                double n1 = 0.0; // total number of the vertices
                double n2 = 0.0; // number of boundary vertices
                for (int k = 0; k<20; k++){
                    if(sub_node_final_array[i][k].x_ == 0 && sub_node_final_array[i][k].y_ == 0)
                        break;
                    n1++;
                    for (int m = 0; m < boundary_vertices_num; m++){
                        if (sub_node_final_array[i][k].x_ == boundary_vertices[m].x_ &&  sub_node_final_array[i][k].y_ == boundary_vertices[m].y_){
                            n2 ++;
                        }
                    }
                }
                //    if(n2 > 0)
                priority_index_list[i] = (double)(n2+2.0)/(double)(n1+2.0);
                //    else
                //        priority_index_list[i] = 0.0;
            }

            double amountspeed = 0.0;

            for (int i = 0; i < num_array_; i++){
                amountspeed += priority_index_list[i];
                priority_index_list[i] = amountspeed;
            }

            for (int i = 0; i < num_array_; i++){
                if(amountspeed == 0.0)
                    priority_index_list[i] = (double)1.0/(double)num_array_;
                else
                    priority_index_list[i] = priority_index_list[i]/amountspeed;
            }


        }
        scale_path(hdc);
        hdc->sub = hdc->routing_table[1];
        hdc->sub_count = 1;
    }

}

void CorbalAgent::recvData(Packet *p) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_corbal_data *hdc = HDR_CORBAL_DATA(p);

    node *tmp;

    if (cmh->direction() == hdr_cmn::UP && iph->daddr() == my_id_)    // up to destination
    {
        port_dmux_->recv(p, 0);
        return;
    }

    node *nexthop = NULL;

    if(iph->saddr() == 2521){
        if(this->my_id_ == 2521){
            FILE *fp = fopen("Path.tr", "a+");
            fprintf(fp, "\n\n%f\t%f", this->x_, this->y_);
            fclose(fp);
        }
        else{
            FILE *fp = fopen("Path.tr", "a+");
            fprintf(fp, "\n%f\t%f", this->x_, this->y_);
            fclose(fp);
        }
    }

    if(iph->saddr() == 2521 && iph->ttl_ < 10){
        printf("here");
    }
// -------- forward by greedy
    if (hdc->routing_index > hdc->sub_count){
        nexthop = getNeighborByGreedy(hdc->sub);
        while (nexthop == NULL && hdc->routing_index > hdc->sub_count) {
            hdc->sub_count++;
            hdc->sub = hdc->routing_table[hdc->sub_count];
            if (hdc->routing_index > hdc->sub_count){
                nexthop = getNeighborByGreedy(hdc->sub);
            }else{
                nexthop = recvGPSR(p, hdc->sub);
            }
        }
    } else {
        nexthop = recvGPSR(p, hdc->sub);
    }


    if (nexthop == NULL)    // no neighbor close
    {
        printf("dropped: %f - %d\n", NOW, cmh->uid());
        drop(p, DROP_RTR_NO_ROUTE);
        dumpDrop(iph,1);
        return;
    } else {
        cmh->direction() = hdr_cmn::DOWN;
        cmh->addr_type() = NS_AF_INET;
        cmh->last_hop_ = my_id_;
        hdc->hopcount_ ++;
        fwd_counter_++;
        cmh->next_hop_ = nexthop->id_;
        if(cmh->next_hop_ == iph->daddr()){
            dumpHop(hdc, iph);
        }
        send(p, 0);
    }
}

node *CorbalAgent::recvGPSR(Packet *p, Point destionation) {
    struct hdr_corbal_data *egh = HDR_CORBAL_DATA(p);

    node *nb = NULL;

    switch (egh->gprs_type_) {
        case GPSR_GPSR:
            nb = this->getNeighborByGreedy(destionation, *this);

            if (nb == NULL) {
                nb = getNeighborByPerimeter(destionation);

                if (nb == NULL) {
                    return NULL;
                } else {
                    egh->gprs_type_ = GPSR_PERIME;
                    egh->peri_ = *this;
                }
            }
            break;

        case GPSR_PERIME:
            // try to get back to greedy mode
            nb = this->getNeighborByGreedy(destionation, egh->peri_);
            if (nb) {
                egh->gprs_type_ = GPSR_GPSR;
            } else {
                nb = getNeighborByPerimeter(egh->prev_);
                if (nb == NULL) {
                    return NULL;
                }
            }
            break;

        default:
            return NULL;
    }

    egh->prev_ = *this;

    return nb;
}

// scale_factor_ = -1 when SD not intersect with core polygon -> no need to routing
double CorbalAgent::calculateScaleFactor(Packet *p, corePolygon *my_core_polygon) {
    struct hdr_corbal_data *hdc = HDR_CORBAL_DATA(p);
    double scale_factor = 0;
    // check if SD intersect with core polygon
    int numIntersect = 0;
    node *n = my_core_polygon->node_;
    Line sd = G::line(this, hdc->routing_table[0]);
    do {
        node *next = n->next_ == NULL ? my_core_polygon->node_ : n->next_;
        if (G::is_in_line(n, this, hdc->routing_table[0]) && G::is_in_line(next, this, hdc->routing_table[0])) break;
        Point ins;
        if (G::lineSegmentIntersection(n, next, sd, ins)) numIntersect++;
        n = next;
    } while (n != my_core_polygon->node_);
    if (numIntersect <= 1) {
        scale_factor = -1;
        return scale_factor;
    }

    // calculate l_C(S,D)
    double l_c_sd = euclidLengthOfBRSP(this, &(hdc->routing_table[0]), my_core_polygon);
    double l_c_xd = euclidLengthOfBRSP(&(hdc->source), &(hdc->routing_table[0]), my_core_polygon);

    node *i = my_core_polygon->node_;
    double p_c = 0;
    do {
        node *j = i->next_ == NULL ? my_core_polygon->node_ : i->next_;
        p_c += G::distance(i, j);
        i = j;
    } while (i != my_core_polygon->node_);
    if (*this == hdc->source) { // S is source node -- (13) formula
        double xi1 = 1;
        double xi2 = 1 + ((1 + epsilon_) * sin_ * l_c_sd - l_c_sd) / p_c;
        double xi3 = 1 + ((1 + epsilon_) * (l_c_sd - (1 - sin_) * p_c) - l_c_sd) / p_c;
        if (xi1 >= xi2 && xi1 >= xi3) {
            scale_factor = xi1;
        } else if (xi2 >= xi1 && xi2 >= xi3) {
            scale_factor = xi2;
        } else {
            scale_factor = xi3;
        }
    } else { // S is sub-source node -- (14) formula
        double xi1 = 1;
        double xi2 = 1 + ((1 + epsilon_) * sin_ * l_c_sd - (G::distance(this, &(hdc->source)) + l_c_xd)) / p_c;
        double xi3 = 1 +
                     ((1 + epsilon_) * (l_c_sd - (1 - sin_) * p_c) - (G::distance(this, &(hdc->source)) + l_c_xd)) /
                     p_c;
        if (xi1 >= xi2 && xi1 >= xi3) {
            scale_factor = xi1;
        } else if (xi2 >= xi1 && xi2 >= xi3) {
            scale_factor = xi2;
        } else {
            scale_factor = xi3;
        }
    }
    return scale_factor;
}

double CorbalAgent::euclidLengthOfBRSP(Point *s, Point *d, corePolygon *polygon) {
    node *S1, *S2, *D1, *D2;
    findViewLimitVertex(s, polygon, &S1, &S2); // s1 = right, s2 = left
    findViewLimitVertex(d, polygon, &D2, &D1); // d1 = right, d2 = left

    // Line sd = G::line(s, d);
    //int s_side = G::position(S1, sd);
    //int d_side = G::position(D1, sd);

    polygon->circleNodeList();

    double length = 0;
    double dis = 0;

    /* ---- S S1 D1 D ---- */
    dis = G::distance(s, S1);
    for (node *i = S1; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, d);
    length = dis;

    /* ---- D D1 S1 S ---- */
    dis = G::distance(d, D1);
    for (node *i = D1; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, s);
    length = g_min(length, dis);

    /* ---- S S2 D2 D ---- */
    dis = G::distance(s, S2);
    for (node *i = S2; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, d);
    length = g_min(length, dis);

    /* ---- D D2 S2 S ---- */
    dis = G::distance(d, D2);
    for (node *i = D2; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, s);
    length = g_min(length, dis);

    polygon->unCircleNodeList();

    return length;
}


void CorbalAgent::bypassHole(Point *S, Point *D, corePolygon *scalePolygon, corePolygon *corePolygon,
                             Point *routingTable, u_int8_t &routingCount) {
    node *S1, *S2, *D1, *D2;
    S1 = S2 = D1 = D2 = NULL;

    // uncircle node list
    scalePolygon->unCircleNodeList();

    if (G::isPointInsidePolygon(S, scalePolygon->node_)) {
        node *s1, *s2;
        findViewLimitVertex(S, corePolygon, &s1, &s2);
        node *tmp1 = corePolygon->node_;
        for (node *tmp = scalePolygon->node_; tmp != NULL; tmp = tmp->next_, tmp1 = tmp1->next_) {
            if (tmp1 == s1) {
                S1 = tmp;
            }
            if (tmp1 == s2) {
                S2 = tmp;
            }
        }
    } else {
        findViewLimitVertex(S, scalePolygon, &S1, &S2); // s1 = right, s2 = left
    }

    if (G::isPointInsidePolygon(D, scalePolygon->node_)) {
        node *d1, *d2;
        findViewLimitVertex(D, corePolygon, &d1, &d2);
        node *tmp1 = corePolygon->node_;
        for (node *tmp = scalePolygon->node_; tmp != NULL; tmp = tmp->next_, tmp1 = tmp1->next_) {
            if (tmp1 == d1) {
                D1 = tmp;
            }
            if (tmp1 == d2) {
                D2 = tmp;
            }
        }
    } else {
        findViewLimitVertex(D, scalePolygon, &D2, &D1); // d1 = right, d2 = left
    }

    scalePolygon->circleNodeList();

    double length = 0;
    double dis = 0;
    node *i = NULL;

    Point *routingTable_tmp = new Point[n_ + 1];
    u_int8_t routingCount_tmp;

    // ------------------------------------------------- S S1 D1 D
    dis = G::distance(this, S1);
    for (i = S1; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, D);
    length = dis;
    routingCount_tmp = 1;
    for (i = S1; i != D1->next_; i = i->next_) {
        addrouting(i, routingTable_tmp, routingCount_tmp);
    }
    // replace routing_table
    for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
        Point temp = routingTable_tmp[index];
        routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
        routingTable_tmp[routingCount_tmp - index] = temp;
    }
    // ------------------------------------------------- S S2 D2 D
    dis = G::distance(this, S2);
    for (i = S2; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S2; i != D2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- S S1 D2 D
    dis = G::distance(this, S1);
    for (i = S1; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S1; i != D2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- S S2 D1 D
    dis = G::distance(this, S2);
    for (i = S2; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S2; i != D1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- D D1 S1 S
    dis = G::distance(D, D1);
    for (i = D1; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D1; i != S1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D2 S2 S
    dis = G::distance(D, D2);
    for (i = D2; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D2; i != S2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D1 S2 S
    dis = G::distance(D, D1);
    for (i = D1; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D1; i != S2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D2 S1 S
    dis = G::distance(D, D2);
    for (i = D2; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D2; i != S1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }

    for (int j = 1; j < routingCount_tmp; j++) {
        routingTable[j] = routingTable_tmp[j];
    }
    routingCount = routingCount_tmp;
    delete[] routingTable_tmp;
}

void CorbalAgent::addrouting(Point *p, Point *routingTable, u_int8_t &routingCount) {
    for (int i = 0; i < routingCount; i++) {
        if ((routingTable[i].x_ == p->x_ && routingTable[i].y_ == p->y_))
            return;
    }

    routingTable[routingCount].x_ = p->x_;
    routingTable[routingCount].y_ = p->y_;
    routingCount++;
}

/**
 * Dump methods
 */
void CorbalAgent::dumpCorePolygon() {
    FILE *fp = fopen("CorePolygon.tr", "a+");

    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        fprintf(fp, "%d\n", tmp->id_);
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            fprintf(fp, "%f\t%f\n", node->x_, node->y_);
        }
    }
    fclose(fp);
}

void CorbalAgent::dump(Angle a, int i, int j, Line ln) {
    FILE *fp = fopen("debug.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\t%f\t%d\t%d\t%f\t%f\t%f\t\n", my_id_, x_, y_, a, i, j, ln.a_, ln.b_, ln.c_);
    fclose(fp);
}

void CorbalAgent::dumpBroadcastRegion() {
    FILE *fp = fopen("BroadcastRegion.tr", "a+");

    fprintf(fp, "%d\t%f\t%f\t", my_id_, x_, y_);
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        fprintf(fp, "%f\t%f\t", cg->node_->x_, cg->node_->y_);
    }
    fprintf(fp, "\n");
    fclose(fp);
}

void CorbalAgent::dumpScaleHole(Packet *p, corePolygon *hole) {
    hdr_cmn *cmh = HDR_CMN(p);

    FILE *fp = fopen("DynamicScaleHole.tr", "a+");

    node *n = hole->node_;
    do {
        fprintf(fp, "%d\t%f\t%f\n", cmh->uid_, n->x_, n->y_);
        n = n->next_;
    } while (n != hole->node_);

    fprintf(fp, "%d	%f	%f\n", cmh->uid_, n->x_, n->y_);
    fprintf(fp, "\n");

    fclose(fp);
}

void CorbalAgent::dumpBigForbiddenArea(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_corbal_data *hdc = HDR_CORBAL_DATA(p);
    hdr_ip *iph = HDR_IP(p);
    FILE *fp = fopen("BigForbiddenArea.tr", "a+");
    fprintf(fp, "%d\t%d\t%f\t%f\n", cmh->uid(), iph->saddr(), hdc->source.x_, hdc->source.y_);
    fclose(fp);
}


void
CorbalAgent::findBlist(node *s, node* t) {
    node *temp = new node();

    double a = b_list_.size();
    // tim tiep tuyen tu s den cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        findTangent(s, *iter, 0);
    }
    for (int i = 1; i <= count; i++){
        for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++){
            if(iter->id == i){
                double dis = 0;
                dis += G::distance(iter->a.x_, iter->a.y_, iter->b.x_, iter->b.y_)/2;
                if (dis==0)
                    dis = 0.001;
                addEdge(0,i,dis);
            }
        }
        //    add_edge(0,i,1);

    }
//     a = b_list_.size();

    //tim tiep tuyen cua cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        temp = (*iter)->node_;
        while (temp != NULL) {
            for (list<corePolygon *>::iterator iter2 = core_list_st_.begin(); iter2 != core_list_st_.end(); iter2++) {
                if ((*iter)->id_ < (*iter2)->id_) {
                    findTangent(temp, *iter2, (*iter)->id_);
                }
            }
            if (temp->next_ == (*iter)->node_) {
                break;
            }
            temp = temp->next_;
        }
    }
    a = b_list_.size();

    int ho = core_num + 1;
    int j = count +1;
    // tim tiep tuyen tu t den cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        findTangent(t, *iter, ho);
    }

    int final = count + 1;
    for (j; j < final; j++){
        //      add_edge(j,final,1);
        for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
            if (iter->id == j){
                double dis = 0;
                dis += G::distance(iter->a.x_, iter->a.y_, iter->b.x_, iter->b.y_)/2;
                if (dis==0)
                    dis = 0.001;
                addEdge(j, final, dis);
            }

        }
    }
    a = b_list_.size();
}

void
CorbalAgent::addEdge( int src, int dest, double cost)
{
    if (my_id_ == 1652){
        printf("Add: %d - %d: %f\n", src, dest, cost);
    }
    graph[src][dest] = cost;
    // graph[dest][src] = cost;

    return;
}


void
CorbalAgent::findHolelist(Point s, Point t) {
    corePolygon * tmp = core_polygon_set;
    bool Istersection = false;
    while (tmp != NULL){

        Istersection = is_intersect_poly2(tmp, s, t); //doan thang sS1
        if (Istersection){
            bool done = false;
            if (core_list_st_.size() == 0){
                core_num++;
                tmp->id_ = core_num;
                core_list_st_.push_back(tmp);
            } else {
                for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
                    if (G::distance(s.x_, s.y_, (*iter)->node_->x_, (*iter)->node_->y_)
                        > G::distance(s.x_, s.y_, tmp->node_->x_, tmp->node_->y_)) {
                        core_num++;
                        tmp->id_ = core_num;
                        core_list_st_.insert(iter, tmp);
                        done = true;
                        break;
                    }
                }
                if (!done){
                    core_num++;
                    tmp->id_ = core_num;
                    core_list_st_.push_back(tmp);
                }
            }

        } else{
            core_list_un_st_.push_back(tmp);
        };
        Istersection = false;
        tmp = tmp->next_;
    }
}

void
CorbalAgent::findTangent(node *s, corePolygon *tmp, int hole_nb) {
    // create routing table for packet p
    node* S1;	// min angle view of this node to hole
    node* S2;	// max angle view of this node to hole

    // ------------------- S1 S2 - view angle of this node to hole
    double Smax = 0;

    node* i = tmp->node_;
    do {
        for (node* j = i->next_; j != tmp->node_; j = j->next_)
        {
            // S1 S2
            double angle = G::angle(s, i, j);
            if (angle > Smax)
            {
                Smax = angle;
                S1 = i;
                S2 = j;
            }
        }
        i = i->next_;
    } while(i != tmp->node_);

    bool Istersection1 = false, Istersection2 = false;
    bool Istersection3 = false, Istersection4 = false;


    edge temp_edge;
//Kiem tra duong thang cat hole 1 chieu
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        if ((*iter)->id_ != tmp->id_ ) {
            if ((*iter)->id_ == hole_nb || hole_nb == (*iter)->id_  + 1) {
                if(!Istersection1) {
                    Istersection1 = is_intersect_poly(*iter, *s, *S1);
                }
                if(!Istersection2) {
                    Istersection2 = is_intersect_poly(*iter, *s, *S2);
                }
            }
        }
    }

    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        if ((*iter)->id_ != tmp->id_ && (*iter)->id_ != hole_nb) {
            if(!Istersection3){
                Istersection3 = is_intersect_poly2(*iter, *s, *S1); //doan thang sS1
            }
            if(!Istersection4) {
                Istersection4 = is_intersect_poly2(*iter, *s, *S2);
            }
        }
    }

    double tmp_angle = 0;
    if (!Istersection1 && !Istersection3 &&(hole_nb < tmp->id_ || hole_nb == core_num +1)) {
        tmp_angle = G::angle(*this,*dest,*s,*S1);
        if (tmp_angle < M_PI/2 || tmp_angle > 3*M_PI/2){
            temp_edge.a = *s;
            temp_edge.b = *S1;
            temp_edge.hole_num_1 = hole_nb;
            temp_edge.hole_num_2 = tmp->id_;
        }else{
            temp_edge.a = *S1;
            temp_edge.b = *s;
            temp_edge.hole_num_1 = tmp->id_;
            temp_edge.hole_num_2 = hole_nb;
        }
        count++;
        temp_edge.id = count;
        b_list_.push_back(temp_edge);
    }
    if (!Istersection2 && !Istersection4 && (hole_nb < tmp->id_ || hole_nb == core_num +1)){
        tmp_angle = G::angle(*this,*dest,*s,*S2);
        if (tmp_angle < M_PI/2 || tmp_angle > 3*M_PI/2){
            temp_edge.a = *s;
            temp_edge.b = *S2;
            temp_edge.hole_num_1 = hole_nb;
            temp_edge.hole_num_2 = tmp->id_;
        }else{
            temp_edge.a = *S2;
            temp_edge.b = *s;
            temp_edge.hole_num_1 = tmp->id_;
            temp_edge.hole_num_2 = hole_nb;
        }
        count ++;
        temp_edge.id = count;
        b_list_.push_back(temp_edge);
    }

    return;
}

// --------------------- Routing ---------------------------------- //

//Point ConvexHullAgent::routing(Point* dest)
void CorbalAgent::routing(hdr_corbal_data* edh)
{
    long a = -1;

    a = core_list_st_.size();
    node* s = new node();
    s->x_ = this->x_;
    s->y_ = this->y_;
    s->id_ = my_id_;

    node* t = new node();
    t->x_ = dest->x_;
    t->y_ = dest->y_;
    //   t->id_ = iph->daddr();

    if (this->my_id_ == 1506){
        printf("debug");
    }

    findClist(s,t); //Tim danh sach ho
    a = b_list_.size();

    /* use this when you want to use only core_list_st in determing the base paths
     for (list<corePolygon*>::iterator iter = core_list_c_.begin(); iter != core_list_c_.end(); iter++) {
        core_num++;
         (*iter)->id_ = core_num;
         core_list_st_.push_back(*iter);
     }
     */

    //use this when you want to use all core polygon in determing the base paths
    core_list_st_.clear();
    corePolygon * tmp = core_polygon_set;
    while (tmp != NULL){
        core_num++;
        tmp->id_ = core_num;
        core_list_st_.push_back(tmp);
        tmp = tmp->next_;
    }


    a = core_list_st_.size();

    // find boundary vertices
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        node *first_node = (*iter)->node_;
        int mark = 0;
        for (node *node1 = (*iter)->node_; node1 != first_node || mark == 0; node1 = node1->next_) {
            // check each segment node, node->next
            mark = 1;
            bool has_positive_node = false;
            bool has_negative_node = false;
            double coe_x = node1->y_ - node1->next_->y_;
            double coe_y = node1->next_->x_ - node1->x_;
            double coe_c = node1->x_ * node1->next_->y_ - node1->next_->x_ * node1->y_;
            bool is_boundary_vertex = true;
            for (list<corePolygon *>::iterator iter2 = core_list_st_.begin(); iter2 != core_list_st_.end(); iter2++) {
                node *first_node2 = (*iter2)->node_;
                for(node *node2 = (*iter2)->node_; node2->next_ != first_node2; node2 = node2->next_){
                    if(coe_x * node2->x_ + coe_y * node2->y_ + coe_c > 0.000001){
                        has_positive_node = true;
                    }
                    else if (coe_x * node2->x_ + coe_y * node2->y_ + coe_c < -0.000001)
                        has_negative_node = true;
                    if(has_negative_node && has_positive_node){
                        is_boundary_vertex = false;
                        break;
                    }
                }
                if (is_boundary_vertex == false)
                    break;

            }
            if (is_boundary_vertex){
                if(boundary_vertices_num > 0){
                    if (boundary_vertices[boundary_vertices_num-1].x_ == node1->x_ && boundary_vertices[boundary_vertices_num-1].y_ == node1->y_){
                        boundary_vertices[boundary_vertices_num].x_ = node1->next_->x_;
                        boundary_vertices[boundary_vertices_num].y_ = node1->next_->y_;
                        boundary_vertices_num ++;
                    }
                    else{
                        boundary_vertices[boundary_vertices_num].x_ = node1->x_;
                        boundary_vertices[boundary_vertices_num].y_ = node1->y_;
                        boundary_vertices[boundary_vertices_num+1].x_ = node1->next_->x_;
                        boundary_vertices[boundary_vertices_num+1].y_ = node1->next_->y_;
                        boundary_vertices_num += 2;
                    }
                }
                else{
                    boundary_vertices[boundary_vertices_num].x_ = node1->x_;
                    boundary_vertices[boundary_vertices_num].y_ = node1->y_;
                    boundary_vertices[boundary_vertices_num+1].x_ = node1->next_->x_;
                    boundary_vertices[boundary_vertices_num+1].y_ = node1->next_->y_;
                    boundary_vertices_num += 2;
                }

            }
        }
    }

    b_list_.clear();
    count = 0;

    findBlist(s,t);

    int b = 0;
    edge test[30];
    if (my_id_ == 1416){
        for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
            test[b] = *iter;
            b++;
        }
    }

    buildGraph(); //Dung do thi

    //    dijkstra(0);
    V =  count + 2;
    dijkstra2(0);
    n = V;
    D = 0;
    C = V - 1;
    KhoiTao();
    cout<<"Duong di tu 0 den "<< C;
    TimKiem(1);
    //   induongdi(0,count,truoc);
    //	std::cout << "\n";


    for (int m = 0; m < num_array_; m++){
        int j = 0;
        for (int i = 1; i < sub_num_array[m][0]; i++) {
            for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
                if (sub_num_array[m][i] == iter->id) {
                    if (j == 0){
                        if (iter->a.x_ == this->x_ && iter->a.y_ == this->y_) {
                            sub_node_array[m][j].x_ = iter->a.x_;
                            sub_node_array[m][j].y_ = iter->a.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_1;
                            sub_node_array[m][j].tagent_num = iter->id;
                            j++;

                            sub_node_array[m][j].x_ = iter->b.x_;
                            sub_node_array[m][j].y_ = iter->b.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_2;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                        } else {
                            sub_node_array[m][j].x_ = iter->b.x_;
                            sub_node_array[m][j].y_ = iter->b.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_2;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                            sub_node_array[m][j].x_ = iter->a.x_;
                            sub_node_array[m][j].y_ = iter->a.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_1;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                        }
                    }else{
                        if (iter->hole_num_1 == sub_node_array[m][j-1].hole_num) {

                            sub_node_array[m][j].x_ = iter->a.x_;
                            sub_node_array[m][j].y_ = iter->a.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_1;
                            sub_node_array[m][j].tagent_num = iter->id;
                            j++;

                            sub_node_array[m][j].x_ = iter->b.x_;
                            sub_node_array[m][j].y_ = iter->b.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_2;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                        } else {
                            sub_node_array[m][j].x_ = iter->b.x_;
                            sub_node_array[m][j].y_ = iter->b.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_2;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                            sub_node_array[m][j].x_ = iter->a.x_;
                            sub_node_array[m][j].y_ = iter->a.y_;
                            sub_node_array[m][j].hole_num = iter->hole_num_1;
                            sub_node_array[m][j].tagent_num = iter->id;

                            j++;
                        }
                    }
                }
            }
        }


        sub_node_final_array[m][0] = sub_node_array[m][0];
        int k = 1;
        for (int i = 1; i < j; i++){
            if(sub_node_array[m][i - 1].hole_num == sub_node_array[m][i].hole_num){
                if (sub_node_array[m][i-1].x_ == sub_node_array[m][i].x_ && sub_node_array[m][i-1].y_ == sub_node_array[m][i].y_){
                    sub_node_final_array[m][k] = sub_node_array[m][i];
                    k++;
                } else{
                    k = findPointmid_ab2(sub_node_array[m][i-1],sub_node_array[m][i],k,m);
                }
            }
        }
        sub_node_final_array[m][k] = sub_node_array[m][j-1];
    }


    int j = 0;
    for (int i = 0; i < sub_count; i++) {
        //	std::cout << sub_num[i] << "\n";
        for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
            if (sub_num[i] == iter->id) {
                if (j == 0){
                    if (iter->a.x_ == this->x_ && iter->a.y_ == this->y_) {
                        sub_node[j].x_ = iter->a.x_;
                        sub_node[j].y_ = iter->a.y_;
                        sub_node[j].hole_num = iter->hole_num_1;
                        sub_node[j].tagent_num = iter->id;
                        j++;

                        sub_node[j].x_ = iter->b.x_;
                        sub_node[j].y_ = iter->b.y_;
                        sub_node[j].hole_num = iter->hole_num_2;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                    } else {
                        sub_node[j].x_ = iter->b.x_;
                        sub_node[j].y_ = iter->b.y_;
                        sub_node[j].hole_num = iter->hole_num_2;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                        sub_node[j].x_ = iter->a.x_;
                        sub_node[j].y_ = iter->a.y_;
                        sub_node[j].hole_num = iter->hole_num_1;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                    }
                }else{
                    if (iter->hole_num_1 == sub_node[j-1].hole_num) {

                        sub_node[j].x_ = iter->a.x_;
                        sub_node[j].y_ = iter->a.y_;
                        sub_node[j].hole_num = iter->hole_num_1;
                        sub_node[j].tagent_num = iter->id;
                        j++;

                        sub_node[j].x_ = iter->b.x_;
                        sub_node[j].y_ = iter->b.y_;
                        sub_node[j].hole_num = iter->hole_num_2;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                    } else {
                        sub_node[j].x_ = iter->b.x_;
                        sub_node[j].y_ = iter->b.y_;
                        sub_node[j].hole_num = iter->hole_num_2;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                        sub_node[j].x_ = iter->a.x_;
                        sub_node[j].y_ = iter->a.y_;
                        sub_node[j].hole_num = iter->hole_num_1;
                        sub_node[j].tagent_num = iter->id;

                        j++;
                    }
                }
            }
        }
    }


    sub_node_final[0] = sub_node[0];
    int k = 1;
    for (int i = 1; i < j; i++){
        if(sub_node[i - 1].hole_num == sub_node[i].hole_num){
            if (sub_node[i-1].x_ == sub_node[i].x_ && sub_node[i-1].y_ == sub_node[i].y_){
                sub_node_final[k] = sub_node[i];
                k++;
            } else{
                k = findPointmid_ab(sub_node[i-1],sub_node[i],k);
            }
        }
    }
    sub_node_final[k] = sub_node[j-1];

}

void
CorbalAgent::findClist(node *s, node* t) {
    node *temp = new node();

    double a = b_list_.size();
    // tim tiep tuyen tu s den cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        findTangent2(s, *iter, 0);
    }

    //tim tiep tuyen cua cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        temp = (*iter)->node_;
        while (temp != NULL) {
            for (list<corePolygon *>::iterator iter2 = core_list_st_.begin(); iter2 != core_list_st_.end(); iter2++) {
                if ((*iter)->id_ < (*iter2)->id_) {
                    findTangent2(temp, *iter2, (*iter)->id_);
                }
            }
            if (temp->next_ == (*iter)->node_) {
                break;
            }
            temp = temp->next_;
        }
    }
    a = b_list_.size();

    int ho = core_num + 1;
    // tim tiep tuyen tu t den cac hole
    for (list<corePolygon *>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        findTangent2(t, *iter, ho);
    }
}

void
CorbalAgent::buildGraph() {
    //Dung do thi
    int check = -1;
    corePolygon *tmp = NULL;
    node* node_list;
    Point a, b;
    for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
        for (list<edge>::iterator iter2 = b_list_.begin(); iter2 != b_list_.end(); iter2++) {
            if((*iter).id < (*iter2).id ){
                check = checkTangent(*iter,*iter2);
                if(check != -1){
                    for (list<corePolygon*>::iterator iter3 = core_list_st_.begin(); iter3 != core_list_st_.end(); iter3++) {
                        if ((*iter3)->id_ == check) {
                            tmp = (*iter3);
                            break;
                        }
                    }
                    node_list = tmp->node_;
                    bool flag1 = false, flag2 = false;
                    do {
                        if ((*iter).a.x_ == node_list->x_ && (*iter).a.y_ == node_list->y_ ){
                            a.x_ = (*iter).a.x_;
                            a.y_ = (*iter).a.y_;
                            flag1 = true;
                        }
                        if ((*iter).b.x_ == node_list->x_ && (*iter).b.y_ == node_list->y_ ){
                            a.x_ = (*iter).b.x_;
                            a.y_ = (*iter).b.y_;
                            flag1 = true;
                        }
                        if ((*iter2).a.x_ == node_list->x_ && (*iter2).a.y_ == node_list->y_ ){
                            b.x_ = (*iter2).a.x_;
                            b.y_ = (*iter2).a.y_;
                            flag2 = true;
                        }
                        if ((*iter2).b.x_ == node_list->x_ && (*iter2).b.y_ == node_list->y_ ){
                            b.x_ = (*iter2).b.x_;
                            b.y_ = (*iter2).b.y_;
                            flag2 = true;
                        }
                        if (flag1 && flag2){
                            break;
                        }
                        node_list = node_list->next_;
                    } while (node_list != NULL && node_list != tmp->node_);
                    if (!flag1 || !flag2){
                        int das = 0;
                    };
                    double dis_ab = 0;
                    if(a.x_ != b.x_ || a.y_ != b.y_) {
                        dis_ab = distance_ab(a, b, tmp);
                        double cir = circuit_poly(tmp); // chu vi hole
                        if (dis_ab > cir - dis_ab) {
                            dis_ab = cir - dis_ab;
                        }
                    }
                    double dis1 = G::distance(iter->a.x_, iter->a.y_, iter->b.x_, iter->b.y_);
                    double dis2 = G::distance(iter2->a.x_, iter2->a.y_, iter2->b.x_, iter2->b.y_);
                    dis_ab = dis_ab + dis1/2 + dis2/2;
                    if(dis_ab == 0) dis_ab = 0.001;
                    //add_edge(iter->id,iter2->id,dis_ab);
                    addEdge(iter->id,iter2->id,dis_ab);
                }
            }
        }
    }
}

int
CorbalAgent::checkTangent(edge a, edge b) {
    //if (a.hole_num_1 == b.hole_num_1 && a.hole_num_1 != 0) return a.hole_num_1;
    if (a.hole_num_2 == b.hole_num_1 && a.hole_num_2 != 0) return a.hole_num_2;
    if (a.hole_num_1 == b.hole_num_2 && a.hole_num_1 != 0) return a.hole_num_1;
    //if (a.hole_num_2 == b.hole_num_2 && a.hole_num_2 != 0) return a.hole_num_2;
    return -1;
}


void
CorbalAgent:: dijkstra2(int s) {
    double dist[V];  // The output array. dist[i] will hold
    // the shortest distance from src to i

    // sptSet[i] will true if vertex i is included / in shortest
    // path tree or shortest distance from src to i is finalized
    bool sptSet[V];

    // Parent array to store shortest path tree
    int parent[V];

    // Initialize all distances as INFINITE and stpSet[] as false
    for (int i = 0; i < V; i++)
    {
        parent[0] = -1;
        dist[i] = INT_MAX;
        sptSet[i] = false;
    }

    // Distance of source vertex from itself is always 0
    dist[s] = 0;

    // Find shortest path for all vertices
    for (int count = 0; count < V-1; count++)
    {
        // Pick the minimum distance vertex from the set of
        // vertices not yet processed. u is always equal to src
        // in first iteration.
        int u = minDistance(dist, sptSet);

        // Mark the picked vertex as processed
        sptSet[u] = true;

        // Update dist value of the adjacent vertices of the
        // picked vertex.
        for (int v = 0; v < V; v++)

            // Update dist[v] only if is not in sptSet, there is
            // an edge from u to v, and total weight of path from
            // src to v through u is smaller than current value of
            // dist[v]
            if (!sptSet[v] && graph[u][v] &&
                dist[u] + graph[u][v] < dist[v])
            {
                parent[v]  = u;
                dist[v] = dist[u] + graph[u][v];
            }
    }

    // print the constructed distance array
    printSolution(dist, V, parent);
}


int
CorbalAgent::minDistance(double dist[], bool sptSet[])
{
    // Initialize min value
    double min = INT_MAX;
    int min_index = 1;

    for (int v = 0; v < V; v++)
        if (!sptSet[v] && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

// Function to print shortest path from source to j
// using parent array
void CorbalAgent::printPath(int parent[], int j)
{
    // Base Case : If j is source
    if (parent[j]==-1)
        return;

    printPath(parent, parent[j]);

    sub_num[sub_count] = j;
    sub_count++;

    printf("%d ", j);
}

// A utility function to print the constructed distance
// array
int
CorbalAgent::printSolution(double dist[], int n, int parent[])
{
    int src = 0;
    printf("%d : ", my_id_);
    printf("Vertex\t  Distance\tPath\n");
    for (int i = 1; i < V; i++)
    {
        if (i == V-1){
            printf("\n%d -> %d \t\t %f\t\t%d ", src, i, dist[i], src);
            cost_shortest_path_ = dist[i];
            printPath(parent, i);
        }

    }
}

void
CorbalAgent::scale_path(hdr_corbal_data* edh) {
    srand(time(NULL));
    double cost = 0;
    double theta;
    corePolygon * tmp = new corePolygon();
    if (core_list_st_.size() > 4){
        int ad = 0;
    }
/*    bool flag = true;
    for (int p = 0; p <num_array_; p++){ //xet [p][]
        for (int q = 0; q <num_array_; q++){ //duyet toan bo [q][]
            if (p != q){
                for (int x = 0; x < 20; x++){ //phan tu [q][x]
                    for (int y = 0; y < 20; y++){
                        if ((sub_node_final_array[q][x].x_ != sub_node_final_array[p][y].x_)
                                || (sub_node_final_array[q][x].y_ != sub_node_final_array[p][y].y_ )){
                            flag = false;
                            break;
                        }
                    }
                }
                if (flag){
                    for (int k = 0; k < 20; k++){
                        sub_node_final_array[p][k] = sub_node_final_array[num_array_-1][k];
                        sub_node_array[p][k] = sub_node_array[num_array_-1][k];
                    }
                    cost_sub[p] = cost_sub[num_array_ -1];
                    num_array_--;
                    p--;
                    break;
                }
                flag = true;
            }
        }
    }*/

    // int m = rand() % num_array_;
    //gama_ = (1 + (1+epsilon_)/(cost_sub[m]/cost_shortest_path_)) * sin_;

    int m;

    double prob = fwdProb_.uniform(0.0, 1.0);
    for (int i = 0; i < num_array_; i++){
        if (prob <= priority_index_list[i]) {
            m = i;
            break;
        }
    }


    theta = cost_shortest_path_ / cost_sub[m];

    int v = 0;
    int subNodeNum = 0;

    for (v = 0; v < 20; v++){
        sub_node[v] = sub_node_array[m][v];
        //sub_node_final[v] = sub_node_final_array[m][v];

        if(sub_node[v].x_ == 0 && sub_node[v].y_==0){
            break;
        }
        subNodeNum ++;
    }

    for (v = 0; v < 20; v++){
        sub_node_final[v] = sub_node_final_array[m][v];
        edh->routing_table[v] = sub_node_final[v];
        if (sub_node_final[v].x_ == 0 && sub_node_final[v].y_ == 0){
            edh->routing_index = v -1;
            break;
        }
    }/*
    v = 0;
    for (v = 0; v < 20; v++){
        edh->routing_table[v] = sub_node[v];
        if (sub_node[v].x_ == 0 && sub_node[v].y_ == 0){
            edh->routing_index = v -1;
            break;
        }
    }*/

    double scale_factor_list[20];
    for (int i=0; i<20; i++){
        scale_factor_list[i] = 1;
    }
    Point scale_center[20];

    if(this->my_id_ == 2521){
        printf("here");
    }
    sub_list r1, r2;
    for (int k = 0; k < subNodeNum; k++){
        if (sub_node[k].hole_num == sub_node[k+1].hole_num){
            //cost = graph[sub_node[k].tagent_num][sub_node[k+1].tagent_num];
            //if (cost > 0) {
            for (list<corePolygon*>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
                if ((*iter)->id_ == sub_node[k].hole_num){
                    tmp = (*iter);
                    break;
                }
            }
            if (sub_node[k].x_ != sub_node[k+1].x_ || sub_node[k].y_ != sub_node[k+1].y_){
                cost = distance_ab(sub_node[k], sub_node[k+1], tmp);
                double cir = circuit_poly(tmp);
                if (cost > cir - cost) {
                    cost = cir - cost;
                }
            }

            double bj=0;
            Point I;
            if(cost==0){
                while(bj==0){
                    I = genrI(tmp);
                    bj = G::distance(I,sub_node[k]);
                }
            }
            else{
                I= genrI(tmp);
                bj = G::distance(I,sub_node[k]) + G::distance(I,sub_node[k+1]);
            }
            double cj = 0;
            if (k==1){
                cj = G::distance(sub_node[k-1],sub_node[k]) + G::distance(sub_node[k],sub_node[k+1])/2;
            }else if (sub_node[k+1].x_ == dest->x_ && sub_node[k+1].y_ == dest->y_){
                cj = G::distance(sub_node[k-1],sub_node[k])/2 + G::distance(sub_node[k],sub_node[k+1]);
            } else{
                cj = G::distance(sub_node[k-1],sub_node[k])/2 + G::distance(sub_node[k],sub_node[k+1])/2;
            }
            double scale_factor_ = (gama_ * theta * cost + bj + (gama_ * theta-1)*cj)/(cost + bj);
            if (scale_factor_ > 1){
                for (int i = 1; i <v; i++){
                    if(sub_node_final[i].hole_num == sub_node[k].hole_num){
                        r1.x_ = scale_factor_ * sub_node_final[i].x_ + (1 - scale_factor_) * I.x_;
                        r1.y_ = scale_factor_ * sub_node_final[i].y_ + (1 - scale_factor_) * I.y_;
                        double fix_scale = scale_factor_;
                        double fix_scale_previous = scale_factor_list[i-1];
                        while(is_intersect_poly4(edh->routing_table[i-1],r1) || r1.x_ <=5 || r1.y_ <= 5 ||
                              r1.x_ >= network_width_*0.95 || r1.y_ >= network_height_*0.95){
                            double scale_down = (double)(rand()%10)/10.0;
                            if(i > 1 && sub_node_final[i].hole_num != sub_node_final[i-1].hole_num){
                                fix_scale_previous = fix_scale_previous * scale_down;
                                fix_scale = fix_scale * scale_down;

                                if (fix_scale_previous < 1){
                                    fix_scale_previous = 1;
                                }

                                if (fix_scale < 1){
                                    fix_scale = 1;
                                }

                                edh->routing_table[i-1].x_ = fix_scale_previous * sub_node_final[i-1].x_ + (1 - fix_scale_previous) * scale_center[i-1].x_;
                                edh->routing_table[i-1].y_ = fix_scale_previous * sub_node_final[i-1].y_ + (1 - fix_scale_previous) * scale_center[i-1].y_;
                                r1.x_ = fix_scale * sub_node_final[i].x_ + (1 - fix_scale) * I.x_;
                                r1.y_ = fix_scale * sub_node_final[i].y_ + (1 - fix_scale) * I.y_;

                                if (fix_scale_previous == 1 && fix_scale == 1){
                                    break;
                                }

                            }
                            if(i==1 || sub_node_final[i].hole_num == sub_node_final[i-1].hole_num){
                                fix_scale = fix_scale * scale_down;
                                if (fix_scale < 1){
                                    fix_scale = 1;
                                }
                                r1.x_ = fix_scale * sub_node_final[i].x_ + (1 - fix_scale) * I.x_;
                                r1.y_ = fix_scale * sub_node_final[i].y_ + (1 - fix_scale) * I.y_;
                                if (fix_scale == 1){
                                    break;
                                }
                            }
                        }
                        edh->routing_table[i] = r1;
                        scale_factor_list[i] = fix_scale;
                        scale_center[i] = I;
                    }
                }

                /*
                r1.x_ = scale_factor_ * sub_node[k].x_ + (1 - scale_factor_) * I.x_;
                r1.y_ = scale_factor_ * sub_node[k].y_ + (1 - scale_factor_) * I.y_;
                double fix_scale = 1;
                while(is_intersect_poly3(sub_node[k],r1) || r1.x_ <=0 || r1.y_ <= 0 ||
                        r1.x_ >= network_width_ || r1.y_ >= network_height_){
                    fix_scale = scale_factor_ * 3/4;
                    if (fix_scale < 1){
                        fix_scale = 1;
                    }
                    r1.x_ = fix_scale * sub_node[k].x_ + (1 - fix_scale) * I.x_;
                    r1.y_ = fix_scale * sub_node[k].y_ + (1 - fix_scale) * I.y_;
                    if (fix_scale == 1){
                        break;
                    }
                };



                r2.x_ = scale_factor_ * sub_node[k+1].x_ + (1 - scale_factor_) * I.x_;
                r2.y_ = scale_factor_ * sub_node[k+1].y_ + (1 - scale_factor_) * I.y_;
                fix_scale = 1;
                while(is_intersect_poly3(sub_node[k+1],r2) || r2.x_ <=0 || r2.y_ <= 0 ||
                      r2.x_ >= network_width_ || r2.y_ >= network_height_){
                    fix_scale = scale_factor_ * 3/4;
                    if (fix_scale < 1){
                        fix_scale = 1;
                    }
                    r2.x_ = fix_scale * sub_node[k+1].x_ + (1 - fix_scale) * I.x_;
                    r2.y_ = fix_scale * sub_node[k+1].y_ + (1 - fix_scale) * I.y_;
                    if (fix_scale == 1){
                        break;
                    }
                }*/
                //    edh->routing_table[k] = r1;
                //  edh->routing_table[k+1] = r2;
            }


            //}

        }

    }

}




double
CorbalAgent::distance_ab(Point a, Point b, corePolygon *p) {
    node* temp = p->node_;
    double dis = 0;
    int i = -1;
    int j = 0;
    while (temp){
        if (temp->x_ == a.x_ && temp->y_ == a.y_) {
            i = 0;
            break;
        }
        if (temp->x_ == b.x_ && temp->y_ == b.y_) {
            i = 1;
            break;
        }
        temp = temp->next_;
    }
    if (i == 0){
        while(temp){
            dis = dis + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
            temp = temp->next_;
            if (temp->x_ == b.x_ && temp->y_ == b.y_) {
                break;
            }
        }
    } else if (i == 1){
        while(temp){
            dis = dis + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
            temp = temp->next_;
            if (temp->x_ == a.x_ && temp->y_ == a.y_) {
                break;
            }
        }
    } else {
        int b = 0;
    }
    return dis;
}

int
CorbalAgent::findPointmid_ab(sub_list a, sub_list b, int k ) {
    corePolygon *p;
    for (list<corePolygon*>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        if((*iter)->id_ == a.hole_num){
            p = (*iter);
        }
    }

    node* temp = p->node_;
    //node table_tmp_1[n_];
    node table_tmp_1[10];
    double dis_tmp_1 = 0;
    //node table_tmp_2[n_];
    node table_tmp_2[10];
    double dis_tmp_2 = 0;
    while (temp){
        if (temp->x_ == a.x_ && temp->y_ == a.y_) {
            break;
        }
        temp = temp->next_;
    }
    int i =0;

    while(temp){
        dis_tmp_1 = dis_tmp_1 + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
        table_tmp_1[i] = *temp;
        i++;
        temp = temp->next_;
        if (temp->x_ == b.x_ && temp->y_ == b.y_) {
            break;
        }
    }
    table_tmp_1[i] = *temp;

    int j=0;
    while(temp){
        dis_tmp_2 = dis_tmp_2 + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
        table_tmp_2[j] = *temp;
        j++;
        temp = temp->next_;
        if (temp->x_ == a.x_ && temp->y_ == a.y_) {
            break;
        }
    }
    table_tmp_2[j] = *temp;

    if (dis_tmp_1 <= dis_tmp_2){
        for (int m = 0; m <= i; m++){
            sub_node_final[k].x_ = table_tmp_1[m].x_;
            sub_node_final[k].y_ = table_tmp_1[m].y_;
            sub_node_final[k].hole_num = a.hole_num;
            k++;
        }
    } else{
        for (int m = j; m >= 0; m--){
            sub_node_final[k].x_ = table_tmp_2[m].x_;
            sub_node_final[k].y_ = table_tmp_2[m].y_;
            sub_node_final[k].hole_num = a.hole_num;
            k++;
        }
    }
    return k;
}

void CorbalAgent::dumpHop(hdr_corbal_data* edh, hdr_ip *iph) {
    FILE *fp = fopen("Hopcounts.tr", "a+");
    fprintf(fp, "%d\t%d\n", iph->saddr(), edh->hopcount_);
    fclose(fp);
}

void CorbalAgent::dumpDrop(hdr_ip *iph, int type_) {
    FILE *fp = fopen("Drop.tr", "a+");
    if(type_ == 0){
        fprintf(fp, "%d\t%s\n", iph->saddr(),"ttl");
    }
    if(type_ == 1){
        fprintf(fp, "%d\t%s\n", iph->saddr(),"no_neighbor");
    }

    fclose(fp);
}


/*Khi to cc tham s ban u cho chng trnh*/
void CorbalAgent::KhoiTao() {
    DanhDau = new char [n];
    L = new int [n];
    for (int i = 0; i<n; i++) {   //Tt c cc nh cha c nh du
        DanhDau[i] = 0;
        L[i] = 0;
    }
    DanhDau[D] = 1;      //nh du nh u tin
    L[0] = D;         //Lu li nh u tin l  nh xut pht
}
void CorbalAgent::InDuongDi(int SoCanh) {
    Dem++;
    int tmp_holenum = -1;
    Point tmp_prenode;
    double tmp_cost = 0;
    double tmp_angle = -2;
    double tmp_angle_2 = -2;
    bool flag = true;
    int tmp1 = 0, tmp2 =0;
    int k = 0;
    for (int j = 0; j <SoCanh-1; j++) {
        tmp1 = L[j];
        tmp2 = L[j + 1];
        tmp_cost += graph[tmp1][tmp2];
        for (list<edge>::iterator iter = b_list_.begin(); iter != b_list_.end(); iter++) {
            if (L[j] == iter->id) {
                if (k == 0){
                    if (iter->a.x_ == this->x_ && iter->a.y_ == this->y_) {
                        tmp_angle = G::angle(*this,*dest,iter->a,iter->b);
                        tmp_holenum = iter->hole_num_2;
                        tmp_prenode = iter->b;
                        k++;
                    } else {
                        tmp_angle = G::angle(*this,*dest,iter->b,iter->a);
                        tmp_holenum = iter->hole_num_1;
                        tmp_prenode = iter->a;
                        k++;
                    }

                    if (tmp_angle > M_PI/2 && tmp_angle < 3*M_PI/2){
                        flag = false;
                        break;
                    }
                }else{
                    if (iter->hole_num_1 == tmp_holenum) {
                        tmp_angle = G::angle(*this,*dest,iter->a,iter->b);
                        tmp_angle_2 = G::angle(*this, *dest,tmp_prenode,iter->a);
                        if (iter->a.y_ > 1.2*tmp_prenode.y_ && (tmp_angle_2 < M_PI/2 || tmp_angle_2 > 3*M_PI/2)){
                            int a = 0;
                        }
                        tmp_holenum = iter->hole_num_2;
                        tmp_prenode = iter->b;

                    } else {
                        tmp_angle = G::angle(*this,*dest,iter->b,iter->a);
                        tmp_angle_2 = G::angle(*this, *dest,tmp_prenode,iter->b);
                        if (iter->b.y_ > 1.2*tmp_prenode.y_ && (tmp_angle_2 < M_PI/2 || tmp_angle_2 > 3*M_PI/2)){
                            int a = 0;
                        }
                        tmp_holenum = iter->hole_num_1;
                        tmp_prenode = iter->a;
                    }

                    if (tmp_angle > M_PI/2 && tmp_angle < 3*M_PI/2 && tmp_angle_2 > M_PI/2 && tmp_angle_2 < 3*M_PI/2){
                        flag = false;
                        break;
                    }
                }
            }
        }
    }

    if (tmp_cost <= cost_shortest_path_ * (1 + epsilon_)*sin_ && num_array_ < 200 && flag){
        cout<<endl<<D;
        int i = 1;
        for (i = 1; i<SoCanh; i++){
            cout<<" -> "<<L[i];
            sub_num_array[num_array_][i] = L[i];
        }
        sub_num_array[num_array_][0] = i ;
        cost_sub[num_array_] = tmp_cost;
        num_array_++;
        cout<<"\n";
    }
}
/*Th tc  quy tm kim ng i*/
void CorbalAgent::TimKiem(int SoCanh) {
    if(L[SoCanh-1] == C)      //Xut nu nh tm t ln tm kim trc bng C
        InDuongDi(SoCanh);
    else {
        for(int i = 0; i<n; i++)
            if( graph[L[SoCanh-1]][i]>0 && DanhDau[i] == 0 ){
                L[SoCanh] = i;      //Lu li nh i qua
                DanhDau[i] = 1;      //nh du nh i qua
                TimKiem(SoCanh+1);   //Tm kim nh tip theo
                L[SoCanh] = 0;
                DanhDau[i] = 0;      //Phc hi nh nh  i qua
            }
    }
}

int
CorbalAgent::findPointmid_ab2(sub_list a, sub_list b, int k, int m ) {
    corePolygon *p;
    for (list<corePolygon*>::iterator iter = core_list_st_.begin(); iter != core_list_st_.end(); iter++) {
        if((*iter)->id_ == a.hole_num){
            p = (*iter);
        }
    }

    node* temp = p->node_;
    //node table_tmp_1[n_];
    node table_tmp_1[10];
    double dis_tmp_1 = 0;
    //node table_tmp_2[n_];
    node table_tmp_2[10];
    double dis_tmp_2 = 0;
    while (temp){
        if (temp->x_ == a.x_ && temp->y_ == a.y_) {
            break;
        }
        temp = temp->next_;
    }
    int i =0;

    while(temp){
        dis_tmp_1 = dis_tmp_1 + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
        table_tmp_1[i] = *temp;
        i++;
        temp = temp->next_;
        if (temp->x_ == b.x_ && temp->y_ == b.y_) {
            break;
        }
    }
    table_tmp_1[i] = *temp;

    int j=0;
    while(temp){
        dis_tmp_2 = dis_tmp_2 + G::distance(temp->x_,temp->y_,temp->next_->x_,temp->next_->y_);
        table_tmp_2[j] = *temp;
        j++;
        temp = temp->next_;
        if (temp->x_ == a.x_ && temp->y_ == a.y_) {
            break;
        }
    }
    table_tmp_2[j] = *temp;

    if (dis_tmp_1 <= dis_tmp_2){
        for (int n = 0; n <= i; n++){
            sub_node_final_array[m][k].x_ = table_tmp_1[n].x_;
            sub_node_final_array[m][k].y_ = table_tmp_1[n].y_;
            sub_node_final_array[m][k].hole_num = a.hole_num;
            k++;
        }
    } else{
        for (int n = j; n >= 0; n--){
            sub_node_final_array[m][k].x_ = table_tmp_2[n].x_;
            sub_node_final_array[m][k].y_ = table_tmp_2[n].y_;
            sub_node_final_array[m][k].hole_num = a.hole_num;
            k++;
        }
    }
    return k;
}
