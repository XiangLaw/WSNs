#include <packet.h>
#include "corbal_packet.h"
#include "corbal.h"
#include "corbal_packet_data.h"

int hdr_corbal::offset_;

static class CorbalHeaderClass : public PacketHeaderClass {
public:
    CorbalHeaderClass() : PacketHeaderClass("PacketHeader/CORBAL", sizeof(hdr_corbal)) {
        bind_offset(&hdr_corbal::offset_);
    }
} class_corbalhdr;

static class CorbalAgentClass : public TclClass {
public:
    CorbalAgentClass() : TclClass("Agent/CORBAL") { }

    TclObject *create(int, const char *const *) {
        return (new CorbalAgent());
    }
} class_corbal;

void
CorbalTimer::expire(Event *e) {
    (a_->*firing_)();
}

/**
 * Agent Implementatoion
 */
CorbalAgent::CorbalAgent() : GPSRAgent(),
                             findStuck_timer_(this, &CorbalAgent::findStuckAngle),
                             boundhole_timer_(this, &CorbalAgent::sendBoundHole),
                             broadcast_timer_(this) {
    stuck_angle_ = NULL;
    range_ = 40;
    limit_min_hop_ = 10;
    limit_max_hop_ = 80;
    n_ = 8;
    core_polygon_set = NULL;
    hole_ = NULL;
    my_core_polygon = NULL;
    epsilon_ = 0.5;
    scale_factor_ = 0;
    p_c_ = 0;

    bind("range_", &range_);
    bind("limit_boundhole_hop_", &limit_max_hop_);
    bind("min_boundhole_hop_", &limit_min_hop_);
    bind("n_", &n_);
    bind("epsilon_", &epsilon_);
    bind("net_width_", &network_width_);
    bind("net_height_", &network_height_);
    bind("k_n_", &k_n_);

    theta_n = (2 * M_PI / n_ - 0.01) / (k_n_ - 1); // epsilon = 0.01
//    theta_n = 2 * M_PI * 1 / 9;
//    k_n_ = (int) floor((n_ - 2) * M_PI / (n_ * theta_n));
}

int
CorbalAgent::command(int argc, const char *const *argv) {
    if (argc == 2) {
        if (strcasecmp(argv[1], "start") == 0) {
            startUp();
        }
        if (strcasecmp(argv[1], "boundhole") == 0) {
            dumpBroadcastEnergy();
            boundhole_timer_.resched(0.02 * my_id_);
//            boundhole_timer_.resched(randSend_.uniform(0.0, 5));
            return TCL_OK;
        }
        if (strcasecmp(argv[1], "dumpEnergy") == 0) {
            dumpBroadcastEnergy();
            return TCL_OK;
        }
    }

    return GPSRAgent::command(argc, argv);
}

void
CorbalAgent::recv(Packet *p, Handler *h) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_corbal *bhh = HDR_CORBAL(p);

    switch (cmh->ptype()) {
        case PT_HELLO:
            GPSRAgent::recv(p, h);
            break;

        case PT_CORBAL:
            if (bhh->type_ == CORBAL_BOUNDHOLE) {
                recvBoundHole(p);
            }
            else if (bhh->type_ == CORBAL_HBA) // bhh->type_ == CORBAL_HBA
            {
                recvHBA(p);
            }
            else if (bhh->type_ == CORBAL_BROADCAST) {
                recvHCI(p);
            }
            break;

        case PT_CBR:
            if (iph->saddr() == my_id_)                // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)        // a new packet
                {
                    sendData(p);
                }
                else    //(cmh->num_forwards() > 0)	// routing loop -> drop
                {
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                drop(p, DROP_RTR_TTL);
                return;
            }
            recvData(p);
            break;

        default:
            drop(p, " UnknowType");
            break;
    }
}

void
CorbalAgent::startUp() {
    findStuck_timer_.resched(20);

    // clear trace file
    FILE *fp;
    fp = fopen("Neighbors.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("CorePolygon.tr", "w");
    fclose(fp);
    fp = fopen("debug.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastRegion.tr", "w");
    fclose(fp);
    fp = fopen("DynamicScaleHole.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastEnergy.tr", "w");
    fclose(fp);
}

/*
 * Boundhole phase
 */
void
CorbalAgent::findStuckAngle() {
    if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL) {
        stuck_angle_ = NULL;
        return;
    }

    node *nb1 = neighbor_list_; //u
    node *nb2 = neighbor_list_->next_; //v

    while (nb2) {
        Circle circle = G::circumcenter(this, nb1, nb2);
        Angle a = G::angle(this, nb1, this, &circle); // upO
        Angle b = G::angle(this, nb1, this, nb2); // upv
        Angle c = G::angle(this, &circle, this, nb2); //Opv

        // if O is outside range of node, nb1 and nb2 create a stuck angle with node
        if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
            stuckangle *new_angle = new stuckangle();
            new_angle->a_ = nb1;
            new_angle->b_ = nb2;
            new_angle->next_ = stuck_angle_;
            stuck_angle_ = new_angle;
        }

        nb1 = nb1->next_;
        nb2 = nb1->next_;
    }

    nb2 = neighbor_list_;
    Circle circle = G::circumcenter(this, nb1, nb2);
    Angle a = G::angle(this, nb1, this, &circle);
    Angle b = G::angle(this, nb1, this, nb2);
    Angle c = G::angle(this, &circle, this, nb2);

    // if O is outside range of node, nb1 and nb2 create a stuck angle with node
    if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
        stuckangle *new_angle = new stuckangle();
        new_angle->a_ = nb1;
        new_angle->b_ = nb2;
        new_angle->next_ = stuck_angle_;
        stuck_angle_ = new_angle;
    }
}

void CorbalAgent::sendBoundHole() {
    Packet *p;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_corbal *bhh;

    for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
        p = allocpkt();

        CorbalPacketData *bhpkt_data = new CorbalPacketData();
        bhpkt_data->add(sa->b_->id_, sa->b_->x_, sa->b_->y_);
        bhpkt_data->add(my_id_, this->x_, this->y_);
        p->setdata(bhpkt_data);

        cmh = HDR_CMN(p);
        iph = HDR_IP(p);
        bhh = HDR_CORBAL(p);

        cmh->ptype() = PT_CORBAL;
        cmh->direction() = hdr_cmn::DOWN;
        cmh->size() += IP_HDR_LEN + bhh->size() + bhpkt_data->data_len_;
        cmh->next_hop_ = sa->a_->id_;
        cmh->last_hop_ = my_id_;
        cmh->addr_type_ = NS_AF_INET;

        iph->saddr() = my_id_;
        iph->daddr() = sa->a_->id_;
        iph->sport() = RT_PORT;
        iph->dport() = RT_PORT;
        iph->ttl_ = limit_max_hop_;            // more than ttl_ hop => boundary => remove

        bhh->prev_ = *this;
        bhh->type_ = CORBAL_BOUNDHOLE;

        send(p, 0);
    }
}

void CorbalAgent::recvBoundHole(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_corbal *bhh = HDR_CORBAL(p);

    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    // if the boundhole packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        if (iph->ttl_ > (limit_max_hop_ - limit_min_hop_)) {
            drop(p, " SmallHole");    // drop hole that have less than limit_min_hop_ hop
        }
        else {
            hole_ = createPolygonHole(p);
            data->dump();
            // starting sending HBA to hole boundary
            sendHBA(p);
        }
        return;
    }

    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

//	int lastcount = data->data_len_;

    node n = data->get_data(1);
    if (n.id_ != iph->saddr()) {
        // if this is second hop => remove "b"
        data->rmv_data(1);
    }
    else {
        // get the entry at index n-1
        n = data->get_data(data->size() - 1);
    }

    node *nb = getNeighborByBoundHole(&bhh->prev_, &n);

    // no neighbor to forward, drop message
    // it means the network is not interconnected
    if (nb == NULL) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    }

    // drop message for loop way
    node temp, next;

    for (int i = 1; i < data->size(); i++) {
        temp = data->get_data(i);
        next = data->get_data(i + 1);

        if (G::is_intersect2(this, nb, temp, next)) {
            if (G::distance(temp, nb) < range_) {
                while (data->size() >= (i + 1)) {
                    data->rmv_data(i + 1);
                }

                data->add(nb->id_, nb->x_, nb->y_);
                nb = getNeighborByBoundHole(nb, &temp);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            }
            else {
                nb = getNeighbor(next.id_);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            }
        }
    }

    // if neighbor already send boundhole message to that node
    if (iph->saddr() > my_id_) {
        for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
            if (sa->a_->id_ == nb->id_) {
                drop(p, "BOUNDHOLE_REPEAT");
                return;
            }
        }
    }

    data->add(my_id_, this->x_, this->y_);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = nb->id_;
    cmh->last_hop_ = my_id_;
//	cmh->size_ += (data->data_len_ - lastcount) * data->element_size_;

    iph->daddr() = nb->id_;

    bhh->prev_ = *this;

    send(p, 0);
}

node *CorbalAgent::getNeighborByBoundHole(Point *p, Point *prev) {
    Angle max_angle = -1;
    node *nb = NULL;

    for (node *temp = neighbor_list_; temp; temp = temp->next_) {
        Angle a = G::angle(this, p, this, temp);
        if (a > max_angle && (!G::is_intersect(this, temp, p, prev) ||
                              (temp->x_ == p->x_ && temp->y_ == p->y_) ||
                              (this->x_ == prev->x_ && this->y_ == prev->y_))) {
            max_angle = a;
            nb = temp;
        }
    }

    return nb;
}

/*
 * HBA phase
 */
void CorbalAgent::sendHBA(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_corbal *bhh = HDR_CORBAL(p);

    // update data payload - alloc memory for set of B(i) nodes
    data->add(my_id_, x_, y_); // add back H0 to end of array
    data->addHBA(n_, k_n_);
    // TODO: refactor this scope. we need to call this function twice since there is a special case:
    // a node is belong to 2 edges of core polygon, i.e. this node is a vertex of core polygon
    isNodeStayOnBoundaryOfCorePolygon(p);
    isNodeStayOnBoundaryOfCorePolygon(p);

    node n = data->get_data(2);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = n.id_;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->ptype() = PT_CORBAL;
    cmh->num_forwards() = 0;
    cmh->size() += IP_HDR_LEN + bhh->size() + data->data_len_;

    iph->saddr() = my_id_;
    iph->daddr() = n.id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = IP_DEF_TTL;

    bhh->type_ = CORBAL_HBA;
    bhh->index_ = 2;

    send(p, 0);
}

void CorbalAgent::recvHBA(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_corbal *bhh = HDR_CORBAL(p);

    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    hole_ = createPolygonHole(p);
    int i = bhh->index_;

    if (i < data->size() - (n_ + 1) * k_n_) {
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        nsaddr_t next_id = data->get_data(i + 1).id_;

        hdr_cmn *cmh = HDR_CMN(p);
        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = next_id;

        iph->daddr() = next_id;
        bhh->index_++;

        send(p, 0);
    }
    else { // back to H0
        contructCorePolygonSet(p);
        drop(p, "BOUNDHOLE_HBA");

        // broadcast HCI
        broadcastHCI();
    }
}

void CorbalAgent::contructCorePolygonSet(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    for (int i = 1; i <= k_n_; i++) {
        corePolygon *new_core = new corePolygon();
        new_core->id_ = i;

        for (int j = 1; j <= n_; j++) {
            int j_1 = j == n_ ? 1 : j + 1;

            off = data_size + (n_ + 1) * (i - 1) + j;
            node b_j = data->get_Bi_data(off);
            off = data_size + (n_ + 1) * (i - 1) + j_1;
            node b_j_1 = data->get_Bi_data(off);

            Angle b_j_angle = i * theta_n + j * 2 * M_PI / n_;
            Angle b_j_1_angle = i * theta_n + j_1 * 2 * M_PI / n_;

            Line l_i_j = G::line(b_j, b_j_angle);
            Line l_i_j_1 = G::line(b_j_1, b_j_1_angle);

            Point intersection;
            if (G::intersection(l_i_j, l_i_j_1, intersection)) {
                addCorePolygonNode(intersection, new_core);
            }
        }

        new_core->next_ = core_polygon_set;
        core_polygon_set = new_core;
    }

    dumpCorePolygon();
}

void CorbalAgent::addCorePolygonNode(Point newPoint, corePolygon *corePolygon) {
    for (node *i = corePolygon->node_; i; i = i->next_) {
        if (*i == newPoint) return;
    }

    node *newNode = new node();
    newNode->x_ = newPoint.x_;
    newNode->y_ = newPoint.y_;
    newNode->next_ = corePolygon->node_;
    corePolygon->node_ = newNode;
}

// check if this node is on boundary of a core polygon
// if true then update the packet data payload for each (i,j) immediately
void CorbalAgent::isNodeStayOnBoundaryOfCorePolygon(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    int i;
    for (i = 1; i <= k_n_; i++) {
        bool first_time = false;
        // get next index of this B(i)

        off = data_size + (n_ + 1) * (i - 1);
        int next_index = data->get_next_index_of_Bi(off);

        if (next_index == 1) {
            next_index = n_ + 1;
        }
        else if (next_index == 0) {
            next_index = n_ + 1;
            first_time = true;
        }

        while (true) {
            next_index--;
            bool flag = false;
            double angle = i * theta_n + next_index * 2 * M_PI / n_;
            // draw line goes through this node and make with x-axis angle: mx + n = y
            Line l_n = G::line(this, angle);

            node tmp1, tmp2;
            int index;

            tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
            for (index = 1; index < data_size; index++) {
                tmp2 = data->get_data(index);
                if (tmp2.id_ == my_id_) continue;
                if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                    flag = true;
                    break;
                }
            }

            if (next_index <= 0) break;
            if (flag && !first_time) break;
            if (flag) continue;

            first_time = false;
            // add N to set B(i, j)
            off = (i - 1) * (n_ + 1) + next_index + data_size;
            data->addBiNode(off, my_id_, x_, y_);
            off = data_size + (i - 1) * (n_ + 1);
            data->update_next_index_of_Bi(off, next_index);
            dump(angle, i, next_index, l_n);
            printf("i = %d j = %d nodeid = %d\n", i, next_index, my_id_);

            // check if next_index = 1 is valid
            if (next_index == n_) {
                flag = false;
                angle = i * theta_n + 2 * M_PI / n_;
                // draw line goes through this node and make with x-axis angle: mx + n = y
                l_n = G::line(this, angle);

                tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
                for (index = 1; index < data_size; index++) {
                    tmp2 = data->get_data(index);
                    if (tmp2.id_ == my_id_) continue;
                    if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                        flag = true;
                        break;
                    }
                }

                if (!flag) {
                    // add N to set B(i, j) but dont update next_index
                    off = (i - 1) * (n_ + 1) + 1 + data_size;
                    data->addBiNode(off, my_id_, x_, y_);
                    dump(angle, i, 1, l_n);
                    printf("i = %d j = %d nodeid = %d\n", i, 1, my_id_);
                }
            }
        }
    }
}

polygonHole *CorbalAgent::createPolygonHole(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    // create hole item
    polygonHole *hole_item = new polygonHole();
    hole_item->hole_id_ = my_id_;
    hole_item->node_list_ = NULL;

    // add node info to hole item
    struct node *item;

    for (int i = 1; i <= data->size(); i++) {
        node n = data->get_data(i);

        item = new node();
        item->x_ = n.x_;
        item->y_ = n.y_;
        item->next_ = hole_item->node_list_;
        hole_item->node_list_ = item;
    }

    return hole_item;
}

/*
 * HCI broadcast phase
 */
void CorbalAgent::broadcastHCI() {
    Packet *p = NULL;
    CorbalPacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_corbal *hdc;

    if (hole_ == NULL)
        return;

    p = allocpkt();
    payload = new CorbalPacketData();
    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            payload->add(-1, node->x_, node->y_);
        }
    }
    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hdc = HDR_CORBAL(p);

    cmh->ptype() = PT_CORBAL;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hdc->size();

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 4 * IP_DEF_TTL;

    hdc->type_ = CORBAL_BROADCAST;

    corePolygonSelection(p);

    send(p, 0);
}

void CorbalAgent::recvHCI(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);

    // if the hci packet has came back to the initial node
    if (iph->saddr() == my_id_) {
        drop(p, "CorbalLoopHCI");
        return;
    }
    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    // check if is really receive this hole's information
    if (my_core_polygon != NULL)    // already received
    {
        drop(p, "HciReceived");
        return;
    }

    // select core polygon
    corePolygonSelection(p);

    if (!canBroadcast()) {
        drop(p, "CorbalRegion_IsOutside");
    }
    else {
        broadcast_timer_.setParameter(p);
        broadcast_timer_.resched(randSend_.uniform(0.0, 0.5));
    }

    dumpBroadcastRegion();
}

// core polygon selection & update payload data
void CorbalAgent::corePolygonSelection(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();
    int offset = 0;
    RNG rand_;
    int selection = rand_.uniform(k_n_);
    if (data->size() == n_) { // 1 core polygon only
        selection = 0;
    }

    // alloc
    my_core_polygon = new corePolygon();

    for (int j = 0; j < n_; j++) {
        offset = selection * n_ + j;
        node newPoint = data->get_Bi_data(offset);
        addCorePolygonNode(newPoint, my_core_polygon);
    }

    if (hole_ == NULL && data->size() > n_) { // if not in hole boundary and received multi core polygons
        updatePayload(p);
    }
}

// return true if it can continue broadcast or false if the broadcast range has reached
bool CorbalAgent::canBroadcast() {
    // if node is inside polygon or in hole boundary, simply return
    if (hole_ || G::isPointInsidePolygon(this, my_core_polygon->node_)) {
        return true;
    }

    node *pi, *pj;
    findViewLimitVertex(this, my_core_polygon, &pi, &pj);

    alpha_ = fabs(G::directedAngle(pi, this, pj)); // get absolute angle
    l_c_n_ = g_min(G::distance(pi, this), G::distance(pj, this));
    // double l_c_n_ = distanceToPolygon(this, my_core_polygon);
    node *i = my_core_polygon->node_;
    do {
        node *j = i->next_ == NULL ? my_core_polygon->node_ : i->next_;
        p_c_ += G::distance(i, j);
        i = j;
    } while (i != my_core_polygon->node_);

    double left_side = cos(alpha_ / 2);
    double right_side = 1 / (1 + epsilon_) + p_c_ * (1 - sin((n_ - 2) * M_PI / (2 * n_))) / l_c_n_;

    //double left_side = p_c_ / l_c_n_ * (0.3 / cos(alpha_ / 2) + 1) + 1 / cos(alpha_ / 2);
    //double right_side = s_;

    return left_side <= right_side;
}

void CorbalAgent::updatePayload(Packet *p) {
    CorbalPacketData *data = (CorbalPacketData *) p->userdata();

    for (int i = n_ * k_n_; i > 0; i--) {
        data->rmv_data(i);
    }
    for (node *node = my_core_polygon->node_; node != NULL; node = node->next_) {
        data->add(-1, node->x_, node->y_);
    }
}

void CorbalAgent::findViewLimitVertex(Point *N, corePolygon *polygon, node **right, node **left) {
    node *pi, *pj, *tmp;
    pi = polygon->node_;
    pj = polygon->node_;
    tmp = polygon->node_;

    do {
        if (G::directedAngle(pi, N, tmp) > 0) {
            pi = tmp;
        }
        if (G::directedAngle(pj, N, tmp) < 0) {
            pj = tmp;
        }
        tmp = tmp->next_;
    } while (tmp && tmp != polygon->node_);

    *right = pi;
    *left = pj;
}

double CorbalAgent::distanceToPolygon(Point *p, corePolygon *polygon) {
    double distance = 0;
    node *i = polygon->node_;
    do {
        double len = G::distance(p, i);
        i = i->next_ == NULL ? polygon->node_ : i->next_;
        distance = distance > len ? distance : len;
    } while (i != polygon->node_);

    return distance;
}

/**
 * Routing phase
 */
void CorbalAgent::sendData(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_corbal *hdc = HDR_CORBAL(p);

    cmh->size() += IP_HDR_LEN + hdc->size();
    cmh->direction_ = hdr_cmn::DOWN;

    hdc->type_ = CORBAL_CBR_GREEDY;
    hdc->dest = *dest;
    hdc->source = *this;
    hdc->routing_table[0] = *dest;
    hdc->routing_index = 1;

    iph->saddr() = my_id_;
    iph->ttl_ = 4 * IP_DEF_TTL;
    hdc->gprs_type_ = GPSR_GPSR;
}

void CorbalAgent::recvData(Packet *p) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_corbal *hdc = HDR_CORBAL(p);

    node *tmp;

    if (cmh->direction() == hdr_cmn::UP && iph->daddr() == my_id_)    // up to destination
    {
        port_dmux_->recv(p, 0);
        return;
    }

    if (my_core_polygon) {
        if (hdc->type_ == CORBAL_CBR_GREEDY) {
            // change to routing mode
            hdc->type_ = CORBAL_CBR_ROUTING;

            // calculate scale factor and check if SD intersects with hole
            calculateScaleFactor(p);
            if (scale_factor_ > 0) {
                // routing using corbal
                // random I
                Point I;
                I.x_ = 0;
                I.y_ = 0;
                double fr = 0;
                tmp = my_core_polygon->node_;
                do {
                    int ra = rand();
                    I.x_ += tmp->x_ * ra;
                    I.y_ += tmp->y_ * ra;
                    fr += ra;
                    tmp = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                } while (tmp != my_core_polygon->node_);

                I.x_ = I.x_ / fr;
                I.y_ = I.y_ / fr;

                double rand_angle = randSend_.uniform(0.0, 1.0) * 2 * M_PI;
                rand_angle = rand_angle > M_PI ? rand_angle - 2 * M_PI : rand_angle;
                Line rand_line = G::line(I, rand_angle);
                tmp = my_core_polygon->node_;
                Point rand_int;
                do {
                    node *tmp_next = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                    if (G::lineSegmentIntersection(tmp, tmp_next, rand_line, rand_int)) {
                        if (G::angle_x_axis(&I, &rand_int) * rand_angle >= 0) {
                            break;
                        }
                    }
                    tmp = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                } while (tmp != my_core_polygon->node_);

                double rand_distance = randSend_.uniform(0.0, 1.0) * G::distance(I, rand_int);
                Point I1, I2;
                G::circleLineIntersect(I, rand_distance, I, rand_int, &I1, &I2);
                if (G::onSegment(I, I1, rand_int)) {
                    I = I1;
                } else {
                    I = I2;
                }

                // scale hole by I and scale_factor_
                double real_scale_factor = scale_factor_;
                bool recalculate_scale_factor = false;

                corePolygon *revereScaleHole = new corePolygon();
                revereScaleHole->next_ = NULL;
                revereScaleHole->node_ = NULL;

                corePolygon *scaleHole = new corePolygon();
                scaleHole->next_ = NULL;
                scaleHole->node_ = NULL;

                // add new node
                tmp = my_core_polygon->node_;
                do {
                    double tmp_x = scale_factor_ * tmp->x_ + (1 - scale_factor_) * I.x_;
                    double tmp_y = scale_factor_ * tmp->y_ + (1 - scale_factor_) * I.y_;
                    if (tmp_x < 0 || tmp_y < 0 || tmp_x > network_width_ || tmp_y > network_height_) {
                        recalculate_scale_factor = true;
                        break;
                    }
                    tmp = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                } while (tmp != my_core_polygon->node_);

                if (recalculate_scale_factor) {
                    Point p_border[4] = {};
                    p_border[0].x_ = 0;
                    p_border[0].y_ = 0;
                    p_border[1].x_ = network_width_;
                    p_border[1].y_ = 0;
                    p_border[2].x_ = network_width_;
                    p_border[2].y_ = network_height_;
                    p_border[3].x_ = 0;
                    p_border[3].y_ = network_height_;

                    tmp = my_core_polygon->node_;
                    do {

                        Line I_node = G::line(I, tmp);
                        for (int i = 0; i < 4; i++) {
                            Point intersect;
                            if (G::lineSegmentIntersection(&p_border[i % 4], &p_border[(i + 1) % 4], I_node,
                                                           intersect) &&
                                G::onSegment(&I, tmp, &intersect)) {
                                double d1 = G::distance(I, tmp);
                                double d2 = G::distance(I, intersect);
                                if (real_scale_factor > d2 / d1) {
                                    real_scale_factor = d2 / d1;
                                }
                            }
                        }
                        tmp = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                    } while (tmp != my_core_polygon->node_);

                    real_scale_factor = 3 * real_scale_factor / 4;
                }

                tmp = my_core_polygon->node_;
                do {
                    node *newNode = new node();
                    newNode->x_ = real_scale_factor * tmp->x_ + (1 - real_scale_factor) * I.x_;
                    newNode->y_ = real_scale_factor * tmp->y_ + (1 - real_scale_factor) * I.y_;
                    newNode->next_ = revereScaleHole->node_;
                    revereScaleHole->node_ = newNode;

                    tmp = tmp->next_ == NULL ? my_core_polygon->node_ : tmp->next_;
                } while (tmp != my_core_polygon->node_);

                tmp = revereScaleHole->node_;
                do {
                    node *newNode = new node();
                    newNode->x_ = tmp->x_;
                    newNode->y_ = tmp->y_;
                    newNode->next_ = scaleHole->node_;
                    scaleHole->node_ = newNode;

                    tmp = tmp->next_ == NULL ? revereScaleHole->node_ : tmp->next_;
                } while (tmp != revereScaleHole->node_);

                // free reverse scale hole
                do {
                    tmp = revereScaleHole->node_;
                    revereScaleHole->node_ = revereScaleHole->node_->next_;
                    delete tmp;
                } while (revereScaleHole->node_);

                // circle node list
                tmp = scaleHole->node_;
                while (tmp->next_) tmp = tmp->next_;
                tmp->next_ = scaleHole->node_;

                dumpScaleHole(p, scaleHole);

                // generate routing table
                bypassHole(this, &(hdc->dest), scaleHole, my_core_polygon,
                           hdc->routing_table, hdc->routing_index);

                // free
                tmp = scaleHole->node_;
                while (tmp->next_ != scaleHole->node_) tmp = tmp->next_;
                tmp->next_ = NULL;

                do {
                    tmp = scaleHole->node_;
                    scaleHole->node_ = scaleHole->node_->next_;
                    delete tmp;
                } while (scaleHole->node_);
            }
        }
    }

    node *nexthop = NULL;
    while (nexthop == NULL && hdc->routing_index > 0) {
        if (hdc->routing_index == 1)
            nexthop = recvGPSR(p, hdc->routing_table[hdc->routing_index - 1]);
        else
            nexthop = getNeighborByGreedy(hdc->routing_table[hdc->routing_index - 1]);
        if (nexthop == NULL) {
            hdc->routing_index--;
        }
    }

    if (nexthop == NULL)    // no neighbor close
    {
        printf("dropped\n");
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    }
    else {
        cmh->direction() = hdr_cmn::DOWN;
        cmh->addr_type() = NS_AF_INET;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = nexthop->id_;
        send(p, 0);
    }
}

node *CorbalAgent::recvGPSR(Packet *p, Point destionation) {
    struct hdr_corbal *egh = HDR_CORBAL(p);

    node *nb = NULL;

    switch (egh->gprs_type_) {
        case GPSR_GPSR:
            nb = this->getNeighborByGreedy(destionation, *this);

            if (nb == NULL) {
                nb = getNeighborByPerimeter(destionation);

                if (nb == NULL) {
                    return NULL;
                }
                else {
                    egh->gprs_type_ = GPSR_PERIME;
                    egh->peri_ = *this;
                }
            }
            break;

        case GPSR_PERIME:
            // try to get back to greedy mode
            nb = this->getNeighborByGreedy(destionation, egh->peri_);
            if (nb) {
                egh->gprs_type_ = GPSR_GPSR;
            }
            else {
                nb = getNeighborByPerimeter(egh->prev_);
                if (nb == NULL) {
                    return NULL;
                }
            }
            break;

        default:
            return NULL;
    }

    egh->prev_ = *this;

    return nb;
}

// scale_factor_ = -1 when SD not intersect with core polygon -> no need to routing
void CorbalAgent::calculateScaleFactor(Packet *p) {
    struct hdr_corbal *hdc = HDR_CORBAL(p);

    if (scale_factor_ > 0 || scale_factor_ == -1) return; // calculated in the last time

    // check if SD intersect with core polygon
    int numIntersect = 0;
    node *n = my_core_polygon->node_;
    do {
        node *next = n->next_ == NULL ? my_core_polygon->node_ : n->next_;
        if (G::is_in_line(n, this, hdc->dest) && G::is_in_line(next, this, hdc->dest)) break;
        if (G::is_intersect(n, next, this, hdc->dest)) numIntersect++;
        n = next;
    } while (n != my_core_polygon->node_);
    if (numIntersect <= 1) {
        scale_factor_ = -1;
        return;
    }

    // calculate l_C(S,D)
    double l_c_sd = euclidLengthOfBRSP(this, &(hdc->dest), my_core_polygon);
    double l_c_xd = euclidLengthOfBRSP(&(hdc->source), &(hdc->dest), my_core_polygon);

    if (*this == hdc->source) { // S is source node
//        double delta = (s_ - 1) * l_c_sd / p_c_ -
//                       s_ * (1 - sin((n_ - 2) * M_PI / (2 * n_)));
        double delta = epsilon_ * l_c_sd - (1 + epsilon_) * (1 - sin((n_ - 2) * M_PI / (2 * n_))) * p_c_;
        if (delta > 0) {
            scale_factor_ = 1 + delta / p_c_;
        } else {
            scale_factor_ = 1;
        }
    }
    else { // S is sub-source node
        //double delta = (s_ * l_c_xd - l_c_sd - G::distance(this, &(hdc->source))) / p_c_ -
        //               s_ * (1 - sin((n_ - 2) * M_PI / (2 * n_)));
//        double delta = (s_ - 1 / cos(alpha_ / 2)) * l_c_n_ / p_c_ - 0.3 / cos(alpha_ / 2);
        double delta = (1 + epsilon_) * (l_c_xd) - l_c_sd - G::distance(this, &(hdc->source)) -
                       (1 + epsilon_) * (1 - sin((n_ - 2) * M_PI / (2 * n_))) * p_c_;
        if (delta > 0) {
            scale_factor_ = 1 + delta / p_c_;
        } else {
            scale_factor_ = 1;
        }
    }
}

double CorbalAgent::euclidLengthOfBRSP(Point *s, Point *d, corePolygon *polygon) {
    node *S1, *S2, *D1, *D2;
    findViewLimitVertex(s, polygon, &S1, &S2); // s1 = right, s2 = left
    findViewLimitVertex(d, polygon, &D2, &D1); // d1 = right, d2 = left

    // TODO: debug side of right, left
    // Line sd = G::line(s, d);
    //int s_side = G::position(S1, sd);
    //int d_side = G::position(D1, sd);

    polygon->circleNodeList();

    double length = 0;
    double dis = 0;

    /* ---- S S1 D1 D ---- */
    dis = G::distance(s, S1);
    for (node *i = S1; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, d);
    length = dis;

    /* ---- D D1 S1 S ---- */
    dis = G::distance(d, D1);
    for (node *i = D1; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, s);
    length = g_min(length, dis);

    /* ---- S S2 D2 D ---- */
    dis = G::distance(s, S2);
    for (node *i = S2; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, d);
    length = g_min(length, dis);

    /* ---- D D2 S2 S ---- */
    dis = G::distance(d, D2);
    for (node *i = D2; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, s);
    length = g_min(length, dis);

    polygon->unCircleNodeList();

    return length;
}


void CorbalAgent::bypassHole(Point *S, Point *D, corePolygon *scalePolygon, corePolygon *corePolygon,
                             Point *routingTable, u_int8_t &routingCount) {
    node *S1, *S2, *D1, *D2;
    S1 = S2 = D1 = D2 = NULL;

    // uncircle node list
    scalePolygon->unCircleNodeList();

    if (G::isPointInsidePolygon(S, scalePolygon->node_)) {
        node *s1, *s2;
        findViewLimitVertex(S, corePolygon, &s1, &s2);
        node *tmp1 = corePolygon->node_;
        for (node *tmp = scalePolygon->node_; tmp != NULL; tmp = tmp->next_, tmp1 = tmp1->next_) {
            if (tmp1 == s1) {
                S1 = tmp;
            } else if (tmp1 == s2) {
                S2 = tmp;
            }
        }
    } else {
        findViewLimitVertex(S, scalePolygon, &S1, &S2); // s1 = right, s2 = left
    }

    if (G::isPointInsidePolygon(D, scalePolygon->node_)) {
        node *d1, *d2;
        findViewLimitVertex(D, corePolygon, &d1, &d2);
        node *tmp1 = corePolygon->node_;
        for (node *tmp = scalePolygon->node_; tmp != NULL; tmp = tmp->next_, tmp1 = tmp1->next_) {
            if (tmp1 == d1) {
                D1 = tmp;
            } else if (tmp1 == d2) {
                D2 = tmp;
            }
        }
    } else {
        findViewLimitVertex(D, scalePolygon, &D2, &D1); // d1 = right, d2 = left
    }

    scalePolygon->circleNodeList();

    double length = 0;
    double dis = 0;
    node *i = NULL;

    Point *routingTable_tmp = new Point[n_ + 1];
    u_int8_t routingCount_tmp;

    // ------------------------------------------------- S S1 D1 D
    dis = G::distance(this, S1);
    for (i = S1; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, D);
    length = dis;
    routingCount_tmp = 1;
    for (i = S1; i != D1->next_; i = i->next_) {
        addrouting(i, routingTable_tmp, routingCount_tmp);
    }
    // replace routing_table
    for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
        Point temp = routingTable_tmp[index];
        routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
        routingTable_tmp[routingCount_tmp - index] = temp;
    }
    // ------------------------------------------------- S S2 D2 D
    dis = G::distance(this, S2);
    for (i = S2; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S2; i != D2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- S S1 D2 D
    dis = G::distance(this, S1);
    for (i = S1; i != D2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D2, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S1; i != D2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- S S2 D1 D
    dis = G::distance(this, S2);
    for (i = S2; i != D1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(D1, D);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = S2; i != D1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
        // replace routing_table
        for (int index = 1; index <= (routingCount_tmp - 1) / 2; index++) {
            Point temp = routingTable_tmp[index];
            routingTable_tmp[index] = routingTable_tmp[routingCount_tmp - index];
            routingTable_tmp[routingCount_tmp - index] = temp;
        }
    }
    // ------------------------------------------------- D D1 S1 S
    dis = G::distance(D, D1);
    for (i = D1; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D1; i != S1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D2 S2 S
    dis = G::distance(D, D2);
    for (i = D2; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, this);
    if (dis < length) {
        routingCount_tmp = 1;
        for (i = D2; i != S2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D1 S2 S
    dis = G::distance(D, D1);
    for (i = D1; i != S2; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S2, this);
    if (dis < length) {
        length = dis;
        routingCount_tmp = 1;
        for (i = D1; i != S2->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }
    // ------------------------------------------------- D D2 S1 S
    dis = G::distance(D, D2);
    for (i = D2; i != S1; i = i->next_) {
        dis += G::distance(i, i->next_);
    }
    dis += G::distance(S1, this);
    if (dis < length) {
        routingCount_tmp = 1;
        for (i = D2; i != S1->next_; i = i->next_) {
            addrouting(i, routingTable_tmp, routingCount_tmp);
        }
    }

    for (int j = 1; j <= routingCount_tmp; j++) {
        routingTable[j] = routingTable_tmp[j];
    }
    routingCount = routingCount_tmp;
    delete[] routingTable_tmp;
}

void CorbalAgent::addrouting(Point *p, Point *routingTable, u_int8_t &routingCount) {
    for (int i = 0; i < routingCount; i++) {
        if ((routingTable[i].x_ == p->x_ && routingTable[i].y_ == p->y_))
            return;
    }

    routingTable[routingCount].x_ = p->x_;
    routingTable[routingCount].y_ = p->y_;
    routingCount++;
}

/**
 * Dump methods
 */
void CorbalAgent::dumpCorePolygon() {
    FILE *fp = fopen("CorePolygon.tr", "a+");

    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        fprintf(fp, "%d\n", tmp->id_);
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            fprintf(fp, "%f\t%f\n", node->x_, node->y_);
        }
    }
    fclose(fp);
}

void CorbalAgent::dump(Angle a, int i, int j, Line ln) {
    FILE *fp = fopen("debug.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\t%f\t%d\t%d\t%f\t%f\t%f\t\n", my_id_, x_, y_, a, i, j, ln.a_, ln.b_, ln.c_);
    fclose(fp);
}

void CorbalAgent::dumpBroadcastRegion() {
    FILE *fp = fopen("BroadcastRegion.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\n", my_id_, x_, y_);
    fclose(fp);
}

void CorbalAgent::dumpScaleHole(Packet *p, corePolygon *hole) {
    hdr_cmn *cmh = HDR_CMN(p);

    FILE *fp = fopen("DynamicScaleHole.tr", "a+");

    node *n = hole->node_;
    do {
        fprintf(fp, "%d\t%f\t%f\n", cmh->uid_, n->x_, n->y_);
        n = n->next_;
    }
    while (n != hole->node_);

    fprintf(fp, "%d	%f	%f\n", cmh->uid_, n->x_, n->y_);
    fprintf(fp, "\n");

    fclose(fp);
}

void CorbalAgent::dumpBroadcastEnergy() {
    if (node_->energy_model()) {
        FILE *fp = fopen("BroadcastEnergy.tr", "a+");
        fprintf(fp, "%f\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n", NOW, my_id_, this->x_, this->y_,
                node_->energy_model()->energy(),
                node_->energy_model()->et(),
                node_->energy_model()->er(),
                node_->energy_model()->ei(),
                node_->energy_model()->es()
        );
        fclose(fp);
    }
}
