#include <packet.h>
#include <algorithm>
#include <stack>
#include <wsn/versatilerouting_v1/graph/o_graph.h>
#include <wsn/versatilerouting_v2/graph/vr2_o_graph.h>
#include <wsn/versatilerouting_v2/graph/vr2_i_graph.h>
#include "vr2.h"
#include "vr2_packet.h"
#include "vr2_packet_data.h"


#define ALPHA_ M_PI/6

int hdr_vr2::offset_;

// data packet header
static class VR2HeaderClass : public PacketHeaderClass {
public:
    VR2HeaderClass() : PacketHeaderClass("PacketHeader/VR2", sizeof(hdr_all_vr2)) {
        bind_offset(&hdr_vr2::offset_);
    }
} class_vr2hdr;


// each sensor node
static class VR2AgentClass : public TclClass {
public:
    VR2AgentClass() : TclClass("Agent/VR2") {}

    TclObject *create(int, const char *const *) {
        return (new VR2Agent());
    }
} class_vr2;

void VR2Timer::expire(Event *e) {
    (a_->*firing_)();
}

/*
 * Agent - initialize all parameters of a sensor
 */
VR2Agent::VR2Agent() : GPSRAgent(),
                       findStuck_timer_(this, &VR2Agent::findStuckAngle),
                       boundhole_timer_(this, &VR2Agent::sendBoundHole),
                       broadcast_timer_(this) {

    stuck_angle_ = NULL;
    range_ = 40;
    limit_min_hop_ = 10;
    limit_max_hop_ = 80;
    n_ = 8;
    epsilon_o_ = 0.5;
    epsilon_i_ = 0.5;
    core_polygon_set = NULL;
    already_dump_energy_ = false;

    bind("range_", &range_);
    bind("n_", &n_);
    bind("k_n_", &k_n_);
    bind("limit_boundhole_hop_", &limit_max_hop_);
    bind("min_boundhole_hop_", &limit_min_hop_);
    bind("epsilon_", &epsilon_o_);
    bind("epsilon_", &epsilon_i_);
    bind("net_width_", &network_width_);
    bind("net_height_", &network_height_);

    theta_n = 2 * M_PI / (n_ * (k_n_ + ALPHA_));
    alpha_ = sin((n_ - 2) * M_PI / (2 * n_));
}

int VR2Agent::command(int argc, const char *const *argv) {
    if (argc == 2) {
        if (strcasecmp(argv[1], "start") == 0) {
            startUp();
        }
        if (strcasecmp(argv[1], "boundhole") == 0) {
            boundhole_timer_.resched(0.02 * my_id_);
            return TCL_OK;
        }
        if (strcasecmp(argv[1], "dumpBroadcast") == 0) {
            dumpBroadcastRegion();
            dumpNodeInfo();
            return TCL_OK;
        }
    }
    return GPSRAgent::command(argc, argv);
}

void VR2Agent::recv(Packet *p, Handler *h) {
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_ip *iph = HDR_IP(p);

    switch (cmh->ptype()) {
        case PT_HELLO:
            GPSRAgent::recv(p, h);
            break;

        case PT_VR2:
            recvVR2(p);
            break;

        case PT_CBR:
            if (iph->saddr() == my_id_)     // a packet generated by myself
            {
                if (cmh->num_forwards() == 0)   // a new packet
                {
                    sendData(p);
                } else      // (cmh->num_forwards() > 0) - routing loop -> drop
                {
                    dumpDrop(iph->saddr(), 2);
                    drop(p, DROP_RTR_ROUTE_LOOP);
                    return;
                }
            }

            if (iph->ttl_-- <= 0) {
                dumpDrop(iph->saddr(), 0);
                drop(p, DROP_RTR_TTL);
                return;
            }
            recvData(p);
            break;

        default:
            drop(p, "UnknownType");
            break;
    }
}

/*
 * Routing phase
 */
void VR2Agent::sendData(Packet *p) {
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_vr2_data *hdc = HDR_VR2_DATA(p);

    cmh->size() += IP_HDR_LEN + hdc->size();
    cmh->direction_ = hdr_cmn::DOWN;

    hdc->apIndex = 0;
    hdc->hopCount = 0;
    hdc->dest = *dest;
    hdc->vr2_type_ = VR2_CBR_BLIND;
    hdc->source_id_ = this->my_id_;
    hdc->gprs_type_ = GPSR_GPSR;

    for (int i = 0; i < 30; i++) {
        hdc->path[i] = *dest;
    }

    iph->saddr() = my_id_;
    iph->daddr() = -1;
    iph->ttl_ = 8 * IP_DEF_TTL;

    if (my_id_ == 3691)
        printf("debug");

    if (my_id_ == 4436)
        printf("stuck into hole");

    if (hdc->vr2_type_ == VR2_CBR_BLIND && hasDestHoleInfo(hdc->dest)) {
        hdc->vr2_type_ = VR2_CBR_AWARE;
     //   findPath2(p);
        hdc->apIndex = 0;
    }

    findPath2(p);

    int q = 0;
    std::vector<Point> path_s_x;
    while (hdc->path[q] != *dest) {
        path_s_x.push_back(hdc->path[q]);
        q++;
    }

    hdc->B_s_t_ = Geo::pathLength(path_s_x);
}

void VR2Agent::recvData(Packet *p) {
    hdr_ip *iph = HDR_IP(p);

    printf("%d\trecv data\n", this->my_id_);

    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_vr2_data *edh = HDR_VR2_DATA(p);

    if (iph->saddr() == 3691 || iph->saddr() == 4281)
        printf("debug");

    /*
    * dump exhausted energy
    */
    if (node_->energy_model()->energy() < 1 && !already_dump_energy_) {
        already_dump_energy_ = true;
        FILE *fp = fopen("DiedEnergy.tr", "a+");
        fprintf(fp, "%f\t%d\t%f\t%f\t%f\n", NOW, this->my_id_, this->x_, this->y_, node_->energy_model()->energy());
        fclose(fp);
    }

    if (cmh->direction() == hdr_cmn::UP && edh->dest == *this) {  // up to destination
        dumpHopCount(edh);
        port_dmux_->recv(p, 0);
        return;
    }

    node *nexthop = NULL;

    if (edh->vr2_type_ == VR2_CBR_BLIND && hasDestHoleInfo(edh->dest)) {
        edh->vr2_type_ = VR2_CBR_AWARE;
        findPath2(p);
        edh->apIndex = 0;
    }

    nexthop = getNeighborByGreedy(edh->path[edh->apIndex]);

    // while (nexthop == NULL && edh->path[edh->apIndex + 1] != edh->dest) {
    while (nexthop == NULL && edh->apIndex < 29) {      //  path co toi da 30 phan tu
        edh->apIndex += 1;
        nexthop = getNeighborByGreedy(edh->path[edh->apIndex]);
    }

    if (nexthop == NULL) {
        nexthop = recvGPSR(p, edh->dest);
    }
    if (nexthop == NULL) {
        dumpDrop(iph->saddr(), 1);
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    } else {
        cmh->direction() = hdr_cmn::DOWN;
        cmh->addr_type() = NS_AF_INET;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = nexthop->id_;
        edh->hopCount++;
        send(p, 0);
        data_pkt_counter_++;
    }
}

void VR2Agent::recvVR2(Packet *p) {
    hdr_vr2_ha *bhh = HDR_VR2_HA(p);
    if (bhh->type_ == VR2_BOUNDHOLE) {
        recvBoundHole(p);
    } else if (bhh->type_ == VR2_HBA) {
        recvHBA(p);
    } else if (bhh->type_ == VR2_BROADCAST) {
        recvHCI(p);
    }
}

void VR2Agent::startUp() {
    findStuck_timer_.resched(65);

    FILE *fp;
    fp = fopen("Neighbors.tr", "w");
    fclose(fp);
    fp = fopen("BoundHole.tr", "w");
    fclose(fp);
    fp = fopen("CorePolygon.tr", "w");
    fclose(fp);
    fp = fopen("Debug.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastRegion.tr", "w");
    fclose(fp);
    fp = fopen("DynamicScaleHole.tr", "w");
    fclose(fp);
    fp = fopen("BroadcastEnergy.tr", "w");
    fclose(fp);
    fp = fopen("BigForbiddenArea.tr", "w");
    fclose(fp);
    fp = fopen("DebugBroadcast.tr", "w");
    fclose(fp);
    fp = fopen("HopCount.tr", "w");
    fclose(fp);
    fp = fopen("Drop.tr", "w");
    fclose(fp);
}

/*
 * Boundhole phase
 */
void VR2Agent::findStuckAngle() {
    if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL) {
        stuck_angle_ = NULL;
        return;
    }

//    printf("find stuck angle %d\n", this->my_id_);

    node *nb1 = neighbor_list_; //u
    node *nb2 = neighbor_list_->next_; //v

    while (nb2) {
        Circle circle = G::circumcenter(this, nb1, nb2);
        Angle a = G::angle(this, nb1, this, &circle); // upO
        Angle b = G::angle(this, nb1, this, nb2); // upv
        Angle c = G::angle(this, &circle, this, nb2); //Opv

        // if O is outside range of node, nb1 and nb2 create a stuck angle with node
        if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
            stuckangle *new_angle = new stuckangle();
            new_angle->a_ = nb1;
            new_angle->b_ = nb2;
            new_angle->next_ = stuck_angle_;
            stuck_angle_ = new_angle;
        }

        nb1 = nb1->next_;
        nb2 = nb1->next_;
    }

    nb2 = neighbor_list_;
    Circle circle = G::circumcenter(this, nb1, nb2);
    Angle a = G::angle(this, nb1, this, &circle);
    Angle b = G::angle(this, nb1, this, nb2);
    Angle c = G::angle(this, &circle, this, nb2);

    // if O is outside range of node, nb1 and nb2 create a stuck angle with node
    if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_)) {
        stuckangle *new_angle = new stuckangle();
        new_angle->a_ = nb1;
        new_angle->b_ = nb2;
        new_angle->next_ = stuck_angle_;
        stuck_angle_ = new_angle;
    }
}

void VR2Agent::sendBoundHole() {
    Packet *p;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_vr2_ha *bhh;

    for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
        p = allocpkt();

        VR2PacketData *bhpkt_data = new VR2PacketData();
        bhpkt_data->add(sa->b_->id_, sa->b_->x_, sa->b_->y_);
        bhpkt_data->add(my_id_, this->x_, this->y_);
        p->setdata(bhpkt_data);

        cmh = HDR_CMN(p);
        iph = HDR_IP(p);
        bhh = HDR_VR2_HA(p);

        cmh->ptype() = PT_VR2;
        cmh->direction() = hdr_cmn::DOWN;
        cmh->size() += IP_HDR_LEN + bhh->size() + bhpkt_data->data_len_;
        cmh->next_hop_ = sa->a_->id_;
        cmh->last_hop_ = my_id_;
        cmh->addr_type_ = NS_AF_INET;

        iph->saddr() = my_id_;
        iph->daddr() = sa->a_->id_;
        iph->sport() = RT_PORT;
        iph->dport() = RT_PORT;
        iph->ttl_ = limit_max_hop_;            // more than ttl_ hop => boundary => remove

        bhh->prev_ = *this;
        bhh->type_ = VR2_BOUNDHOLE;

        send(p, 0);
        boundhole_pkt_counter_++;
//        printf("send boundhole: %d\n", this->my_id_);
    }
}

void VR2Agent::recvBoundHole(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_cmn *cmh = HDR_CMN(p);
    struct hdr_vr2_ha *bhh = HDR_VR2_HA(p);

    VR2PacketData *data = (VR2PacketData *) p->userdata();

    // if the boundhole packet has came back to the initial node
    if (iph->saddr() == my_id_) {
//        printf("%d came back\n", this->my_id_);
        if (iph->ttl_ > (limit_max_hop_ - limit_min_hop_)) {
            drop(p, "SmallHole");
        } else {
            createHole(p);
            data->dump();
            // start sending HBA to hole boundary
            sendHBA(p);
        }
        return;
    }

    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    node n = data->get_data(1);
    if (n.id_ != iph->saddr()) {
        data->rmv_data(1);
    } else {
        // get the entry at index n-1
        n = data->get_data(data->size() - 1);
    }

    node *nb = getNeighborByBoundHole(&bhh->prev_, &n);

    // no neighbor to forward, drop message
    // it means the network is not interconnected
    if (nb == NULL) {
        drop(p, DROP_RTR_NO_ROUTE);
        return;
    }

    // drop message for loop way
    node temp, next;

    for (int i = 1; i < data->size(); i++) {
        temp = data->get_data(i);
        next = data->get_data(i + 1);

        if (G::is_intersect2(this, nb, temp, next)) {
            if (G::distance(temp, nb) < range_) {
                while (data->size() >= (i + 1)) {
                    data->rmv_data(i + 1);
                }

                data->add(nb->id_, nb->x_, nb->y_);
                nb = getNeighborByBoundHole(nb, &temp);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            } else {
                nb = getNeighbor(next.id_);
                if (nb == NULL) {
                    drop(p, DROP_RTR_NO_ROUTE);
                    return;
                }
                continue;
            }
        }
    }


    // if neighbor already send boundhole message to that node
    if (iph->saddr() > my_id_) {
        for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_) {
            if (sa->a_->id_ == nb->id_) {
                drop(p, "BOUNDHOLE_REPEAT");
                return;
            }
        }
    }

    data->add(my_id_, this->x_, this->y_);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = nb->id_;
    cmh->last_hop_ = my_id_;
    iph->daddr() = nb->id_;
    bhh->prev_ = *this;

    send(p, 0);
    boundhole_pkt_counter_++;
}

void VR2Agent::createHole(Packet *p) {
    VR2PacketData *data = (VR2PacketData *) p->userdata();

    BoundaryNode tmp = BoundaryNode();
    for (int i = 1; i <= data->size(); i++) {
        node n = data->get_data(i);
        tmp.x_ = n.x_;
        tmp.y_ = n.y_;
        tmp.id_ = n.id_;
        tmp.is_convex_hull_boundary_ = false;
        hole.node_vector_.push_back(tmp);
    }
    holes.push_back(hole);
}

node *VR2Agent::getNeighborByBoundHole(Point *p, Point *prev) {
    Angle max_angle = -1;
    node *nb = NULL;

    for (node *temp = neighbor_list_; temp; temp = temp->next_) {
        Angle a = G::angle(this, p, this, temp);
        if (a > max_angle && (!G::is_intersect(this, temp, p, prev) ||
                              (temp->x_ == p->x_ && temp->y_ == p->y_) ||
                              (this->x_ == prev->x_ && this->y_ == prev->y_))) {
            max_angle = a;
            nb = temp;
        }
    }

    return nb;
}

/*
 * HBA phase
 */
void VR2Agent::sendHBA(Packet *p) {
    VR2PacketData *data = (VR2PacketData *) p->userdata();
    hdr_cmn *cmh = HDR_CMN(p);
    hdr_ip *iph = HDR_IP(p);
    hdr_vr2_ha *bhh = HDR_VR2_HA(p);

    // update data payload - alloc memory for set of B(i) nodes
    data->add(my_id_, x_, y_); // add back H0 to end of array
    data->addHBA(n_, k_n_);
    // we need to call this function twice since there is a special case:
    // a node is belong to 2 edges of core polygon, i.e. this node is a vertex of core polygon
    isNodeStayOnBoundaryOfCorePolygon(p);
    isNodeStayOnBoundaryOfCorePolygon(p);

    node n = data->get_data(2);

    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = n.id_;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->ptype() = PT_VR2;
    cmh->num_forwards() = 0;
    cmh->size() += IP_HDR_LEN + bhh->size() + data->data_len_;

    iph->saddr() = my_id_;
    iph->daddr() = n.id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = IP_DEF_TTL;

    bhh->type_ = VR2_HBA;
    bhh->index_ = 2;

    send(p, 0);
    HBA_counter_++;

//    printf("%d send HBA\n", this->my_id_);
}

void VR2Agent::recvHBA(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    struct hdr_vr2_ha *bhh = HDR_VR2_HA(p);

    VR2PacketData *data = (VR2PacketData *) p->userdata();

//    createHole(p);

//    printf("%d recv HBA\n", this->my_id_);

    int i = bhh->index_;
    if (i < data->size() - (n_ + 1) * k_n_) {
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        nsaddr_t next_id = data->get_data(i + 1).id_;

        hdr_cmn *cmh = HDR_CMN(p);
        cmh->direction_ = hdr_cmn::DOWN;
        cmh->last_hop_ = my_id_;
        cmh->next_hop_ = next_id;

        iph->daddr() = next_id;
        bhh->index_++;

        send(p, 0);
        HBA_counter_++;
    } else { // back to H0
        isNodeStayOnBoundaryOfCorePolygon(p);
        isNodeStayOnBoundaryOfCorePolygon(p);
        constructCorePolygonSet(p);
        drop(p, "BOUNDHOLE_HBA");

        // broadcast HCI
        broadcastHCI();
    }
}

void VR2Agent::constructCorePolygonSet(Packet *p) {
    VR2PacketData *data = (VR2PacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    corePolygon *tmp_choose = new corePolygon();
    double area = DBL_MAX, tmp_area = 0;

    for (int i = 1; i <= k_n_; i++) {
        corePolygon *new_core = new corePolygon();
        new_core->id_ = i;

        for (int j = 1; j <= n_; j++) {
            int j_1 = j == n_ ? 1 : j + 1;

            off = data_size + (n_ + 1) * (i - 1) + j;
            node b_j = data->get_Bi_data(off);
            off = data_size + (n_ + 1) * (i - 1) + j_1;
            node b_j_1 = data->get_Bi_data(off);

            Angle b_j_angle = (i - 1) * theta_n + (j - 1) * 2 * M_PI / n_;
            Angle b_j_1_angle = (i - 1) * theta_n + (j_1 - 1) * 2 * M_PI / n_;

            Line l_i_j = G::line(b_j, b_j_angle);
            Line l_i_j_1 = G::line(b_j_1, b_j_1_angle);

            Point intersection;
            if (G::intersection(l_i_j, l_i_j_1, intersection)) {
                addCorePolygonNode(intersection, new_core);
            }
        }

        if (areaCorePolygon(new_core) < area) {
            tmp_choose = new_core;
            area = areaCorePolygon(new_core);
        }
    }
    tmp_choose->next_ = core_polygon_set;
    core_polygon_set = tmp_choose;
    dumpCorePolygon();
}

double VR2Agent::areaCorePolygon(corePolygon *tmp) {
    node *node_tmp = tmp->node_;
    Point array_tmp[n_];
    double sum = 0, sum_a = 0, sum_b = 0;
    for (int i = 0; i < n_; i++) {
        array_tmp[i] = *node_tmp;
        node_tmp = node_tmp->next_;
    }
    for (int i = 0; i < n_ - 1; i++) {
        sum_a = sum_a + array_tmp[i].x_ * array_tmp[i + 1].y_;
        sum_b = sum_b + array_tmp[i + 1].x_ * array_tmp[i].y_;
    }
    sum_a = sum_a + array_tmp[n_ - 1].x_ * array_tmp[0].y_;
    sum_b = sum_b + array_tmp[1].x_ * array_tmp[n_ - 1].y_;
    sum = (sum_a - sum_b) / 2;
    if (sum < 0) {
        sum = 0 - sum;
    }
    return sum;
}

void VR2Agent::addCorePolygonNode(Point newPoint, corePolygon *corePolygon) {
    node *newNode = new node();
    newNode->x_ = newPoint.x_;
    newNode->y_ = newPoint.y_;
    newNode->next_ = NULL;
    node *tmp = corePolygon->node_;
    while (tmp && tmp->next_) { tmp = tmp->next_; }
    if (tmp == NULL) corePolygon->node_ = newNode;
    else tmp->next_ = newNode;
}

// check if this node is on boundary of a core polygon
// if true then update the packet data payload for each (i,j) immediately
void VR2Agent::isNodeStayOnBoundaryOfCorePolygon(Packet *p) {
    VR2PacketData *data = (VR2PacketData *) p->userdata();
    int data_size = data->size() - (n_ + 1) * k_n_;
    int off = 0;

    int i;
    for (i = 1; i <= k_n_; i++) {
        bool first_time = false;
        // get next index of this B(i)

        off = data_size + (n_ + 1) * (i - 1);
        int next_index = data->get_next_index_of_Bi(off);

        if (next_index == 1) {
            next_index = n_ + 1;
        } else if (next_index == 0) {
            next_index = n_ + 1;
            first_time = true;
        }

        while (true) {
            next_index--;
            bool flag = false;
            double angle = (i - 1) * theta_n + (next_index - 1) * 2 * M_PI / n_;
            // draw line goes through this node and make with x-axis angle: mx + n = y
            Line l_n = G::line(this, angle);

            node tmp1, tmp2;
            int index;

            tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
            for (index = 1; index <= data_size; index++) {
                tmp2 = data->get_data(index);
                if (tmp2.id_ == my_id_) continue;
                if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                    flag = true;
                    break;
                }
            }

            if (next_index <= 0) break;
            if (flag && !first_time) break;
            if (flag) continue;

            first_time = false;
            // add N to set B(i, j)
            off = (i - 1) * (n_ + 1) + next_index + data_size;
            data->addBiNode(off, my_id_, x_, y_);
            off = data_size + (i - 1) * (n_ + 1);
            data->update_next_index_of_Bi(off, next_index);
            dump(angle, i, next_index, l_n);

            // check if next_index = 1 is valid
            if (next_index == n_) {
                flag = false;
                angle = (i - 1) * theta_n;
                // draw line goes through this node and make with x-axis angle: mx + n = y
                l_n = G::line(this, angle);

                tmp1 = data->get_data(1).id_ == my_id_ ? data->get_data(2) : data->get_data(1);
                for (index = 1; index <= data_size; index++) {
                    tmp2 = data->get_data(index);
                    if (tmp2.id_ == my_id_) continue;
                    if (G::position(&tmp1, &tmp2, &l_n) < 0) {
                        flag = true;
                        break;
                    }
                }

                if (!flag) {
                    // add N to set B(i, j) but dont update next_index
                    off = (i - 1) * (n_ + 1) + 1 + data_size;
                    data->addBiNode(off, my_id_, x_, y_);
                    dump(angle, i, 1, l_n);
                }
            }
        }
    }
}
/*
 * Broadcast phase
 */
// broadcast hole's & core polygons's information
void VR2Agent::broadcastHCI() {
    Packet *p = NULL;
    VR2PacketData *payload;
    hdr_cmn *cmh;
    hdr_ip *iph;
    hdr_vr2_ha *hdc;

    if (holes.empty() || core_polygon_set == NULL)
        return;

    p = allocpkt();
    payload = new VR2PacketData();

    // todo: kiem tra xem co can gui ca core_polygon_set va holes vao packet ko
    // add core polygon nodes of this node to broadcast packet
    corePolygon *my_self_core_ = core_polygon_set;
    for (node *node = my_self_core_->node_; node != NULL; node = node->next_) {
        payload->add(-1, node->x_, node->y_);
    }

    // add hole nodes of this node to broadcast packet
    for (int i = 0; i < hole.node_vector_.size(); i++) {
        payload->add(i, hole.node_vector_[i].x_, hole.node_vector_[i].y_);
    }

    p->setdata(payload);

    cmh = HDR_CMN(p);
    iph = HDR_IP(p);
    hdc = HDR_VR2_HA(p);

    cmh->ptype() = PT_VR2;
    cmh->direction() = hdr_cmn::DOWN;
    cmh->next_hop_ = IP_BROADCAST;
    cmh->last_hop_ = my_id_;
    cmh->addr_type_ = NS_AF_INET;
    cmh->size() += IP_HDR_LEN + hdc->size();

    iph->daddr() = IP_BROADCAST;
    iph->saddr() = my_id_;
    iph->sport() = RT_PORT;
    iph->dport() = RT_PORT;
    iph->ttl_ = 8 * IP_DEF_TTL;

    hdc->type_ = VR2_BROADCAST;

    dumpCorePolygon();

    send(p, 0);
    HCI_counter_ += 1;
}

void VR2Agent::recvHCI(Packet *p) {
    struct hdr_ip *iph = HDR_IP(p);
    hdr_cmn *cmh = HDR_CMN(p);

    if (iph->saddr() == my_id_) {
        drop(p, "VR2LoopHCI");
        return;
    }

    if (iph->ttl_-- <= 0) {
        drop(p, DROP_RTR_TTL);
        return;
    }

    // store corepolygons and holes
    corePolygon *diffCores = new corePolygon();
    bool has_corepolygon_ = true;
    HoleSt new_hole_ = storeCorePolygons(p, diffCores, has_corepolygon_);

    if (has_corepolygon_) {
        drop(p, "HCI_Received");
        return;
    }

    if (!new_hole_.node_vector_.empty()) {      // local - binded hole info
        std::vector<BoundaryNode> convex = determineConvexHull(new_hole_);
        if (hole.node_vector_.empty() && Geo::isPointInsidePolygon(*this, new_hole_.node_vector_))
            hole.node_vector_.insert(hole.node_vector_.end(), new_hole_.node_vector_.begin(),
                                     new_hole_.node_vector_.end());

        // check if node already has this hole's info
        bool flag = false;
        for (std::vector<HoleSt>::iterator it = holes.begin(); it != holes.end(); it++) {
            if (isSamePolygon(*it, new_hole_)) {
                flag = true;
                break;
            }
        }
        if (!flag) {
            holes.push_back(new_hole_);
        } else {
            drop(p, "Redundant");
            return;
        }

        if (!canBroadcast(0, diffCores)) {   // ko nam trong vung phat tan thong tin ho
            VR2PacketData *data = (VR2PacketData *) p->userdata();
            int k = data->size();
            for (int i = k; i > 8; i--)
                data->rmv_data(i);
        }
    }

    cmh->direction_ = hdr_cmn::DOWN;
    cmh->last_hop_ = my_id_;
    broadcast_timer_.setParameter(p);
    broadcast_timer_.resched(randSend_.uniform(0, 0.5));
    HCI_counter_++;

}

HoleSt VR2Agent::storeCorePolygons(Packet *p, corePolygon *diffCore, bool &has_corepolygon_) {
    VR2PacketData *data = (VR2PacketData *) p->userdata();
    int offset = 0;

    // check if we already have this cg
    for (int j = 0; j < n_; j++) {
        offset = j;
        node newPoint = data->get_Bi_data(offset);
        addCorePolygonNode(newPoint, diffCore);
    }

    has_corepolygon_ = false;
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        node *nn = cg->node_;
        bool flag = true;
        for (node *n = diffCore->node_; n; n = n->next_) {
            if (n->x_ != nn->x_ || n->y_ != nn->y_) {
                flag = false;
                break;
            }
            nn = nn->next_;
        }
        if (flag) {
            has_corepolygon_ = true;

//            diffCore = NULL;
            break;
        }
    }

    // store new cg
    if (!has_corepolygon_) {
        diffCore->next_ = core_polygon_set;
        core_polygon_set = diffCore;
        if (core_polygon_set != NULL) {
            if (core_polygon_set->next_ != NULL) {
                if (core_polygon_set->next_->next_ != NULL) {
                    dumpCorePolygon();
                }
            }
        }
    }

    // neu co thong tin ho thi luu thong tin ho vao
    HoleSt *new_hole_ = new HoleSt();
    if (data->size() > n_) {
        // store holes' info
        offset += 1;
        while (offset < data->size()) {
            node n = data->get_Bi_data(offset);
            BoundaryNode *np = new BoundaryNode();
            np->x_ = n.x_;
            np->y_ = n.y_;
            new_hole_->node_vector_.push_back(*np);
            offset++;
        }
    }

    return *new_hole_;
}

// check if distance from this node to polygon <
// max length edge of corepolygon + (1/2) * convex's perimeter
bool VR2Agent::canBroadcast(double a, corePolygon *cp) {
    CorePolygon cp_;
    for (node *n = cp->node_; n != NULL; n = n->next_) {
        Point tmp = Point(n->x_, n->y_);
        cp_.vertices.push_back(tmp);
    }
    double m_ = calculateM(cp_);
    if (distanceToPolygon(cp->node_) < m_ / (1 + epsilon_i_ - 1.0 / alpha_))
        return true;
    else
        return false;
}

double VR2Agent::calculateM(CorePolygon cp) {
    std::vector<BoundaryNode> core_vector_;

    for (int i = 0; i < cp.vertices.size(); i++) {
        BoundaryNode *tmp = new BoundaryNode();
        tmp->x_ = cp.vertices[i].x_;
        tmp->y_ = cp.vertices[i].y_;
        core_vector_.push_back(*tmp);
    }

    double m_ = Geo::polygonPerimeter(core_vector_) / 2.0;
    return m_;
}

double VR2Agent::distanceToPolygon(node *polygon) {
    node *tmp0;
    node *tmp1;
    node *tmp2;
    node *tmp3;
    Line l, l1, l2; // l: line P(i+1)P(i+2),l1: parallel with P(i)P(i+1), l2: parallel with P(i+2)P(i+3)

    // check if point inside polygon return maximum scale factor
    if (G::isPointInsidePolygon(this, polygon)) return 0;

    double distance;
    double d = DBL_MAX;
    int n = 8; // number of vertices of octagon = 8

    for (tmp0 = polygon; n; tmp0 = tmp0->next_, n--) {
        tmp1 = tmp0->next_ == NULL ? polygon : tmp0->next_;
        tmp2 = tmp1->next_ == NULL ? polygon : tmp1->next_;
        l = G::line(tmp1, tmp2);

        if (G::position(this, tmp0, &l) > 0) continue;

        distance = G::distance(this, l);
        if (distance < d) {
            // detect if node stays on covering polygon's boundary
            tmp3 = tmp2->next_ == NULL ? polygon : tmp2->next_;
            l1 = G::line(tmp0, tmp1);
            l2 = G::line(tmp2, tmp3);

            int pos1 = G::position(this, tmp2, &l1);
            int pos2 = G::position(this, tmp1, &l2);

            if (pos1 * pos2 >= 0 && pos1 >= 0) {
                d = distance;
            } else if (pos1 * pos2 >= 0 && pos1 < 0) {
                if (G::distance(this, l1) <= distance && G::distance(this, l2) <= distance)
                    d = distance;
            } else {
                if ((pos1 < 0 && G::distance(this, l1) <= distance)
                    || (pos2 < 0 && G::distance(this, l2) <= distance)) {
                    d = distance;
                }
            }
        }
    }

    return d;
}

std::vector<BoundaryNode> VR2Agent::determineConvexHull(HoleSt hole_) {
    std::stack<BoundaryNode *> hull;
    std::vector<BoundaryNode> convex;
    std::vector<BoundaryNode *> clone_hole;

    for (std::vector<BoundaryNode>::iterator it = hole_.node_vector_.begin(); it != hole_.node_vector_.end(); ++it) {
        clone_hole.push_back(&(*it));
    }

    std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
    BoundaryNode *pivot = clone_hole.front();
    std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
    hull.push(clone_hole[0]);
    hull.push(clone_hole[1]);
    hull.push(clone_hole[2]);

    for (int i = 3; i < clone_hole.size(); i++) {
        BoundaryNode *top = hull.top();
        hull.pop();
        while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
            top = hull.top();
            hull.pop();
        }
        hull.push(top);
        hull.push(clone_hole[i]);
    }

    while (!hull.empty()) {
        BoundaryNode *top = hull.top();
        top->is_convex_hull_boundary_ = true;
        convex.push_back(*top);
        hull.pop();
    }

    return convex;
}

bool VR2Agent::isSamePolygon(HoleSt p1, HoleSt p2) {
    bool flag = true;
    if (p1.node_vector_.size() != p2.node_vector_.size())
        return false;
    else {
        for (int i = 0; i < p1.node_vector_.size(); i++)
            if (p1.node_vector_[i].x_ != p2.node_vector_[i].x_ || p1.node_vector_[i].x_ != p2.node_vector_[i].x_) {
                flag = false;
                break;
            }
    }
    return flag;
}

void VR2Agent::findPath2(Packet *p) {
    struct hdr_vr2_data *edh = HDR_VR2_DATA(p);
    Point d = edh->dest;

    std::vector<Point> final_path_;
    double beta_, before_scale_path_len;
    CorePolygon source_core_;
    CorePolygon dest_core_;
    std::vector<Point> s_convex_gate_list_;
    s_convex_gate_list_.reserve(50);
    std::vector<std::vector<InsidePoint>> s_inside_stp_list_;
    s_inside_stp_list_.reserve(1000);
    std::vector<InsidePoint> s_inside_stp_final_;
    s_inside_stp_final_.reserve(100);
    std::vector<Point> s_core_gate_list_;
    s_core_gate_list_.reserve(20);

    std::vector<Point> d_convex_gate_list_;
    d_convex_gate_list_.reserve(50);
    std::vector<std::vector<InsidePoint>> d_inside_stp_list_;
    d_inside_stp_list_.reserve(1000);
    std::vector<InsidePoint> d_inside_stp_final_;
    d_inside_stp_final_.reserve(100);
    std::vector<Point> d_core_gate_list_;
    d_core_gate_list_.reserve(20);

    std::vector<AllPath> all_stp_list_;
    all_stp_list_.reserve(1000);
    std::vector<BasePathPoint> outside_stp_final_;
    outside_stp_final_.reserve(100);

    double shortest_len;
   // std::vector<std::vector<std::vector<Point>>> final_stp_list_;
   // final_stp_.reserve(1000);



// 1. chuyen core_polygon_set ve dang vector
    std::vector<CorePolygon> core_pols;
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        CorePolygon *cp = new CorePolygon();
        for (node *n = cg->node_; n != NULL; n = n->next_)
            cp->vertices.push_back(Point(n->x_, n->y_));
        core_pols.push_back(*cp);
    }

// 2. check xem dest hay source co nam trong core polygon nao khong

    std::vector<BoundaryNode> s_hole_, s_convex_, d_hole_, d_convex_;

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(*this, core_pols[i].vertices)) {
            source_core_ = core_pols[i];
            break;
        }
    }

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(d, core_pols[i].vertices)) {
            dest_core_ = core_pols[i];
            break;
        }
    }

    std::vector<std::vector<BoundaryNode>> convex_hull_set_;
    determineConvexHullSet(convex_hull_set_);
    for (int i = 0; i < convex_hull_set_.size(); i++) {
        if (Geo::isPointReallyInsidePolygon(d, convex_hull_set_[i])) {
            d_hole_ = holes[i].node_vector_;
            d_convex_ = convex_hull_set_[i];
        }

        if (Geo::isPointReallyInsidePolygon(*this, convex_hull_set_[i])) {
            s_hole_ = holes[i].node_vector_;
            s_convex_ = convex_hull_set_[i];
        }
    }

    // LE: tim inside path tai s
    if(!source_core_.vertices.empty()){ // s nam trong core poygon
        int s_gate_index_; // = rand() % 2;

        InsidePoint s;
        s.x_ = this->x_;
        s.y_ = this->y_;
        //   s.index_ = -1;
        std::vector<InsidePoint> inside_stp_1;
        std::vector<InsidePoint> inside_stp_2;


        std::vector<InsidePoint> s_cave_ = determineCaveContainingNode(*this, s_convex_, s_hole_);

        if (s_cave_.empty()) { // ddung ra phai xet truong hop neu s nam trong core polygon nhung khong nam trong convex hull,
            // nhng theo code thi s_cave = null laf khi s la 1 diem tren convex
            // se nhay vao day neu s la 1 diem tren convex --> cho nay phai tra ve s_inside_stp = s
            InsidePoint tmp;
            tmp.x_ = this->x_;
            tmp.y_ = this->y_;
            tmp.index_ = 0;
            inside_stp_1.push_back(tmp);
            s_inside_stp_list_.push_back(inside_stp_1);
            Point s_gate_point;
            s_gate_point.x_ = s.x_;
            s_gate_point.y_ = s.y_;
            s_convex_gate_list_.push_back(s_gate_point);
        } else {

            InsidePoint source;
            source.x_ = this->x_;
            source.y_ = this->y_;
            Point s_gate_point_1, s_gate_point_2;
            s_gate_point_1.x_ = s_cave_[0].x_;
            s_gate_point_1.y_ = s_cave_[0].y_;
            s_gate_point_2.x_ = s_cave_[s_cave_.size() - 1].x_;
            s_gate_point_2.y_ = s_cave_[s_cave_.size() - 1].y_;

            s_convex_gate_list_.push_back(s_gate_point_1);
            s_convex_gate_list_.push_back(s_gate_point_2);

            VR2IGraph *in_graph_1 = new VR2IGraph(s_cave_);
            inside_stp_1 = in_graph_1->shortestPath(source, s_cave_[0]); // gate point cua ho chua d


            VR2IGraph *in_graph_2 = new VR2IGraph(s_cave_);
            inside_stp_2 = in_graph_2->shortestPath(source, s_cave_[s_cave_.size() - 1]); // gate point cua ho chua d

            s_inside_stp_list_.push_back(inside_stp_1);
            s_inside_stp_list_.push_back(inside_stp_2);
            delete (in_graph_1);
            delete (in_graph_2);

         /*   double L1_ = Geo::pathLength(inside_stp_1);
            double L2_ = Geo::pathLength(inside_stp_2);

            if (L1_ < L2_) {
                inside_stp_.insert(inside_stp_.begin(), inside_stp_1.begin(), inside_stp_1.end());
                s_gate_index_ = 0;
            } else {
                inside_stp_.insert(inside_stp_.begin(), inside_stp_2.begin(), inside_stp_2.end());
                s_gate_index_ = s_cave_.size() - 1;
            }*/
        }

        for(int i= 0; i < s_convex_gate_list_.size(); i++){ // tim danh sach core vertices that closest to the s_gates
            double min_dis_ = DBL_MAX;
            int min_index_ = 0;
            for (int j = 0; j < source_core_.vertices.size(); j++) {
                double dis_ = G::distance(source_core_.vertices[j], s_convex_gate_list_[i]);
                if (dis_ < min_dis_) {
                    min_dis_ = dis_;
                    min_index_ = j;
                }
            }
            s_core_gate_list_.push_back(source_core_.vertices[min_index_]);
        }


       /* std::vector<std::vector<Point>> sub_inside_;
        sub_inside_.reserve(1000);
        devideInsidePath(inside_stp_, *this, d, sub_inside_);

        Point s_gate_ = Point(s_cave_[s_gate_index_].x_, s_cave_[s_gate_index_].y_);
        double min_dis_ = DBL_MAX;
        int min_index_ = 0;
        for (int i = 0; i < source_core_.vertices.size(); i++) {
            double dis_ = G::distance(source_core_.vertices[i], s_gate_);
            if (dis_ < min_dis_) {
                min_dis_ = dis_;
                min_index_ = i;
            }
        }*/
    }
    else{ // s khong nam trong core polygon
        // s_core_gate = s
        Point tmp;
        tmp.x_ = this->x_;
        tmp.y_ = this->y_;
        s_convex_gate_list_.push_back(tmp);
        s_core_gate_list_.push_back(tmp);

        InsidePoint tmp2;
        std::vector<InsidePoint> inside_stp_1;
        inside_stp_1.reserve(100);
        tmp2.x_ = this->x_;
        tmp2.y_ = this->y_;
        tmp2.index_ = 0;
        inside_stp_1.push_back(tmp2);
        s_inside_stp_list_.push_back(inside_stp_1);
    }

    //LE: tim inside path tai d
    if(!dest_core_.vertices.empty()){ // d nam trong core poygon
        if(edh->vr2_type_ == VR2_CBR_AWARE){ // s co thong tin cua ho: s la source node hoac sub-source node
            std::vector<InsidePoint> d_cave_ = determineCaveContainingNode(d, d_convex_, d_hole_);
            d_cave_.reserve(200);
            std::vector<InsidePoint> inside_stp_1;
            inside_stp_1.reserve(100);
            std::vector<InsidePoint> inside_stp_2;
            inside_stp_2.reserve(100);

            if (d_cave_.empty()) { // d la dinh cua d_convex
                InsidePoint tmp;
                tmp.x_ = d.x_;
                tmp.y_ = d.y_;
                tmp.index_ = 0;
                inside_stp_1.push_back(tmp);
                d_inside_stp_list_.push_back(inside_stp_1);
                Point d_gate_point;
                d_gate_point.x_ = d.x_;
                d_gate_point.y_ = d.y_;
                d_convex_gate_list_.push_back(d_gate_point);
            } else {
                InsidePoint dest;
                dest.x_ = d.x_;
                dest.y_ = d.y_;

                Point d_gate_point_1, d_gate_point_2;
                d_gate_point_1.x_ = d_cave_[0].x_;
                d_gate_point_1.y_ = d_cave_[0].y_;
                d_gate_point_2.x_ = d_cave_[d_cave_.size() - 1].x_;
                d_gate_point_2.y_ = d_cave_[d_cave_.size() - 1].y_;
                d_convex_gate_list_.push_back(d_gate_point_1);
                d_convex_gate_list_.push_back(d_gate_point_2);

                VR2IGraph *igraph1 = new VR2IGraph(d_cave_);
                inside_stp_1 = igraph1->shortestPath(d_cave_[0], dest);


                VR2IGraph *igraph2 = new VR2IGraph(d_cave_);
                inside_stp_2 = igraph2->shortestPath(d_cave_[d_cave_.size() - 1], dest);

                d_inside_stp_list_.push_back(inside_stp_1);
                d_inside_stp_list_.push_back(inside_stp_2);

                delete (igraph1);
                delete (igraph2);

                /*   double L1_ = Geo::pathLength(inside_stp_1);
                   double L2_ = Geo::pathLength(inside_stp_2);


                   if (L1_ < L2_) {
                       inside_stp_.insert(inside_stp_.end(), inside_stp_1.begin(), inside_stp_1.end());
                       L_G_ = L1_;
                       d_gate_index_ = 0;
                   } else {
                       inside_stp_.insert(inside_stp_.end(), inside_stp_2.begin(), inside_stp_2.end());
                       L_G_ = L2_;
                       d_gate_index_ = d_cave_.size() - 1;
                   }
                   d_gate_ = Point(d_cave_[d_gate_index_].x_, d_cave_[d_gate_index_].y_);*/
            }

            for(int i= 0; i < d_convex_gate_list_.size(); i++){ // tim danh sach core vertices that closest to the s_gates
                double min_dis_ = DBL_MAX;
                int min_index_ = 0;
                for (int j = 0; j < dest_core_.vertices.size(); j++) {
                    double dis_ = G::distance(dest_core_.vertices[j], d_convex_gate_list_[i]);
                    if (dis_ < min_dis_) {
                        min_dis_ = dis_;
                        min_index_ = j;
                    }
                }
                d_core_gate_list_.push_back(dest_core_.vertices[min_index_]);
            }
        }

        else{ // source node la blind node. this node phai la souce node, khong the la sub-source
            InsidePoint tmp;
            std::vector<InsidePoint> inside_stp_;
            inside_stp_.reserve(100);
            for (int i= 0; i < dest_core_.vertices.size(); i++){
                d_core_gate_list_.push_back(dest_core_.vertices[i]);
                d_core_gate_list_.push_back(dest_core_.vertices[i]);
                tmp.x_ = dest_core_.vertices[i].x_;
                tmp.y_ = dest_core_.vertices[i].y_;
                tmp.index_ = 0;
                inside_stp_.push_back(tmp);
                d_inside_stp_list_.push_back(inside_stp_);
            }
        }


/*
        std::vector<std::vector<Point>> sub_inside_;
        sub_inside_.reserve(1000);
        devideInsidePath(inside_stp_, *this, d, sub_inside_);

        // outside
        double min_dis_ = DBL_MAX;
        int min_index_ = 0;
        for (int i = 0; i < dest_core_.vertices.size(); i++) {
            double dis_ = G::distance(dest_core_.vertices[i], d_gate_);
            if (dis_ < min_dis_) {
                min_dis_ = dis_;
                min_index_ = i;
            }
        }
  */
    }
    else{ // d khong nam trong core polygon
        // d_core_gate = s
        Point tmp;
        tmp.x_ = dest->x_;
        tmp.y_ = dest->y_;
        d_convex_gate_list_.push_back(tmp);
        d_core_gate_list_.push_back(tmp);

        InsidePoint tmp2;
        std::vector<InsidePoint> inside_stp_;
        inside_stp_.reserve(100);
        tmp2.x_ = dest->x_;
        tmp2.y_ = dest->y_;
        tmp2.index_ = 0;
        inside_stp_.push_back(tmp2);
        d_inside_stp_list_.push_back(inside_stp_);

    }

    //LE: tim duong outside path

    shortest_len = DBL_MAX;

    for (int i = 0; i < s_core_gate_list_.size(); i++){
        for (int j = 0; j < d_core_gate_list_.size(); j++){
            std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s_core_gate_list_[i], d_core_gate_list_[j]); // obs co first item vaf last item la 2 diem dau cuoi
            std::vector<BasePathPoint> path;
            std::vector<std::vector<Point>> sub_path_; // list cac path sau khi chia nho
            if (obs.size() == 2) { // duong noi hai diem khong cat core polygon gon
                BasePathPoint tmp1;

                tmp1.x_ = this->x_;
                tmp1.y_ = this->y_;
                tmp1.hole_id_ = 0;
                path.push_back(tmp1);

                tmp1.x_ = d.x_;
                tmp1.y_ = d.y_;
                tmp1.hole_id_ = 1;
                path.push_back(tmp1);

             //   outside_stp_list_.push_back(outside_path);
            } else {
           //     OutsidePath outside_path;

                VR2OGraph graph = VR2OGraph(obs);
                std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_, n_);

                std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);
                int m;
                double prob = fwdProb_.uniform(0.0, 1.0);
                for (int i = 0; i < base_paths_.size(); i++) {
                    if (prob <= priority_indexes_[i]) {
                        m = i;
                        break;
                    }
                }
                path = base_paths_[m];
            }
            double len = 0;
            if(s_inside_stp_list_[i].size() > 1)
                len += Geo::pathLength(s_inside_stp_list_[i]);
            if(d_inside_stp_list_[j].size() > 1)
                len += Geo::pathLength(d_inside_stp_list_[j]);
            if(path.size() > 1)
                len += Geo::pathLength(path);
            len += G::distance(s_convex_gate_list_[i], s_core_gate_list_[i]) + G::distance(d_convex_gate_list_[j], d_core_gate_list_[j]);

            AllPath all_stp;
            all_stp.s_core_gate_index_ = i;
            all_stp.d_core_gate_index_ = j;
            all_stp.outside_path_ = path;
            all_stp.len = len;
            all_stp_list_.push_back(all_stp);

            if(len < shortest_len){
               shortest_len = len;
            }
        }
    }

    //LE: tim final_path
    // final path duoc chia thanh cac subpath; finalpath khong chua s va d
    std::vector<std::vector<Point>> s_devide_path_, d_devide_path_, outside_devide_path_;
    std::vector<std::vector<Point>> final_stp_, final_stp_tmp_;
    final_stp_.reserve(1000);
    final_stp_tmp_.reserve(1000);
    s_devide_path_.reserve(50);
    d_devide_path_.reserve(50);
    outside_devide_path_.reserve(50);

    for(int i = 0; i < all_stp_list_.size(); i++){
        if(all_stp_list_[i].len > shortest_len * (1.0 + epsilon_i_)){
            all_stp_list_.erase(all_stp_list_.begin() + i);
        }
    }
    // lay 1 path ngau nhien trong tap all_stp_list_
    srand(time(NULL));
    int index = rand()%(all_stp_list_.size());
    int s_index =  all_stp_list_[index].s_core_gate_index_;
    int d_index = all_stp_list_[index].d_core_gate_index_;

    double new_stretch = (1.0 + epsilon_i_) * shortest_len / all_stp_list_[index].len;

    s_inside_stp_final_ = s_inside_stp_list_[s_index];
    d_inside_stp_final_ = d_inside_stp_list_[d_index];
    outside_stp_final_ = all_stp_list_[index].outside_path_;

    if (G::distance(s_convex_gate_list_[s_index], s_core_gate_list_[s_index]) == 0){
        // gate cua convex va core trung nhau --> xoa diem nay de tranh lap lai 2 lan tren outside path va inside path
        s_inside_stp_final_.erase(s_inside_stp_final_.end()); // xoa diem cuoi cung cua inside path
    }
    if(G::distance(d_convex_gate_list_[d_index], d_core_gate_list_[d_index]) == 0){
        d_inside_stp_final_.erase(d_inside_stp_final_.begin());
    }

    //LE: tach stp thanh subpath va scale

    if(s_inside_stp_final_.size() > 0){ // s_inside_stp_final = s--> s_convex_gate;
        // s_inside_final_.size() = 0 if s khong nam trong ho
        // s_inside_final.size() = 1 neu s_convex_gate_ = s (tuc la s nam tren bien convex)
        devideInsidePath(s_inside_stp_final_, *this, d, s_devide_path_);
        final_stp_.insert(final_stp_.end(), s_devide_path_.begin(), s_devide_path_.end());
    }
    if(outside_stp_final_.size() > 0){
        devideOutsidePath(outside_stp_final_, *this, d, outside_devide_path_);
        final_stp_.insert(final_stp_.end(), outside_devide_path_.begin(), outside_devide_path_.end());
    }
    if(d_inside_stp_final_.size() > 0){
        devideInsidePath(d_inside_stp_final_, *this, d, d_devide_path_);
        final_stp_.insert(final_stp_.end(), d_devide_path_.begin(), d_devide_path_.end());
    }

    std::vector<Point> s_extra_, d_extra_;
    if(G::distance(final_stp_[0][0], *this) > (double)8.0 * range_ ) { // add extra point
        double gama_ = (double) 8.0 * range_ / G::distance(final_stp_[0][0], *this);
        Point s_extra_point;
        // neu diem dau tien cua s_inside_path cach s qua xa, thi lay them 1 anchor nam giua s va diem dau tien cua s_inside_path
        s_extra_point.x_ = gama_ * final_stp_[0][0].x_ + (1 - gama_) * this->x_;
        s_extra_point.y_ = gama_ * final_stp_[0][0].y_ + (1 - gama_) * this->y_;
        s_extra_.push_back(s_extra_point);
        final_stp_.insert(final_stp_.begin(), s_extra_); // add s_extra to final_stp
    }
    std::vector<Point> last_subpath = final_stp_[final_stp_.size()-1];
    if(G::distance(last_subpath[last_subpath.size()-1],d) > (double)8.0 * range_){
        double gama_ = (double)8.0 * range_ / G::distance(last_subpath[last_subpath.size()-1],d);
        Point  d_extra_point_;
        d_extra_point_.x_ = gama_ * last_subpath[last_subpath.size()-1].x_ + (1-gama_)*d.x_;
        d_extra_point_.y_ = gama_ * last_subpath[last_subpath.size()-1].y_ + (1-gama_)*d.y_;
        d_extra_.push_back(d_extra_point_);
        final_stp_.insert(final_stp_.end(), d_extra_); // add d_extra to final_stp
    }



    // LE: tim beta_
    if( dest_core_.vertices.empty() || (edh->vr2_type_ == VR2_CBR_AWARE && (this->my_id_ == edh->source_id_)) ){
        beta_ = new_stretch * alpha_;
    }
    else if (edh->vr2_type_ == VR2_CBR_BLIND){ // this node is a source node and it does not have hole information of d
        beta_ = new_stretch * alpha_ - Geo::polygonPerimeter(dest_core_) * alpha_ / (2 * before_scale_path_len);
        if (beta_ < 1) beta_ = 1;
    }
    else{
        double b_s_ = edh->B_s_t_;

        std::vector<Point> path_until_now_;
        path_until_now_.reserve(200);
        int q = 0;
        while (edh->path[q] != edh->path[edh->apIndex]) {
            path_until_now_.push_back(edh->path[q]); // path from s to the previous anchor
            q++;
        }
        double L_G_ = Geo::pathLength(d_inside_stp_final_);
        double L_t_ = Geo::pathLength(path_until_now_) + G::distance(edh->path[edh->apIndex], *this);
        double d_C_t = Geo::polygonMaxEdge(dest_core_);
        double B_t_ = before_scale_path_len;
        double beta1_ = (new_stretch * (alpha_ * b_s_ + L_G_ - d_C_t) - L_t_) / B_t_;
        double beta2_ = (new_stretch * (alpha_ * b_s_ - d_C_t / 2) - L_t_) / B_t_;

        beta_ = beta1_ < beta2_ ? beta2_ : beta1_;
        if (beta_ < 1) beta_ = 1;
    }
    if(beta_ > 1){
        srand(time(NULL));
        beta_ = (beta_ - 1.0) * ( (double)rand() / (double)RAND_MAX ) + 1.0;
    }

    final_path_ = scalePath(final_stp_, beta_, *this, d, holes, core_pols);


    for (int i = 0; i < final_path_.size(); i++)
        edh->path[i] = final_path_[i];

    return;

}

void VR2Agent::findPath(Packet *p) {
    struct hdr_vr2_data *edh = HDR_VR2_DATA(p);
    Point d = edh->dest;

    std::vector<Point> final_path_;

// 1. chuyen core_polygon_set ve dang vector
    std::vector<CorePolygon> core_pols;
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        CorePolygon *cp = new CorePolygon();
        for (node *n = cg->node_; n != NULL; n = n->next_)
            cp->vertices.push_back(Point(n->x_, n->y_));
        core_pols.push_back(*cp);
    }

// 2. check xem dest hay source co nam trong core polygon nao khong
    CorePolygon source_core_;
    CorePolygon dest_core_;

    std::vector<BoundaryNode> s_hole_, s_convex_, d_hole_, d_convex_;

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(*this, core_pols[i].vertices)) {
            source_core_ = core_pols[i];
            break;
        }
    }

    for (int i = 0; i < core_pols.size(); i++) {
        if (G::isPointInsidePolygon(d, core_pols[i].vertices)) {
            dest_core_ = core_pols[i];
            break;
        }
    }

    std::vector<std::vector<BoundaryNode>> convex_hull_set_;
    determineConvexHullSet(convex_hull_set_);
    for (int i = 0; i < convex_hull_set_.size(); i++) {
        if (Geo::isPointReallyInsidePolygon(d, convex_hull_set_[i])) {
            d_hole_ = holes[i].node_vector_;
            d_convex_ = convex_hull_set_[i];
        }

        if (Geo::isPointReallyInsidePolygon(*this, convex_hull_set_[i])) {
            s_hole_ = holes[i].node_vector_;
            s_convex_ = convex_hull_set_[i];
        }
    }

    double beta_;
// TH1: neu d nam ngoai hole
    if (dest_core_.vertices.empty()) {
        if (source_core_.vertices.empty())      // s nam ngoai hole
        {
            std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, *this, d);
            std::vector<BasePathPoint> chosed_path_;
            std::vector<std::vector<Point>> sub_path_;
            if (obs.size() == 2) {

                std::vector<Point> tmp;
                tmp.push_back(*this);
                tmp.push_back(d);
                sub_path_.push_back(tmp);

                BasePathPoint tmp1;
                tmp1.x_ = this->x_;
                tmp1.y_ = this->y_;
                tmp1.hole_id_ = 0;
                chosed_path_.push_back(tmp1);

                tmp1.x_ = d.x_;
                tmp1.y_ = d.y_;
                tmp1.hole_id_ = 1;
                chosed_path_.push_back(tmp1);
            } else {
                VR2OGraph graph = VR2OGraph(obs);
                std::vector<std::vector<BasePathPoint>> base_paths_ = graph.basePaths(epsilon_o_, n_);

                std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);
                int m;
                double prob = fwdProb_.uniform(0.0, 1.0);
                for (int i = 0; i < base_paths_.size(); i++) {
                    if (prob <= priority_indexes_[i]) {
                        m = i;
                        break;
                    }
                }
                chosed_path_ = base_paths_[m];

                // chia chosed_path_ thanh cac sub_path

                devideOutsidePath(chosed_path_, *this, d, sub_path_);
            }

            beta_ = (1 + epsilon_o_) * alpha_;

            final_path_ = scalePath(sub_path_, beta_, *this, d, holes, core_pols);

        } else {                          // s nam trong hole
            std::vector<InsidePoint> s_cave_ = determineCaveContainingNode(*this, s_convex_, s_hole_);

            srand(time(NULL));
            int s_gate_index_; // = rand() % 2;

            InsidePoint s;
            s.x_ = this->x_;
            s.y_ = this->y_;
            //   s.index_ = -1;
            std::vector<InsidePoint> inside_stp_;

            if (s_cave_.empty()) { // ddung ra phai xet truong hop neu s nam trong core polygon nhung khong nam trong convex hull,
                // nhng theo code thi s_cave = null laf khi s la 1 diem tren convex
                // se nhay vao day neu s la 1 diem tren convex --> cho nay phai tra ve s_inside_stp = s
                InsidePoint tmp;
                tmp.x_ = this->x_;
                tmp.y_ = this->y_;
                tmp.index_ = 0;
                inside_stp_.push_back(tmp);
            } else {

                InsidePoint source;
                source.x_ = this->x_;
                source.y_ = this->y_;

                VR2IGraph *in_graph_1 = new VR2IGraph(s_cave_);
                std::vector<InsidePoint> inside_stp_1 = in_graph_1->shortestPath(source,
                                                                                 s_cave_[0]); // gate point cua ho chua d


                VR2IGraph *in_graph_2 = new VR2IGraph(s_cave_);
                std::vector<InsidePoint> inside_stp_2 = in_graph_2->shortestPath(source, s_cave_[s_cave_.size() -
                                                                                                 1]); // gate point cua ho chua d

                delete (in_graph_1);
                delete (in_graph_2);

                double L1_ = Geo::pathLength(inside_stp_1);
                double L2_ = Geo::pathLength(inside_stp_2);

                if (L1_ < L2_) {
                    inside_stp_.insert(inside_stp_.begin(), inside_stp_1.begin(), inside_stp_1.end());
                    s_gate_index_ = 0;
                } else {
                    inside_stp_.insert(inside_stp_.begin(), inside_stp_2.begin(), inside_stp_2.end());
                    s_gate_index_ = s_cave_.size() - 1;
                }
            }

            std::vector<std::vector<Point>> sub_inside_;
            sub_inside_.reserve(1000);
            devideInsidePath(inside_stp_, *this, d, sub_inside_);

            Point s_gate_ = Point(s_cave_[s_gate_index_].x_, s_cave_[s_gate_index_].y_);
            double min_dis_ = DBL_MAX;
            int min_index_ = 0;
            for (int i = 0; i < source_core_.vertices.size(); i++) {
                double dis_ = G::distance(source_core_.vertices[i], s_gate_);
                if (dis_ < min_dis_) {
                    min_dis_ = dis_;
                    min_index_ = i;
                }
            }

            std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, source_core_.vertices[s_gate_index_], d);
            // STP: core_pols thay bang allcore polygon- s' core poly gon + s' convex hull
            // source_core_.vertices[s_gate_index_] thay bang s_gate_

            std::vector<BasePathPoint> chosed_path_;
            std::vector<std::vector<Point>> sub_outside_;
            sub_outside_.reserve(1000);
            if (obs.size() == 2) {
                //STP:thay source_core_.vertices[s_gate_index_] thay bang s_gate_
                // chu y: sub_outside se gom ca s_gate_ vi vay phai remove o final_stp
                std::vector<Point> tmp;
                tmp.push_back(source_core_.vertices[s_gate_index_]);
                sub_outside_.push_back(tmp);

                tmp.clear();
                tmp.push_back(d);
                sub_inside_.push_back(tmp);

                BasePathPoint tmp1;
                tmp1.x_ = source_core_.vertices[s_gate_index_].x_;
                tmp1.y_ = source_core_.vertices[s_gate_index_].y_;
                tmp1.hole_id_ = 0;
                chosed_path_.push_back(tmp1);

                tmp1.x_ = d.x_;
                tmp1.y_ = d.y_;
                tmp1.hole_id_ = 1;
                chosed_path_.push_back(tmp1);
            } else {


                VR2OGraph out_graph_ = VR2OGraph(obs);
                std::vector<std::vector<BasePathPoint>> base_paths_ = out_graph_.basePaths(epsilon_o_,
                                                                                           n_);   // base_paths_ bao gom ca shortest path

                std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

                // chon 1 duong bat ky dua vao priority index
                int m;
                double prob = fwdProb_.uniform(0.0, 1.0);
                for (int i = 0; i < base_paths_.size(); i++) {
                    if (prob <= priority_indexes_[i]) {
                        m = i;
                        break;
                    }
                }
                chosed_path_ = base_paths_[m];

                devideOutsidePath(chosed_path_, *this, d, sub_outside_);
            }

            // STP: s_gate_ se bi lap lai 2 lan trong final_stp_
            std::vector<std::vector<Point>> final_stp_;
            final_stp_.reserve(1000);
            final_stp_.insert(final_stp_.end(), sub_inside_.begin(), sub_inside_.end());
            final_stp_.insert(final_stp_.end(), sub_outside_.begin(), sub_outside_.end());

            beta_ = (1 + epsilon_o_) * alpha_;
            final_path_ = scalePath(final_stp_, beta_, *this, d, holes, core_pols);

        }

    } else {        // d nam trong ho
        if (source_core_.vertices.empty())      // s nam ngoai ho
        {
            if (edh->vr2_type_ == VR2_CBR_AWARE) {
                // inside
                std::vector<InsidePoint> d_cave_ = determineCaveContainingNode(d, d_convex_, d_hole_);
                std::vector<InsidePoint> inside_stp_;
                int d_gate_index_;
                Point d_gate_;
                double L_G_;

                if (d_cave_.empty()) {
                    InsidePoint tmp;
                    tmp.x_ = d.x_;
                    tmp.y_ = d.y_;
                    inside_stp_.push_back(tmp);
                    d_gate_ = d;
                    L_G_ = 0;
                } else {
                    InsidePoint dest;
                    dest.x_ = d.x_;
                    dest.y_ = d.y_;
                    //  dest.index_ = -1;

                    VR2IGraph *igraph1 = new VR2IGraph(d_cave_);
                    std::vector<InsidePoint> inside_stp_1 = igraph1->shortestPath(d_cave_[0], dest);


                    VR2IGraph *igraph2 = new VR2IGraph(d_cave_);
                    std::vector<InsidePoint> inside_stp_2 = igraph2->shortestPath(d_cave_[d_cave_.size() - 1], dest);

                    delete (igraph1);
                    delete (igraph2);

                    double L1_ = Geo::pathLength(inside_stp_1);
                    double L2_ = Geo::pathLength(inside_stp_2);


                    if (L1_ < L2_) {
                        inside_stp_.insert(inside_stp_.end(), inside_stp_1.begin(), inside_stp_1.end());
                        L_G_ = L1_;
                        d_gate_index_ = 0;
                    } else {
                        inside_stp_.insert(inside_stp_.end(), inside_stp_2.begin(), inside_stp_2.end());
                        L_G_ = L2_;
                        d_gate_index_ = d_cave_.size() - 1;
                    }
                    d_gate_ = Point(d_cave_[d_gate_index_].x_, d_cave_[d_gate_index_].y_);
                }

                std::vector<std::vector<Point>> sub_inside_;
                sub_inside_.reserve(1000);
                devideInsidePath(inside_stp_, *this, d, sub_inside_);

                // outside
                double min_dis_ = DBL_MAX;
                int min_index_ = 0;
                for (int i = 0; i < dest_core_.vertices.size(); i++) {
                    double dis_ = G::distance(dest_core_.vertices[i], d_gate_);
                    if (dis_ < min_dis_) {
                        min_dis_ = dis_;
                        min_index_ = i;
                    }
                }
                std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, *this, dest_core_.vertices[min_index_]);
                // STP: thay core_pols = tapcore polygons - core polygon chua t + convex hull chua t
                // thay dest_core_.vertices[min_index_] = d_gate_

                std::vector<BasePathPoint> chosed_path_;
                std::vector<std::vector<Point>> sub_outside_;
                sub_outside_.reserve(1000);
                if (obs.size() == 2) {
                    // STP: thay dest_core_.vertices[min_index_] = d_gate_
                    // chu y : d_gate_ se xuat hien 2 lan trong fnal_stp, vi vay can phai remove o final_stp

                    std::vector<Point> tmp;
                    tmp.push_back(dest_core_.vertices[min_index_]);
                    sub_outside_.push_back(tmp);

                    BasePathPoint tmp1;
                    tmp1.x_ = this->x_;
                    tmp1.y_ = this->y_;
                    tmp1.hole_id_ = 0;
                    chosed_path_.push_back(tmp1);

                    tmp1.x_ = dest_core_.vertices[min_index_].x_;
                    tmp1.y_ = dest_core_.vertices[min_index_].y_;
                    tmp1.hole_id_ = 1;
                    chosed_path_.push_back(tmp1);
                } else {
                    VR2OGraph out_graph_ = VR2OGraph(obs);
                    std::vector<std::vector<BasePathPoint>> base_paths_ = out_graph_.basePaths(epsilon_o_,
                                                                                               n_);   // base_paths_ bao gom ca shortest path

                    std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

                    // chon 1 duong bat ky dua vao priority index
                    int m;
                    double prob = fwdProb_.uniform(0.0, 1.0);
                    for (int i = 0; i < base_paths_.size(); i++) {
                        if (prob <= priority_indexes_[i]) {
                            m = i;
                            break;
                        }
                    }
                    chosed_path_ = base_paths_[m];
                    devideOutsidePath(chosed_path_, *this, d, sub_outside_);
                }
                std::vector<std::vector<Point>> final_stp_;
                final_stp_.reserve(1000);
                final_stp_.insert(final_stp_.end(), sub_outside_.begin(), sub_outside_.end());
                final_stp_.insert(final_stp_.end(), sub_inside_.begin(), sub_inside_.end());
                //STP: : d_gate_ se xuat hien 2 lan trong fnal_stp, vi vay can phai remove o final_stp


                if (this->my_id_ == edh->source_id_)            // source
                {
                    beta_ = (1 + epsilon_o_) * alpha_;
                } else                                            // sub-source
                {
                    double b_s_ = edh->B_s_t_;

                    std::vector<Point> path_until_now_;
                    int q = 0;
                    while (edh->path[q] != edh->path[edh->apIndex]) {
                        path_until_now_.push_back(edh->path[q]); // path from s to the previous anchor
                        q++;
                    }
                    /* while (edh->path[q] != edh->dest) {
                         path_until_now_.push_back(edh->path[q]);
                         q++;
                     }*/
                    double L_t_ = Geo::pathLength(path_until_now_) + G::distance(edh->path[edh->apIndex], *this);
                    double d_C_t = Geo::polygonMaxEdge(dest_core_);
                    double B_t_ = Geo::pathLength(inside_stp_) + Geo::pathLength(chosed_path_);
                    double beta1_ = ((1 + epsilon_o_) * (alpha_ * b_s_ + L_G_ - d_C_t) - L_t_) / B_t_;
                    double beta2_ = ((1 + epsilon_o_) * (alpha_ * b_s_ - d_C_t / 2) - L_t_) / B_t_;

                    beta_ = beta1_ < beta2_ ? beta2_ : beta1_;
                    if (beta_ < 1) beta_ = 1;
                }

                final_path_ = scalePath(final_stp_, beta_, *this, d, holes, core_pols);
            } else            // BLIND
            {
                srand(time(NULL));
//                int d_index_ = rand() % 8;

                // STP: thay core_pols = tap cac core polygon - core polygon chua s + convx hull chua s
                // chay 1 vong for qua tat ca dest_core_.vertices, tinh tinh shortest path tu s den tung dest_core_.vertices
                // d_index_d_index_ la dinh co shorets path den s nho nhat

                double STP_len_ = DBL_MAX;
                Point tt_;      // t' - sub-aware source node
                for (auto it : dest_core_.vertices) {
                    std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, *this, it);
                    double dis_;
                    if (obs.size() == 2) {
                        dis_ = G::distance(*this, it);
                    } else {
                        VR2OGraph out_graph_ = VR2OGraph(obs);
                        dis_ = out_graph_.shortestPathLength();
                    }
                    if (dis_ < STP_len_) {
                        STP_len_ = dis_;
                        tt_ = it;
                    }
                }

                std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, *this, tt_);
                std::vector<std::vector<Point>> sub_outside_;
                sub_outside_.reserve(1000);
                std::vector<BasePathPoint> chosed_path_;

                if (obs.size() == 2) {
                    std::vector<Point> tmp;
                    tmp.push_back(tt_);
                    sub_outside_.push_back(tmp);

                    BasePathPoint tmp1;
                    tmp1.x_ = this->x_;
                    tmp1.y_ = this->y_;
                    tmp1.hole_id_ = 0;
                    chosed_path_.push_back(tmp1);

                    tmp1.x_ = tt_.x_;
                    tmp1.y_ = tt_.y_;
                    tmp1.hole_id_ = 1;
                    chosed_path_.push_back(tmp1);
                } else {
                    VR2OGraph out_graph_ = VR2OGraph(obs); // dung do thi
                    std::vector<std::vector<BasePathPoint>> base_paths_ = out_graph_.basePaths(epsilon_o_,
                                                                                               n_);   // base_paths_ bao gom ca shortest path

                    std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

                    // chon 1 duong bat ky dua vao priority index
                    int m;
                    double prob = fwdProb_.uniform(0.0, 1.0);
                    for (int i = 0; i < base_paths_.size(); i++) {
                        if (prob <= priority_indexes_[i]) {
                            m = i;
                            break;
                        }
                    }
                    chosed_path_ = base_paths_[m];
                    devideOutsidePath(chosed_path_, *this, d, sub_outside_);
                }

                beta_ = (1 + epsilon_o_) * alpha_ - Geo::polygonPerimeter(dest_core_) * alpha_ /
                                                    (2 * Geo::pathLength(chosed_path_));
                if (beta_ < 1) beta_ = 1;

                final_path_ = scalePath(sub_outside_, beta_, *this, d, holes, core_pols);
            }
        } else                                    // s nam trong ho
        {
            // xac dinh duong di tu s ra gate point cua s
            std::vector<InsidePoint> s_cave_ = determineCaveContainingNode(*this, s_convex_, s_hole_);
            srand(time(NULL));
            // int s_gate_index_ = rand() % 2;
            std::vector<InsidePoint> s_inside_stp_;
            int s_gate_index_;
            Point s_gate_;

            if (s_cave_.empty()) { // ddung ra phai xet truong hop neu s nam trong core polygon nhung khong nam trong convex hull,
                // nhng theo code thi s_cave = null laf khi s la 1 diem tren convex
                // se nhay vao day neu s la 1 diem tren convex --> cho nay phai tra ve s_inside_stp = s
                InsidePoint tmp;
                tmp.x_ = this->x_;
                tmp.y_ = this->y_;
                tmp.index_ = 0;
                s_inside_stp_.push_back(tmp);
                s_gate_ = Point(this->x_, this->y_);
            } else {

                InsidePoint source;
                source.x_ = this->x_;
                source.y_ = this->y_;

                VR2IGraph *in_graph_1 = new VR2IGraph(s_cave_);
                std::vector<InsidePoint> inside_stp_1 = in_graph_1->shortestPath(source,
                                                                                 s_cave_[0]); // gate point cua ho chua d


                VR2IGraph *in_graph_2 = new VR2IGraph(s_cave_);
                std::vector<InsidePoint> inside_stp_2 = in_graph_2->shortestPath(source, s_cave_[s_cave_.size() -
                                                                                                 1]); // gate point cua ho chua d

                delete (in_graph_1);
                delete (in_graph_2);

                double L1_ = Geo::pathLength(inside_stp_1);
                double L2_ = Geo::pathLength(inside_stp_2);

                if (L1_ < L2_) {
                    s_inside_stp_.insert(s_inside_stp_.begin(), inside_stp_1.begin(), inside_stp_1.end());
                    s_gate_index_ = 0;
                } else {
                    s_inside_stp_.insert(s_inside_stp_.begin(), inside_stp_2.begin(), inside_stp_2.end());
                    s_gate_index_ = s_cave_.size() - 1;
                }
                s_gate_ = Point(s_cave_[s_gate_index_].x_, s_cave_[s_gate_index_].y_);
            }

            /*if (s_cave_.empty()) { // ddung ra phai xet truong hop neu s nam trong core polygon nhung khong nam trong convex hull,
                // nhng theo code thi s_cave = null laf khi s la 1 diem tren convex
                // se nhay vao day neu s la 1 diem tren convex --> cho nay phai tra ve s_inside_stp = s
                InsidePoint tmp;
                tmp.x_ = s_cave_[s_gate_index_].x_;
                tmp.y_ = s_cave_[s_gate_index_].y_;
                tmp.index_ = 0;
                s_inside_stp_.push_back(tmp);
            }
            else {

                InsidePoint s;
                s.x_ = this->x_;
                s.y_ = this->y_;
                s_inside_stp_ = in_graph_->shortestPath(s, s_cave_[s_gate_index_]);
            }*/
            std::vector<std::vector<Point>> s_sub_inside_;
            s_sub_inside_.reserve(1000);
            devideInsidePath(s_inside_stp_, *this, d, s_sub_inside_);

            //         Point s_gate_ = Point(s_cave_[s_gate_index_].x_, s_cave_[s_gate_index_].y_);
            double s_min_dis_ = DBL_MAX;
            int s_min_index_ = 0;
            for (int i = 0; i < source_core_.vertices.size(); i++) {
                double dis_ = G::distance(source_core_.vertices[i], s_gate_);
                if (dis_ < s_min_dis_) {
                    s_min_dis_ = dis_;
                    s_min_index_ = i;
                }
            }

            if (edh->vr2_type_ == VR2_CBR_AWARE) {
                std::vector<InsidePoint> d_cave_ = determineCaveContainingNode(d, d_convex_, d_hole_);
                std::vector<InsidePoint> d_inside_stp_;
                int d_gate_index_;
                Point d_gate_;
                double L_G_;

                if (d_cave_.empty()) {
                    InsidePoint tmp;
                    tmp.x_ = d.x_;
                    tmp.y_ = d.y_;
                    d_inside_stp_.push_back(tmp);
                    d_gate_ = d;
                    L_G_ = 0;
                } else {
                    InsidePoint dest;
                    dest.x_ = d.x_;
                    dest.y_ = d.y_;

                    VR2IGraph *igraph1 = new VR2IGraph(d_cave_);
                    std::vector<InsidePoint> inside_stp_1 = igraph1->shortestPath(d_cave_[0],
                                                                                 dest); // gate point cua ho chua d


                    VR2IGraph *igraph2 = new VR2IGraph(d_cave_);
                    std::vector<InsidePoint> inside_stp_2 = igraph2->shortestPath(d_cave_[d_cave_.size() - 1],
                                                                                 dest); // gate point cua ho chua d

                    delete(igraph1);
                    delete(igraph2);

                    double L1_ = Geo::pathLength(inside_stp_1);
                    double L2_ = Geo::pathLength(inside_stp_2);

                    if (L1_ < L2_) {
                        d_inside_stp_.insert(d_inside_stp_.end(), inside_stp_1.begin(), inside_stp_1.end());
                        L_G_ = L1_;
                        d_gate_index_ = 0;
                    } else {
                        d_inside_stp_.insert(d_inside_stp_.end(), inside_stp_2.begin(), inside_stp_2.end());
                        L_G_ = L2_;
                        d_gate_index_ = d_cave_.size() - 1;
                    }
                    d_gate_ = Point(d_cave_[d_gate_index_].x_, d_cave_[d_gate_index_].y_);
                }
                std::vector<std::vector<Point>> d_sub_inside_;
                d_sub_inside_.reserve(1000);
                devideInsidePath(d_inside_stp_, *this, d, d_sub_inside_);

                // outside
                double d_min_dis_ = DBL_MAX;
                int d_min_index_ = 0;
                for (int i = 0; i < dest_core_.vertices.size(); i++) {
                    double dis_ = G::distance(dest_core_.vertices[i], d_gate_);
                    if (dis_ < d_min_dis_) {
                        d_min_dis_ = dis_;
                        d_min_index_ = i;
                    }
                }
                std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, source_core_.vertices[s_min_index_],
                                                                  dest_core_.vertices[d_min_index_]);
                // STP: thay core polygons = tap tat ca cac core polgon - core polygon chua d - core polygon chua s  + convex hull chua d + convex hull chua s
                // STP: source_core_.vertices[s_min_index_]  bang s_gate_
                // STP: thay dest_core_.vertices[d_min_index_] bang d_gate_

                std::vector<BasePathPoint> chosed_path_;
                std::vector<std::vector<Point>> sub_outside_;
                sub_outside_.reserve(1000);
                if (obs.size() == 2) {
                    // STP: source_core_.vertices[s_min_index_]  bang s_gate_
                    // STP: thay dest_core_.vertices[d_min_index_] bang d_gate_

                    std::vector<Point> tmp;
                    tmp.push_back(source_core_.vertices[s_min_index_]);
                    sub_outside_.push_back(tmp);
                    tmp.clear();
                    tmp.push_back(dest_core_.vertices[d_min_index_]);
                    sub_outside_.push_back(tmp);

                    BasePathPoint tmp1;
                    tmp1.x_ = source_core_.vertices[s_min_index_].x_;
                    tmp1.y_ = source_core_.vertices[s_min_index_].y_;
                    tmp1.hole_id_ = 0;
                    chosed_path_.push_back(tmp1);

                    tmp1.x_ = dest_core_.vertices[d_min_index_].x_;
                    tmp1.y_ = dest_core_.vertices[d_min_index_].y_;
                    tmp1.hole_id_ = 1;
                    chosed_path_.push_back(tmp1);
                } else {
                    VR2OGraph out_graph_ = VR2OGraph(obs);
                    std::vector<std::vector<BasePathPoint>> base_paths_ = out_graph_.basePaths(epsilon_o_,
                                                                                               n_);   // base_paths_ bao gom ca shortest path

                    std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

                    // chon 1 duong bat ky dua vao priority index
                    int m;
                    double prob = fwdProb_.uniform(0.0, 1.0);
                    for (int i = 0; i < base_paths_.size(); i++) {
                        if (prob <= priority_indexes_[i]) {
                            m = i;
                            break;
                        }
                    }
                    chosed_path_ = base_paths_[m];
                    devideOutsidePath(chosed_path_, *this, d, sub_outside_);
                }

                if (this->my_id_ == edh->source_id_)            // source
                {
                    beta_ = (1 + epsilon_o_) * alpha_;
                } else                                            // sub-source
                {
                    double b_s_ = edh->B_s_t_;

                    std::vector<Point> path_until_now_; //path from s to the previous anchor
                    int q = 0;

                    while (edh->path[q] != edh->path[edh->apIndex]) {
                        path_until_now_.push_back(edh->path[q]);
                        q++;
                    }

                    /*  while (edh->path[q] != edh->dest) {
                          path_until_now_.push_back(edh->path[q]);
                          q++;
                      }*/
                    double L_t_ = Geo::pathLength(path_until_now_) + G::distance(edh->path[edh->apIndex], *this);
                    double d_C_t = Geo::polygonMaxEdge(dest_core_);
                    double B_t_ = Geo::pathLength(d_inside_stp_) + Geo::pathLength(chosed_path_) +
                                  Geo::pathLength(s_inside_stp_);

                    // estimate length of the shortest path

                    double beta1_ = ((1 + epsilon_o_) * (alpha_ * b_s_ + L_G_ - d_C_t) - L_t_) / B_t_;
                    double beta2_ = ((1 + epsilon_o_) * (alpha_ * b_s_ - d_C_t / 2) - L_t_) / B_t_;

                    beta_ = beta1_ < beta2_ ? beta2_ : beta1_;
                    if (beta_ < 1) beta_ = 1;
                }

                std::vector<std::vector<Point>> final_stp_;
                final_stp_.reserve(1000);
                std::vector<std::vector<Point>> s_devide_path_, d_devide_path_, outside_devide_path_;
                s_devide_path_.reserve(1000);
                d_devide_path_.reserve(1000);
                outside_devide_path_.reserve(1000);
                devideInsidePath(s_inside_stp_, *this, d, s_devide_path_);
                final_stp_.insert(final_stp_.end(), s_devide_path_.begin(), s_devide_path_.end());
                devideOutsidePath(chosed_path_, *this, d, outside_devide_path_);
                final_stp_.insert(final_stp_.end(), outside_devide_path_.begin(), outside_devide_path_.end());
                d_inside_stp_.erase(
                        d_inside_stp_.begin());         // xoa di 1 diem chung giua outside path va inside path (d-gate point)
                devideInsidePath(d_inside_stp_, *this, d, d_devide_path_);
                final_stp_.insert(final_stp_.end(), d_devide_path_.begin(), d_devide_path_.end());

                // STP: chu y; s_gate_ vaf d_gate_ se bi lap lai 2 lan trong final_sp --> can phai remove

                final_path_ = scalePath(final_stp_, beta_, *this, d, holes, core_pols);
            } else                // BLIND
            {
                srand(time(NULL));
                double STP_len_ = DBL_MAX;
                Point tt_;      // t' - sub-aware source node
                for (auto it : dest_core_.vertices) {
                    std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, *this, it);
                    double dis_;
                    if (obs.size() == 2) {
                        dis_ = G::distance(*this, it);
                    } else {
                        VR2OGraph out_graph_ = VR2OGraph(obs);
                        dis_ = out_graph_.shortestPathLength();
                    }
                    if (dis_ < STP_len_) {
                        STP_len_ = dis_;
                        tt_ = it;
                    }
                }
                std::vector<CorePolygon> obs = Geo::findObstacles(core_pols, s_gate_, tt_);
                std::vector<BasePathPoint> chosed_path_;
                std::vector<std::vector<Point>> sub_outside_;
                sub_outside_.reserve(1000);

                if (obs.size() == 2) {
                    std::vector<Point> tmp;
                    tmp.push_back(source_core_.vertices[s_min_index_]);
                    sub_outside_.push_back(tmp);
                    tmp.clear();
                    tmp.push_back(tt_);
                    sub_outside_.push_back(tmp);

                    BasePathPoint tmp1;
                    tmp1.x_ = source_core_.vertices[s_min_index_].x_;
                    tmp1.y_ = source_core_.vertices[s_min_index_].y_;
                    tmp1.hole_id_ = 0;
                    chosed_path_.push_back(tmp1);

                    tmp1.x_ = tt_.x_;
                    tmp1.y_ = tt_.y_;
                    tmp1.hole_id_ = 1;
                    chosed_path_.push_back(tmp1);
                } else {
                    VR2OGraph out_graph_ = VR2OGraph(obs); // dung do thi
                    std::vector<std::vector<BasePathPoint>> base_paths_ = out_graph_.basePaths(epsilon_o_,
                                                                                               n_);   // base_paths_ bao gom ca shortest path

                    std::vector<double> priority_indexes_ = findBasePathPriorityIndex(base_paths_);

                    // chon 1 duong bat ky dua vao priority index
                    int m;
                    double prob = fwdProb_.uniform(0.0, 1.0);
                    for (int i = 0; i < base_paths_.size(); i++) {
                        if (prob <= priority_indexes_[i]) {
                            m = i;
                            break;
                        }
                    }
                    chosed_path_ = base_paths_[m];
                    devideOutsidePath(chosed_path_, *this, d, sub_outside_);
                }

                beta_ = (1 + epsilon_o_) * alpha_ - Geo::polygonPerimeter(dest_core_) * alpha_ /
                                                    (2 * Geo::pathLength(chosed_path_));
                if (beta_ < 1) beta_ = 1;
                std::vector<std::vector<Point>> final_stp_;
                final_path_.reserve(1000);
                std::vector<std::vector<Point>> in_devide_path_, out_devide_path_;
                in_devide_path_.reserve(1000);
                out_devide_path_.reserve(1000);
                devideInsidePath(s_inside_stp_, *this, d, in_devide_path_);
                final_stp_.insert(final_stp_.end(), in_devide_path_.begin(), in_devide_path_.end());
                devideOutsidePath(chosed_path_, *this, d, out_devide_path_);
                final_stp_.insert(final_stp_.end(), out_devide_path_.begin(), out_devide_path_.end());

                final_path_ = scalePath(final_stp_, beta_, *this, d, holes, core_pols);
            }
        }
    }


    for (int i = 0; i < final_path_.size(); i++)
        edh->path[i] = final_path_[i];

    return;

}

void
VR2Agent::devideOutsidePath(std::vector<BasePathPoint> bp, Point s, Point t, std::vector<std::vector<Point>> &re_) {
    if ((fabs(bp[0].x_ - s.x_) < 0.00001 && fabs(bp[0].y_ - s.y_) < 0.00001) ||
        (fabs(bp[0].x_ - t.x_) < 0.00001 && fabs(bp[0].y_ - t.y_) < 0.00001))
        bp.erase(bp.begin());  // xoa s
    if ((fabs(bp[bp.size() - 1].x_ - s.x_) < 0.00001 && fabs(bp[bp.size() - 1].y_ - s.y_) < 0.00001) ||
        (fabs(bp[bp.size() - 1].x_ - t.x_) < 0.00001 && fabs(bp[bp.size() - 1].y_ - t.y_) < 0.00001))
        bp.pop_back();          // xoa d


    int k = 0;
    std::vector<Point> tmp;

    for (int i = 0; i < bp.size(); i++) {
        if (bp[i].hole_id_ == k) {
            tmp.push_back(bp[i]);
        } else {
            if (!tmp.empty()) {
                re_.push_back(tmp);
            }
            k += 1;
            tmp.clear();
            tmp.push_back(bp[i]);
        }
    }
    if (!tmp.empty())
        re_.push_back(tmp);   // push tmp cuoi cung

    return;
}

void
VR2Agent::devideInsidePath(std::vector<InsidePoint> bp, Point s, Point t, std::vector<std::vector<Point>> &re_) {
    if ((fabs(bp[0].x_ - s.x_) < 0.00001 && fabs(bp[0].y_ - s.y_) < 0.00001) ||
        (fabs(bp[0].x_ - t.x_) < 0.00001 && fabs(bp[0].y_ - t.y_) < 0.00001))
        bp.erase(bp.begin());  // xoa s
    if ((fabs(bp[bp.size() - 1].x_ - s.x_) < 0.00001 && fabs(bp[bp.size() - 1].y_ - s.y_) < 0.00001) ||
        (fabs(bp[bp.size() - 1].x_ - t.x_) < 0.00001 && fabs(bp[bp.size() - 1].y_ - t.y_) < 0.00001))
        bp.pop_back();          // xoa d

    if (bp.size() == 0)
        return;

    bool incr_ = true;

    if (bp[0].index_ < bp[1].index_)
        incr_ = true;
    else
        incr_ = false;

    std::vector<Point> tmp;

    tmp.push_back(bp[0]);
    for (int i = 0; i < bp.size() - 1; i++) {
        if (incr_) {
            if (bp[i].index_ < bp[i + 1].index_)
                tmp.push_back(bp[i + 1]);
            else {
                if (!tmp.empty())
                    re_.push_back(tmp);
                incr_ = false;
                tmp.clear();
            }
        }

        if (!incr_) {
            if (bp[i].index_ > bp[i + 1].index_)
                tmp.push_back(bp[i + 1]);
            else {
                if (!tmp.empty())
                    re_.push_back(tmp);
                incr_ = false;
                tmp.clear();
            }
        }
    }
    if (!tmp.empty())
        re_.push_back(tmp);
}
// scale 1 segment

std::vector<Point>
VR2Agent::scalePath(std::vector<std::vector<Point>> base_set_, double beta_, Point s, Point t,
                    std::vector<HoleSt> hole_list_, std::vector<CorePolygon> obs) {
    std::vector<SubPath> scale_path_;
    scale_path_.reserve(50);
    std::vector<Point> final_path_;
    final_path_.reserve(50);

    std::vector<Point> scale_center_;
    scale_center_.reserve(50);

    for (int i = 0; i < base_set_.size(); i++) {
        SubPath sub_path_;
        std::vector<Point> tmp = base_set_[i];

        Point I = Point(0, 0);
        double fr = 0;


        if (tmp.size() == 2) {
            Point tmp1 = tmp[0], tmp2 = tmp[tmp.size() - 1];
            for (int kp = 0; kp < hole_list_.size(); kp++) {
                if (Geo::isVertexOfPolygon(tmp1, hole_list_[kp].node_vector_)
                    || Geo::isVertexOfPolygon(tmp2, hole_list_[kp].node_vector_))   // neu doan nay la inside path
                {
                    Line l1 = G::line(tmp1, tmp2);
                    srand(time(NULL));
                    double r1 = rand() % 5;
                    srand(time(NULL));
                    double r2 = rand() % 5;
                    srand(time(NULL));
                    int r3 = rand() % 2;
                    double sign = 1;
                    if (r3 == 0) {
                        sign = -1;
                    }

                    double direction = 1;
                    if (positionSegHole(tmp1, tmp2, hole_list_[kp]) == 1) { // < 0 I nam cung phia voi ho
                        direction = -1;
                    }

                    srand(time(NULL));
                    double r4 = 50 + (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    double rand_c = direction * r4 * sqrt(l1.a_ * l1.a_ + l1.b_ * l1.b_);
                    double rand_x, rand_y;
                    if (fabs(l1.b_) > 0) {
                        srand(time(NULL));
                        rand_x = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                        rand_y = (rand_c - l1.a_ * rand_x) / l1.b_;
                    } else {
                        srand(time(NULL));
                        rand_y = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                        rand_x = (rand_c - l1.b_ * rand_y) / l1.a_;
                    }

                    I.x_ = (tmp1.x_ + tmp2.x_) / 2 + rand_x;
                    I.y_ = (tmp1.y_ + tmp2.y_) / 2 + rand_y;

                }
            }
        } else if (tmp.size() == 1 && base_set_.size() > 1) {
            bool is_extra_point = true;
            for (int kp = 0; kp < hole_list_.size(); kp++) {
                if (Geo::isVertexOfPolygon(tmp[0], hole_list_[kp].node_vector_)){
                    is_extra_point = false;
                    break;
                }
            }
            if(is_extra_point){
                for (int kp = 0; kp < obs.size(); kp++) {
                    if (Geo::isVertexOfPolygon(tmp[0], obs[kp].vertices)){
                        is_extra_point = false;
                        break;
                    }
                }
            }
            if(is_extra_point){ // extra points
                std::vector<std::vector<BoundaryNode>> convex_hull_set_;
                //convex_hull_set_.reserve(100);
                determineConvexHullSet(convex_hull_set_);
                bool is_stayinside_convex = false;
                Point tmp1, tmp2;
                if(i==0) { // s_extra
                    tmp1 = tmp[0];
                    tmp2 = s;
                    for (int i = 0; i < convex_hull_set_.size(); i++) {
                        if (Geo::isPointReallyInsidePolygon(tmp1, convex_hull_set_[i])) {
                            is_stayinside_convex = true;
                            break;
                        }
                    }
                }
                else if( i == base_set_.size()-1){
                    tmp1 = tmp[tmp.size()-1];
                    tmp2 = t;
                    for (int i = 0; i < convex_hull_set_.size(); i++) {
                        if (Geo::isPointReallyInsidePolygon(tmp1, convex_hull_set_[i])) {
                            is_stayinside_convex = true;
                            break;
                        }
                    }
                }

                int direction;
                Line l1 = G::line(tmp1, tmp2);
                srand(time(NULL));
                double r1 = rand() % 5;
                srand(time(NULL));
                double r2 = rand() % 5;
                srand(time(NULL));
                int r3 = rand() % 2;
                double sign = 1;
                if (r3 == 0) {
                    sign = -1;
                }

                int rand_dir = rand()%2;
                if(rand_dir == 0){
                    direction = 1;
                } else{
                    direction = -1;
                }

                srand(time(NULL));
                double r4, rand_x, rand_y, rand_c;
                if(is_stayinside_convex){
                    r4 = 10 + (range_) * ((double) rand() / (double) RAND_MAX);
                }
                else{
                    r4 = 50 + (2 * range_) * ((double) rand() / (double) RAND_MAX);
                }

                rand_c = direction * r4 * sqrt(l1.a_ * l1.a_ + l1.b_ * l1.b_);

                if (fabs(l1.b_) > 0) {
                    srand(time(NULL));
                    rand_x = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_y = (rand_c - l1.a_ * rand_x) / l1.b_;
                } else {
                    srand(time(NULL));
                    rand_y = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_x = (rand_c - l1.b_ * rand_y) / l1.a_;
                }

                I.x_ = (tmp1.x_ + tmp2.x_) / 2 + rand_x;
                I.y_ = (tmp1.y_ + tmp2.y_) / 2 + rand_y;

            }
            else{
                HoleSt this_hole_;
                Point tmp1, tmp2;
                for (int it = 0; it < hole_list_.size(); it++) {
                    std::vector<BoundaryNode> convex = determineConvexHull(hole_list_[it]);
                    if (Geo::isPointInsidePolygon(tmp[0], convex) && Geo::isPointInsidePolygon(s, convex)) {
                        this_hole_ = hole_list_[it];
                        if (i == 0) {
                            tmp1 = s;
                            tmp2 = tmp[0];
                        } else {
                            tmp1 = base_set_[i - 1][base_set_[i - 1].size() - 1];
                            tmp2 = tmp[0];
                        }
                    }

                    if (Geo::isPointInsidePolygon(tmp[0], convex) && Geo::isPointInsidePolygon(t, convex)) {
                        this_hole_ = hole_list_[it];
                        if (i == base_set_.size() - 1) {
                            tmp1 = tmp[0];
                            tmp2 = t;
                        } else {
                            tmp1 = tmp[0];
                            if (base_set_[i + 1].size() == 1)
                                tmp2 = base_set_[i + 1][0];
                            else
                                tmp2 = base_set_[i + 1][1];
                        }
                    }
                }

                Line l1 = G::line(tmp1, tmp2);
                srand(time(NULL));
                double r1 = rand() % 5;
                srand(time(NULL));
                double r2 = rand() % 5;
                srand(time(NULL));
                int r3 = rand() % 2;
                double sign = 1;
                if (r3 == 0) {
                    sign = -1;
                }

                double direction = 1;
                if (positionSegHole(tmp1, tmp2, this_hole_) == 1) { // < 0 I nam cung phia voi ho
                    direction = -1;
                }

                srand(time(NULL));
                double r4 = 50 + (2 * range_) * ((double) rand() / (double) RAND_MAX);
                double rand_c = direction * r4 * sqrt(l1.a_ * l1.a_ + l1.b_ * l1.b_);
                double rand_x, rand_y;
                if (fabs(l1.b_) > 0) {
                    srand(time(NULL));
                    rand_x = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_y = (rand_c - l1.a_ * rand_x) / l1.b_;
                } else {
                    srand(time(NULL));
                    rand_y = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_x = (rand_c - l1.b_ * rand_y) / l1.a_;
                }

                I.x_ = (tmp1.x_ + tmp2.x_) / 2 + rand_x;
                I.y_ = (tmp1.y_ + tmp2.y_) / 2 + rand_y;
            }




        } else {
            bool is_small_polygon = false;
            Point end_point_1, end_point_2, middle_point_;         // chinh la tmp[j], tmp[j+2] va tmp[j+1]
            for (int j = 0; j < tmp.size() - 2; j++) {
                if (fabs(G::abs_angle(tmp[j + 1], tmp[j], tmp[j + 1], tmp[j + 2])) < M_PI / (double) 9) {
                    is_small_polygon = true;
                    end_point_1 = tmp[j];
                    end_point_2 = tmp[j + 1];
                    middle_point_ = tmp[j + 2];
                    break;
                }
            }

            if (!is_small_polygon) {
                if (fabs(G::abs_angle(tmp[0], tmp[1], tmp[0], tmp[tmp.size() - 1])) < M_PI / (double) 9) {
                    is_small_polygon = true;
                    end_point_1 = tmp[0];
                    end_point_2 = tmp[1];
                    middle_point_ = tmp[tmp.size() - 1];
                } else if (fabs(G::abs_angle(tmp[tmp.size() - 1], tmp[0], tmp[tmp.size() - 1], tmp[tmp.size() - 2])) <
                           M_PI / (double) 9) {
                    is_small_polygon = true;
                    end_point_1 = tmp[0];
                    end_point_2 = tmp[tmp.size() - 1];
                    middle_point_ = tmp[tmp.size() - 2];
                }
            }
            if (is_small_polygon) {
                // do new  logic here
                Line l = G::line(tmp[0], tmp[tmp.size() - 1]);
                srand(time(NULL));
                double r1 = rand() % 5;
                srand(time(NULL));
                double r2 = rand() % 5;
                srand(time(NULL));
                int r3 = rand() % 2;
                double sign = 1;
                if (r3 == 0) {
                    sign = -1;
                }


                double direction = -1;
                if (l.a_ * tmp[1].x_ + l.b_ * tmp[1].y_ + l.c_ < 0) { // I nam nguoc phia voi tmp[1]
                    direction = 1;
                }

                srand(time(NULL));
                double r4 = 50 + (2 * range_) * ((double) rand() / (double) RAND_MAX);
                double rand_c = direction * r4 * sqrt(l.a_ * l.a_ + l.b_ * l.b_);
                double rand_x, rand_y;
                if (fabs(l.b_) > 0) {
                    srand(time(NULL));
                    rand_x = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_y = (rand_c - l.a_ * rand_x) / l.b_;
                } else {
                    srand(time(NULL));
                    rand_y = 30 + sign * (2 * range_) * ((double) rand() / (double) RAND_MAX);
                    rand_x = (rand_c - l.b_ * rand_y) / l.a_;
                }
                I.x_ = (tmp[0].x_ + tmp[tmp.size() - 1].x_) / 2 + rand_x;
                I.y_ = (tmp[0].y_ + tmp[tmp.size() - 1].y_) / 2 + rand_y;
            } else { // do old logic
                for (int j = 0; j < tmp.size(); j++) {
                    srand(time(NULL));
                    int ra = rand();
                    I.x_ += tmp[j].x_ * (double) ra;
                    I.y_ += tmp[j].y_ * (double) ra;
                    fr += ra;
                }
                I.x_ = I.x_ / fr;
                I.y_ = I.y_ / fr;
            }


        }

        for (int kp = 0; kp < obs.size(); kp++) {
            if (Geo::isVertexOfPolygon(tmp[0], obs[kp].vertices) &&
                Geo::isVertexOfPolygon(tmp[tmp.size() - 1], obs[kp].vertices)) {
                I = Point(0, 0);
                double fr = 0;

                for (int j = 0; j < obs[kp].vertices.size(); j++) {
                    srand(time(NULL));
                    int ra = rand();
                    I.x_ += obs[kp].vertices[j].x_ * (double) ra;
                    I.y_ += obs[kp].vertices[j].y_ * (double) ra;
                    /* I.x_ += tmp[j].x_ * (double)ra;
                     I.y_ += tmp[j].y_ * (double)ra;*/
                    fr += ra;
                }
                I.x_ = I.x_ / fr;
                I.y_ = I.y_ / fr;
            }
        }

        scale_center_.push_back(I);
        /*
        sub_path_.scale_center_ = I;

        double a_i_ = Geo::pathLength(tmp);
        double b_i_ = G::distance(I, tmp[0]) + G::distance(I, tmp[tmp.size() - 1]);
        if (tmp.size() == 1) b_i_ = b_i_ / 2;



        double c_i_;
        // calculate c_i_
        if (base_set_.size() == 1) {
            c_i_ = G::distance(s, tmp[0]) + G::distance(tmp[tmp.size() - 1], t);
        } else if (i == 0) {
            Point prev_ = tmp[tmp.size() - 1];
            Point next_ = base_set_[i + 1][0];
            c_i_ = G::distance(s, tmp[0]) + ((double) 1.0 / (double) 2.0) * G::distance(prev_, next_);
        } else if (i == base_set_.size() - 1) {
            Point prev_ = base_set_[i - 1][base_set_[i - 1].size() - 1];
            Point next_ = tmp[0];
            c_i_ = G::distance(t, tmp[tmp.size() - 1]) + ((double) 1.0 / (double) 2.0) * G::distance(prev_, next_);
        } else {
            Point prev = base_set_[i - 1][base_set_[i - 1].size() - 1];
            Point curr1 = tmp[0];
            Point curr2 = tmp[tmp.size() - 1];
            Point next = base_set_[i + 1][0];
            c_i_ = ((double) 1.0 / (double) 2.0) * (G::distance(prev, curr1) + G::distance(curr2, next));
        }

        double scale_ratio_ = 1 + (beta_ * c_i_ + (beta_ - 1) * a_i_) / (a_i_ + b_i_);

        sub_path_.scale_ratio_ = scale_ratio_;

        for (int j = 0; j < tmp.size(); j++) {
            tmp[j].x_ = tmp[j].x_ * scale_ratio_ + I.x_ * (1 - scale_ratio_);
            tmp[j].y_ = tmp[j].y_ * scale_ratio_ + I.y_ * (1 - scale_ratio_);
            sub_path_.sub_path_.push_back(tmp[j]);
        }

        scale_path_.push_back(sub_path_); */

    }

    double total_c = 0;
    double total_a = 0;
    double total_b = 0;
    double common_ratio;
    total_c += G::distance(base_set_[0][0], s);
    for (int i = 0; i < base_set_.size()-1; i++){
        total_c += G::distance(base_set_[i][base_set_[i].size()-1], base_set_[i+1][0]);
    }
    std::vector<Point> last_base_set;
    last_base_set = base_set_[base_set_.size()-1];

    total_c += G::distance(last_base_set[last_base_set.size()-1],t);

    for(int i = 0; i < base_set_.size(); i++) {
        SubPath sub_path_;
        std::vector<Point> tmp = base_set_[i];
        Point I = scale_center_[i];
        double a_i_ = Geo::pathLength(tmp);
        double b_i_ = G::distance(I, tmp[0]) + G::distance(I, tmp[tmp.size() - 1]);
        if (tmp.size() == 1) b_i_ = b_i_ / 2;
        total_a += a_i_;
        total_b += b_i_;
    }

    common_ratio = 1 + (beta_ - 1) * (total_a + total_c)/(total_a + total_b);

    for(int i = 0; i < base_set_.size(); i++){
        SubPath sub_path_;
        std::vector<Point> tmp = base_set_[i];

        double scale_ratio_ = common_ratio;

        sub_path_.scale_ratio_ = scale_ratio_;
        sub_path_.scale_center_ = scale_center_[i];

        Point I = sub_path_.scale_center_;

        for (int j = 0; j < tmp.size(); j++) {
            tmp[j].x_ = tmp[j].x_ * scale_ratio_ + I.x_ * (1 - scale_ratio_);
            tmp[j].y_ = tmp[j].y_ * scale_ratio_ + I.y_ * (1 - scale_ratio_);
            sub_path_.sub_path_.push_back(tmp[j]);
        }
        scale_path_.push_back(sub_path_);
    }

    /*std::vector<double> prio;
    double total_prio = 0;
    for(int i = 0; i<base_set_.size(); i++) {
        SubPath sub_path_;
        std::vector<Point> tmp = base_set_[i];
        Point I = scale_path_[i].scale_center_;
        double a_i_ = Geo::pathLength(tmp);
        double b_i_ = G::distance(I, tmp[0]) + G::distance(I, tmp[tmp.size() - 1]);
        if (tmp.size() == 1) b_i_ = b_i_ / 2;
        prio.push_back((a_i_ + b_i_)/a_i_);
        total_prio += (a_i_ + b_i_)/a_i_;
    }
    for(int i = 0; i<base_set_.size(); i++){
        SubPath sub_path_;
        std::vector<Point> tmp = base_set_[i];
        Point I = scale_path_[i].scale_center_;
        double a_i_ = Geo::pathLength(tmp);
        double b_i_ = G::distance(I, tmp[0]) + G::distance(I, tmp[tmp.size() - 1]);
        if (tmp.size() == 1) b_i_ = b_i_ / 2;

        double c_i_ = prio[i]*total_c;
        // calculate c_i_

        double scale_ratio_ = 1 + (beta_ * c_i_ + (beta_ - 1) * a_i_) / (a_i_ + b_i_);

        sub_path_.scale_ratio_ = scale_ratio_;

        for (int j = 0; j < tmp.size(); j++) {
            tmp[j].x_ = tmp[j].x_ * scale_ratio_ + I.x_ * (1 - scale_ratio_);
            tmp[j].y_ = tmp[j].y_ * scale_ratio_ + I.y_ * (1 - scale_ratio_);
            sub_path_.sub_path_.push_back(tmp[j]);
        }
        scale_path_.push_back(sub_path_);
    }*/

    // giam 1/4
    if (scale_path_.size() > 1) {

        for (int i = 0; i < scale_path_.size(); i++) { // dieu chinh cac sub_path vuot khoi mang
            for (int j = 0; j < scale_path_[i].sub_path_.size(); j++) {
                Point tmp1 = scale_path_[i].sub_path_[j];
                while (tmp1.x_ >= 1500 || tmp1.y_ >= 1500 || tmp1.x_ <= 1 || tmp1.y_ <= 1) {
                    scale_path_[i].sub_path_.clear();
                    srand(time(NULL));
                    int ra = rand() % 3;
                    double reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
                    double ratio_1_ = reduce_ratio * scale_path_[i].scale_ratio_;
                    if (ratio_1_ < 1) ratio_1_ = 1;
                    scale_path_[i].scale_ratio_ = ratio_1_;

                    std::vector<Point> ori1 = base_set_[i];

                    Point I1 = scale_path_[i].scale_center_;
                    scale_path_[i].scale_center_ = I1;

                    for (int j = 0; j < ori1.size(); j++) {
                        ori1[j].x_ = ori1[j].x_ * ratio_1_ + I1.x_ * (1 - ratio_1_);
                        ori1[j].y_ = ori1[j].y_ * ratio_1_ + I1.y_ * (1 - ratio_1_);
                        scale_path_[i].sub_path_.push_back(ori1[j]);
                    }
                    tmp1 = scale_path_[i].sub_path_[j];
                    if (ratio_1_ == 1)
                        break;
                }
            }
        }

        std::vector<Point> fisrt_subpath = scale_path_[0].sub_path_;
        while (segmentCutHoleOrCore(fisrt_subpath[0], s, hole_list_)) { // reduce if path connecting the first scaled andchor and s interset hole
            scale_path_[0].sub_path_.clear();

            srand(time(NULL));
            int ra = rand() % 3;
            double reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
            double ratio_1_ = reduce_ratio * scale_path_[0].scale_ratio_;
            if (ratio_1_ < 1) ratio_1_ = 1;
            scale_path_[0].scale_ratio_ = ratio_1_;


            std::vector<Point> ori1 = base_set_[0];

            Point I1 = scale_path_[0].scale_center_;
            scale_path_[0].scale_center_ = I1;


            for (int j = 0; j < ori1.size(); j++) {
                ori1[j].x_ = ori1[j].x_ * ratio_1_ + I1.x_ * (1 - ratio_1_);
                ori1[j].y_ = ori1[j].y_ * ratio_1_ + I1.y_ * (1 - ratio_1_);
                scale_path_[0].sub_path_.push_back(ori1[j]);
            }


            fisrt_subpath = scale_path_[0].sub_path_;

            if (ratio_1_ == 1 )
                break;
        }

        std::vector<Point> last_subpath = scale_path_[scale_path_.size()-1].sub_path_;
        while (segmentCutHoleOrCore(last_subpath[last_subpath.size()-1], t, hole_list_)) { // reduce if path connecting the last scaled andchor and t interset hole
            scale_path_[scale_path_.size()-1].sub_path_.clear();

            srand(time(NULL));
            int ra = rand() % 3;
            double reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
            double ratio_1_ = reduce_ratio * scale_path_[scale_path_.size()-1].scale_ratio_;
            if (ratio_1_ < 1) ratio_1_ = 1;
            scale_path_[scale_path_.size()-1].scale_ratio_ = ratio_1_;


            std::vector<Point> ori1 = base_set_[base_set_.size()-1];

            Point I1 = scale_path_[scale_path_.size()-1].scale_center_;
            scale_path_[scale_path_.size()-1].scale_center_ = I1;


            for (int j = 0; j < ori1.size(); j++) {
                ori1[j].x_ = ori1[j].x_ * ratio_1_ + I1.x_ * (1 - ratio_1_);
                ori1[j].y_ = ori1[j].y_ * ratio_1_ + I1.y_ * (1 - ratio_1_);
                scale_path_[scale_path_.size()-1].sub_path_.push_back(ori1[j]);
            }


            last_subpath = scale_path_[scale_path_.size()-1].sub_path_;

            if (ratio_1_ == 1 )
                break;
        }


        for (int i = 0; i < scale_path_.size() - 1; i++) { // check ddan noi giua 2 subpath
            std::vector<Point> tmp1 = scale_path_[i].sub_path_;
            std::vector<Point> tmp2 = scale_path_[i + 1].sub_path_;

            while (segmentCutHoleOrCore(tmp1[tmp1.size() - 1], tmp2[0], hole_list_)) {
                scale_path_[i].sub_path_.clear();
                scale_path_[i + 1].sub_path_.clear();
                srand(time(NULL));
                int ra = rand() % 3;
                double reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
                double ratio_1_ = reduce_ratio * scale_path_[i].scale_ratio_;
                if (ratio_1_ < 1) ratio_1_ = 1;
                scale_path_[i].scale_ratio_ = ratio_1_;
                srand(time(NULL));
                ra = rand() % 3;
                reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
                double ratio_2_ = reduce_ratio * scale_path_[i + 1].scale_ratio_;
                if (ratio_2_ < 1) ratio_2_ = 1;
                scale_path_[i + 1].scale_ratio_ = ratio_2_;

                std::vector<Point> ori1 = base_set_[i];
                std::vector<Point> ori2 = base_set_[i + 1];

                Point I1 = scale_path_[i].scale_center_;
                scale_path_[i].scale_center_ = I1;
                Point I2 = scale_path_[i + 1].scale_center_;
                scale_path_[i + 1].scale_center_ = I2;

                for (int j = 0; j < ori1.size(); j++) {
                    ori1[j].x_ = ori1[j].x_ * ratio_1_ + I1.x_ * (1 - ratio_1_);
                    ori1[j].y_ = ori1[j].y_ * ratio_1_ + I1.y_ * (1 - ratio_1_);
                    scale_path_[i].sub_path_.push_back(ori1[j]);
                }

                for (int j = 0; j < ori2.size(); j++) {
                    ori2[j].x_ = ori2[j].x_ * ratio_2_ + I2.x_ * (1 - ratio_2_);
                    ori2[j].y_ = ori2[j].y_ * ratio_2_ + I2.y_ * (1 - ratio_2_);
                    scale_path_[i + 1].sub_path_.push_back(ori2[j]);
                }
                tmp1 = scale_path_[i].sub_path_;
                tmp2 = scale_path_[i + 1].sub_path_;
                if (ratio_1_ == 1 && ratio_2_ == 1)
                    break;
            }
        }

        for (int i = 0; i < scale_path_.size(); i++) { // check cac doan trong cung 1 sub path
            for (int j = 0; j < scale_path_[i].sub_path_.size() - 1; j++) {

                Point tmp1 = scale_path_[i].sub_path_[j];
                Point tmp2 = scale_path_[i].sub_path_[j + 1];
                while (segmentCutHoleOrCore(tmp1, tmp2, hole_list_)) {
                    scale_path_[i].sub_path_.clear();
                    srand(time(NULL));
                    int ra = rand() % 3;
                    double reduce_ratio = ((double) ra + (double) 6.0) / (double) 9.0;
                    double ratio_1_ = reduce_ratio * scale_path_[i].scale_ratio_;
                    if (ratio_1_ < 1) ratio_1_ = 1;
                    scale_path_[i].scale_ratio_ = ratio_1_;

                    std::vector<Point> ori1 = base_set_[i];

                    Point I1 = scale_path_[i].scale_center_;
                    scale_path_[i].scale_center_ = I1;

                    for (int j = 0; j < ori1.size(); j++) {
                        ori1[j].x_ = ori1[j].x_ * ratio_1_ + I1.x_ * (1 - ratio_1_);
                        ori1[j].y_ = ori1[j].y_ * ratio_1_ + I1.y_ * (1 - ratio_1_);
                        scale_path_[i].sub_path_.push_back(ori1[j]);
                    }
                    tmp1 = scale_path_[i].sub_path_[j];
                    tmp2 = scale_path_[i].sub_path_[j + 1];
                    if (ratio_1_ == 1)
                        break;
                }
            }
        }

    }

    // add vao final path
    for (int i = 0; i < scale_path_.size(); i++) {
        for (int j = 0; j < scale_path_[i].sub_path_.size(); j++)
            final_path_.push_back(scale_path_[i].sub_path_[j]);
    }

    return final_path_;
}

int VR2Agent::positionSegHole(Point p1, Point p2, HoleSt hole) {
    Point check_point_;
    for (int i = 0; i < hole.node_vector_.size(); i++) {
        if ( (fabs(hole.node_vector_[i].x_ - p1.x_)< 0.00001) && (fabs(hole.node_vector_[i].y_ - p1.y_)< 0.00001))
            check_point_ = hole.node_vector_[(i + 1) % (hole.node_vector_.size()-1)];
    }
    Line l1 = G::line(p1, p2);

    if (l1.a_ * check_point_.x_ + l1.b_ * check_point_.y_ + l1.c_ < 0)
        return 1;
    else
        return 2;
}


bool
VR2Agent::segmentCutHoleOrCore(Point s, Point t, std::vector<HoleSt> hole_list_) {
    for (int i = 0; i < hole_list_.size(); i++) {
        if (Geo::segmentPolygonIntersect(s, t, hole_list_[i].node_vector_))
            return true;
    }

    return false;
}

std::vector<InsidePoint>
VR2Agent::determineCaveContainingNode(Point s, std::vector<BoundaryNode> convex, std::vector<BoundaryNode> hole) {

    if (hole.empty())
        return std::vector<InsidePoint>();


    for (int k = 0; k < hole.size(); k++) {
        hole[k].is_convex_hull_boundary_ = false;
    }

    // todo: neu minh dung con tro cho xac dinh convex, thi ko can lam buoc nay

    for (int k = 0; k < hole.size(); k++) {
        for (int i = 0; i < convex.size(); i++) {
            if (fabs(hole[k].x_ - convex[i].x_) < 0.0001 && fabs(hole[k].y_ - convex[i].y_) < 0.0001) {
                hole[k].is_convex_hull_boundary_ = true;
                break;
            }

        }
    }

    /* for (int i = 0; i < convex.size(); i++) {
         for (int k = 0; k < hole.size(); k++) {
             if (hole[k].x_ == convex[i].x_ && hole[k].y_ == convex[i].y_)
                 hole[k].is_convex_hull_boundary_ = true;

         }
     }*/

    // rotate hole list, i.e. the first element is convex hull boundary
    int j = 0;
    while (!hole[j].is_convex_hull_boundary_)
        j++;
    rotate(hole.begin(), hole.begin() + j, hole.end());

    // determine cave containing s
    std::vector<InsidePoint> cave;
    for (unsigned int i = 0; i < hole.size() - 1; i++) {
        if (hole.at(i).is_convex_hull_boundary_ && s.x_ == hole.at(i).x_ && s.y_ == hole.at(i).y_) {
            break; // s is gate of cave & lies on convex hull's boundary
            // --> phai tra ve cave = s
        }
        if (hole.at(i).is_convex_hull_boundary_ && !hole.at(i + 1).is_convex_hull_boundary_) {
            BoundaryNode tmp1 = hole.at(i);
            i++;
            InsidePoint point1;
            point1.x_ = tmp1.x_;
            point1.y_ = tmp1.y_;
            point1.index_ = i - 1;
            cave.push_back(point1);
            while (!hole.at(i).is_convex_hull_boundary_ && i < hole.size()) {
                BoundaryNode tmp2 = hole.at(i);
                i++;
                InsidePoint point2;
                point2.x_ = tmp2.x_;
                point2.y_ = tmp2.y_;
                point2.index_ = i - 1;
                cave.push_back(point2);
                if (i == hole.size() - 1)
                    break;
            }
            BoundaryNode tmp3 = hole.at(i); // add the gate point
            InsidePoint point3;
            point3.x_ = tmp3.x_;
            point3.y_ = tmp3.y_;
            point3.index_ = i;
            cave.push_back(point3);


            i--; // bat dau tim tu diem gate point cuoi cung cua cave lien truoc

            /* BoundaryNode tmp3 = hole.at(i--); // tai sao phai co doan nay
             InsidePoint point3;
             point3.x_ = tmp3.x_;
             point3.y_ = tmp3.y_;
             point3.index_ = i + 1;
             cave.push_back(point3);
             if (i == hole.size() - 2) { // tai sao phai co doan nay
                 BoundaryNode tmp4 = hole.at(0);
                 InsidePoint point4;
                 point4.x_ = tmp4.x_;
                 point4.y_ = tmp4.y_;
                 point4.index_ = 0;
                 cave.push_back(point4);
             }*/
            if (cave.size() >= MIN_CAVE_VERTICES) {
                if (Geo::isPointInsidePolygon(s, cave))
                    break;
            }
            cave.clear();
        }
    }
    return cave;

}


void VR2Agent::determineConvexHullSet(std::vector<std::vector<BoundaryNode>> &result) {
    for (int i = 0; i < holes.size(); i++) {
        std::stack<BoundaryNode *> hull;
        std::vector<BoundaryNode> convex;
        std::vector<BoundaryNode *> clone_hole;

        std::vector<BoundaryNode> h = holes[i].node_vector_;
        for (std::vector<BoundaryNode>::iterator it = h.begin(); it != h.end(); it++) {
            clone_hole.push_back(&(*it));
        }
        std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
        BoundaryNode *pivot = clone_hole.front();
        std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
        hull.push(clone_hole[0]);
        hull.push(clone_hole[1]);
        hull.push(clone_hole[2]);

        for (int i = 3; i < clone_hole.size(); i++) {
            BoundaryNode *top = hull.top();
            hull.pop();
            while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
                top = hull.top();
                hull.pop();
            }
            hull.push(top);
            hull.push(clone_hole[i]);
        }

        while (!hull.empty()) {
            BoundaryNode *top = hull.top();
            top->is_convex_hull_boundary_ = true;
            convex.push_back(*top);
            hull.pop();
        }

        result.push_back(convex);
    }
}

std::vector<double> VR2Agent::findBasePathPriorityIndex(std::vector<std::vector<BasePathPoint>> bps) {
    std::vector<Point> C = convexHullOfAllCorePolygons();
    std::vector<double> result;
    int k = 0;  // number of bp's vertices staying outside of C's interior
    for (int i = 0; i < bps.size(); i++) {
        for (int j = 0; j < bps[i].size(); j++) {
            if (!G::isPointInsidePolygon(bps[i][j], C))
                k++;
        }
        result.push_back((double) (k + 2) / (double) (bps.size() + 2));
        k = 0;
    }

    double amountspeed = 0.0;

    for (int i = 0; i < bps.size(); i++) {
        amountspeed += result[i];
        result[i] = amountspeed;
    }

    for (int i = 0; i < bps.size(); i++) {
        if (amountspeed == 0.0)
            result[i] = (double) 1.0 / (double) bps.size();
        else
            result[i] = result[i] / amountspeed;
    }

    return result;
}

std::vector<Point> VR2Agent::convexHullOfAllCorePolygons() {
    std::vector<Point> convex;
    std::stack<BoundaryNode *> hull;
    std::vector<BoundaryNode *> clone_hole;

    for (corePolygon *it = core_polygon_set; it != NULL; it = it->next_) {
        for (node *n = it->node_; n != NULL; n = n->next_) {
            BoundaryNode *t = new BoundaryNode();
            t->x_ = n->x_;
            t->y_ = n->y_;
            clone_hole.push_back(t);
        }
    }

    if (!core_polygon_set)
        return convex;

    std::sort(clone_hole.begin(), clone_hole.end(), COORDINATE_ORDER());
    BoundaryNode *pivot = clone_hole.front();
    std::sort(clone_hole.begin() + 1, clone_hole.end(), POLAR_ORDER(*pivot));
    hull.push(clone_hole[0]);
    hull.push(clone_hole[1]);
    hull.push(clone_hole[2]);

    for (int i = 3; i < clone_hole.size(); i++) {
        BoundaryNode *top = hull.top();
        hull.pop();
        while (G::orientation(*hull.top(), *top, *clone_hole[i]) != 2) {
            top = hull.top();
            hull.pop();
        }
        hull.push(top);
        hull.push(clone_hole[i]);
    }

    while (!hull.empty()) {
        BoundaryNode *top = hull.top();
        convex.push_back(*top);
        hull.pop();
    }

    return convex;
}

node *VR2Agent::recvGPSR(Packet *p, Point destionation) {
    struct hdr_vr2_data *egh = HDR_VR2_DATA(p);

    node *nb = NULL;

    switch (egh->gprs_type_) {
        case GPSR_GPSR:
            nb = this->getNeighborByGreedy(destionation, *this);

            if (nb == NULL) {
                nb = getNeighborByPerimeter(destionation);

                if (nb == NULL) {
                    return NULL;
                } else {
                    egh->gprs_type_ = GPSR_PERIME;
                    egh->peri_ = *this;
                }
            }
            break;

        case GPSR_PERIME:
            // try to get back to greedy mode
            nb = this->getNeighborByGreedy(destionation, egh->peri_);
            if (nb) {
                egh->gprs_type_ = GPSR_GPSR;
            } else {
                nb = getNeighborByPerimeter(egh->prev_);
                if (nb == NULL) {
                    return NULL;
                }
            }
            break;

        default:
            return NULL;
    }

    egh->prev_ = *this;

    return nb;
}

bool VR2Agent::hasDestHoleInfo(Point d) {
    for (int i = 0; i < holes.size(); i++) {
        std::vector<BoundaryNode> convex = determineConvexHull(holes[i]);
        if (Geo::isPointInsidePolygon(d, convex))
            return true;
        break;
    }
    return false;
}

/*
 * Dump
 */
void VR2Agent::dumpCorePolygon() {
    FILE *fp = fopen("CorePolygon.tr", "a+");

    for (corePolygon *tmp = core_polygon_set; tmp != NULL; tmp = tmp->next_) {
        fprintf(fp, "%d\n", tmp->id_);
        for (node *node = tmp->node_; node != NULL; node = node->next_) {
            fprintf(fp, "%f\t%f\n", node->x_, node->y_);
        }
    }
    fclose(fp);
}

void VR2Agent::dump(Angle a, int i, int j, Line ln) {
    FILE *fp = fopen("Debug.tr", "a+");
    fprintf(fp, "%d\t%f\t%f\t%f\t%d\t%d\t%f\t%f\t%f\t\n", my_id_, x_, y_, a, i, j, ln.a_, ln.b_, ln.c_);
    fclose(fp);
}

void VR2Agent::dumpBroadcastRegion() {
    FILE *fp = fopen("BroadcastRegion.tr", "a+");

    fprintf(fp, "%d\t%f\t%f\t", my_id_, x_, y_);
    for (corePolygon *cg = core_polygon_set; cg; cg = cg->next_) {
        fprintf(fp, "%f\t%f\t", cg->node_->x_, cg->node_->y_);
    }
    fprintf(fp, "\n");
    fclose(fp);
}

void VR2Agent::dumpNodeInfo() {
    FILE *fp = fopen("NodeList.tr", "a+");

    fprintf(fp, "%g\t%g\n", this->x_, this->y_);
    fclose(fp);
}


void VR2Agent::dumpHopCount(hdr_vr2_data *hdr) {
    FILE *fp = fopen("HopCount.tr", "a+");
    fprintf(fp, "%d\t%d\n", hdr->source_id_, hdr->hopCount);
    fclose(fp);
}

void VR2Agent::dumpDrop(int saddr_, int type_) {
    FILE *fp = fopen("Drop.tr", "a+");
    if (type_ == 0) {
        fprintf(fp, "%d\t%s\n", saddr_, "ttl");
    }
    if (type_ == 1) {
        fprintf(fp, "%d\t%s\n", saddr_, "no neighbor");
    }
    if (type_ == 2) {
        fprintf(fp, "%d\t%s\n", saddr_, "loop");
    }
    fclose(fp);
}