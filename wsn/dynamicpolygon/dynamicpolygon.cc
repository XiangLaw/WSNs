/*
 * dynamicpolgyon.cc
 *
 *  Last edited on Nov 14, 2013
 *  by Trong Nguyen
 */

#include "config.h"
#include "dynamicpolygon.h"
#include "wsn/geomathhelper/geo_math_helper.h"

#include "../include/tcl.h"

#define MIN(a, b) ((a) < (b) ? (a) : (b))

int hdr_dynamicpolygon::offset_;

static class DynamicPolygonAgentClass : public TclClass
{
	public:
		DynamicPolygonAgentClass() : TclClass("Agent/DYNAMICPOLYGON") {}
		TclObject* create(int, const char*const*)
		{
			return (new DynamicPolygonAgent());
		}
}class_dynamic;

// ------------------------ Agent ------------------------ //

DynamicPolygonAgent::DynamicPolygonAgent() : ConvexHullAgent()
{
	stuck_angle_ = NULL;
	hole_list_ = NULL;
	bind("alpha_", &alpha_);
	bind("range_", &range_);
	bind("limit_boundhole_hop_", &limit_boundhole_hop_);
}

int
DynamicPolygonAgent::command(int argc, const char*const* argv)
{
	if (argc == 2)
	{
		if (strcasecmp(argv[1], "start") == 0)
		{
			startUp();
		}
	}

	return ConvexHullAgent::command(argc,argv);
}

// handle the receive packet just of type PT_DYNAMICPOLYGON
void
DynamicPolygonAgent::recv(Packet *p, Handler *h)
{
	hdr_cmn *cmh = HDR_CMN(p);
	hdr_ip	*iph = HDR_IP(p);

	switch (cmh->ptype())
	{
		case PT_HELLO:
			GPSRAgent::recv(p, h);
			break;

		case PT_BOUNDHOLE:
            ConvexHullAgent::recv(p,h);
			break;

		case PT_DYNAMICPOLYGON:
			recvDynamicPolygon(p);
			break;

		case PT_CBR:
//			if (iph->saddr() == my_id_)				// a packet generated by myself
//			{
//				if (cmh->num_forwards() == 0)		// a new packet
//				{
//					sendData(p);
//				}
//				else	//(cmh->num_forwards() > 0)	// routing loop -> drop
//				{
//					drop(p, DROP_RTR_ROUTE_LOOP);
//					return;
//				}
//			}
//
//			if (iph->ttl_-- <= 0)
//			{
//				drop(p, DROP_RTR_TTL);
//				return;
//			}
//			recvData(p);
			break;

		default:
			drop(p, " UnknowType");
			break;
	}
}

void
DynamicPolygonAgent::startUp()
{
	// clear trace file
	FILE *fp;
	fp = fopen("DynamicPolygon.tr", "w");	fclose(fp);
}

void DynamicPolygonAgent::sendBCH(polygonHole *h) {

}

void DynamicPolygonAgent::recvBCH(Packet *p) {
}

void DynamicPolygonAgent::recvDynamicPolygon(Packet* p)
{

}

// ------------------------ Create PolygonHole ------------------------ //
polygonHole*
DynamicPolygonAgent::createPolygonHole(Packet* p)
{
	DynamicPolygonPacketData* data = (DynamicPolygonPacketData*)p->userdata();

	// create hole item
	polygonHole * hole_item = new polygonHole();
	hole_item->node_list_ 	= NULL;

	// add node info to hole item
	struct node* item;

	for (int i = 0; i < data->size(); i++)
	{
		Point n = data->getData(i);

		item = new node();
		item->x_	= n.x_;
		item->y_	= n.y_;
		item->next_ = hole_item->node_list_;
		hole_item->node_list_ = item;
	}

	return hole_item;
}

// ------------------------ Tranfer Data ----------------------- //

void DynamicPolygonAgent::sendData(Packet* p)
{

}

void DynamicPolygonAgent::recvData(Packet* p)
{

}

// ------------------------ Dump ------------------------ //

//void
//DynamicPolygonAgent::dumpTime()
//{
//	FILE * fp = fopen("Time.tr", "a+");
//	fprintf(fp, "%f\n", Scheduler::instance().clock());
//	fclose(fp);
//}

void DynamicPolygonAgent::dumpBroadcast(){
}

void
DynamicPolygonAgent::dumpBoundhole()
{
	FILE *fp = fopen("DynamicPolygon.tr", "a+");

	for (polygonHole* p = hole_list_; p != NULL; p = p->next_)
	{
		node* n = p->node_list_;
		do {
			fprintf(fp, "%f	%f\n", n->x_, n->y_);
			n = n->next_;
		} while (n && n != p->node_list_);

		fprintf(fp, "%f	%f\n\n", p->node_list_->x_, p->node_list_->y_);
	}

	fclose(fp);
}
