/*
 * dynamicpolgyon.cc
 *
 *  Last edited on Nov 14, 2013
 *  by Trong Nguyen
 */

#include "config.h"
#include "dynamicpolygon.h"
#include "wsn/geomathhelper/geo_math_helper.h"

#include "../include/tcl.h"

#define MIN(a, b) ((a) < (b) ? (a) : (b))

int hdr_dynamicpolygon::offset_;

static class DynamicPolygonAgentClass : public TclClass
{
	public:
		DynamicPolygonAgentClass() : TclClass("Agent/DYNAMICPOLYGON") {}
		TclObject* create(int, const char*const*)
		{
			return (new DynamicPolygonAgent());
		}
}class_dinamic;

void
DynamicPolygonTimer::expire(Event *e) {
	(a_->*firing_)();
}

// ------------------------ Agent ------------------------ //

DynamicPolygonAgent::DynamicPolygonAgent() : GPSRAgent(),
		findStuck_timer_(this, &DynamicPolygonAgent::findStuckAngle),
		boundhole_timer_(this, &DynamicPolygonAgent::sendBoundHole)
{
	stuck_angle_ = NULL;
	hole_list_ = NULL;
	bind("vertex_num_", &vertex_num_);
	bind("alpha_", &alpha_);
	bind("range_", &range_);
	bind("limit_boundhole_hop_", &limit_boundhole_hop_);
}

int
DynamicPolygonAgent::command(int argc, const char*const* argv)
{
	if (argc == 2)
	{
		if (strcasecmp(argv[1], "start") == 0)
		{
			startUp();
		}
		if (strcasecmp(argv[1], "boundhole") == 0)
		{
			boundhole_timer_.resched(randSend_.uniform(0.0, 5));
			return TCL_OK;
		}
		if (strcasecmp(argv[1], "routing") == 0)
		{
			return TCL_OK;
		}
		if (strcasecmp(argv[1], "bhenergy") == 0)
		{
			dumpEnergy((char *) "bhenergy.tr");
			return TCL_OK;
		}
	}

	return GPSRAgent::command(argc,argv);
}

// handle the receive packet just of type PT_DYNAMICPOLYGON
void
DynamicPolygonAgent::recv(Packet *p, Handler *h)
{
	hdr_cmn *cmh = HDR_CMN(p);
	hdr_ip	*iph = HDR_IP(p);

	switch (cmh->ptype())
	{
		case PT_HELLO:
			GPSRAgent::recv(p, h);
			break;

		case PT_BOUNDHOLE:
			recvBoundHole(p);
			break;

		case PT_DYNAMICPOLYGON:
			recvDynamicPolygon(p);
			break;

		case PT_CBR:
			if (iph->saddr() == my_id_)				// a packet generated by myself
			{
				if (cmh->num_forwards() == 0)		// a new packet
				{
					sendData(p);
				}
				else	//(cmh->num_forwards() > 0)	// routing loop -> drop
				{
					drop(p, DROP_RTR_ROUTE_LOOP);
					return;
				}
			}

			if (iph->ttl_-- <= 0)
			{
				drop(p, DROP_RTR_TTL);
				return;
			}
			recvData(p);
			break;

		default:
			drop(p, " UnknowType");
			break;
	}
}

void
DynamicPolygonAgent::startUp()
{
	findStuck_timer_.resched(20);

	makeVector();

	// clear trace file
	FILE *fp;
	fp = fopen("DynamicPolygon.tr", "w");	fclose(fp);
}

// ------------------------ Bound hole ------------------------ //

void
DynamicPolygonAgent::findStuckAngle()
{
	if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL)
	{
		stuck_angle_ = NULL;
		return;
	}

	node *nb1 = neighbor_list_;
	node *nb2 = neighbor_list_->next_;

	while (nb2)
	{
		Circle circle = G::circumcenter(this, nb1, nb2);
		Angle a = G::angle(this, nb1, this, &circle);
		Angle b = G::angle(this, nb1, this, nb2);
		Angle c = G::angle(this, &circle, this, nb2);

		// if O is outside range of node, nb1 and nb2 create a stuck angle with node
		if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
		{
			stuckangle* new_angle = new stuckangle();
			new_angle->a_ = nb1;
			new_angle->b_ = nb2;
			new_angle->next_ = stuck_angle_;
			stuck_angle_ = new_angle;
		}

		nb1 = nb1->next_;
		nb2 = nb1->next_;
	}

	nb2 = neighbor_list_;
	Circle circle = G::circumcenter(this, nb1, nb2);
	Angle a = G::angle(this, nb1, this, &circle);
	Angle b = G::angle(this, nb1, this, nb2);
	Angle c = G::angle(this, &circle, this, nb2);

	// if O is outside range of node, nb1 and nb2 create a stuck angle with node
	if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
	{
		stuckangle* new_angle = new stuckangle();
		new_angle->a_ = nb1;
		new_angle->b_ = nb2;
		new_angle->next_ = stuck_angle_;
		stuck_angle_ = new_angle;
	}
}

void
DynamicPolygonAgent::sendBoundHole()
{
	Packet		*p;
	hdr_cmn		*cmh;
	hdr_ip		*iph;
	hdr_grid	*bhh;

	for (stuckangle * sa = stuck_angle_; sa; sa = sa->next_)
	{
		p = allocpkt();

		p->setdata(new DynamicPolygonPacketData());

		cmh = HDR_CMN(p);
		iph = HDR_IP(p);
		bhh = HDR_GRID(p);

		cmh->ptype() 	 = PT_BOUNDHOLE;
		cmh->direction() = hdr_cmn::DOWN;
		cmh->size() 	+= IP_HDR_LEN + bhh->size();
		cmh->next_hop_	 = sa->a_->id_;
		cmh->last_hop_ 	 = my_id_;
		cmh->addr_type_  = NS_AF_INET;

		iph->saddr() = my_id_;
		iph->daddr() = sa->a_->id_;
		iph->sport() = RT_PORT;
		iph->dport() = RT_PORT;
		iph->ttl_ 	 = limit_boundhole_hop_;			// more than ttl_ hop => boundary => remove

		bhh->prev_ = *this;
		bhh->last_ = *(sa->b_);
		bhh->i_ = *this;

		send(p, 0);

		printf("%d\t- Send DynamicPolygon\n", my_id_);
	}
}

void
DynamicPolygonAgent::recvBoundHole(Packet *p)
{
	struct hdr_ip	*iph = HDR_IP(p);
	struct hdr_cmn 	*cmh = HDR_CMN(p);
	struct hdr_grid *bhh = HDR_GRID(p);

	// if the convex packet has came back to the initial node
	if (iph->saddr() == my_id_)
	{
		if (iph->ttl_ > (limit_boundhole_hop_ - 5))
		{
			drop(p, " SmallHole");	// drop hole that have less than 5 hop
		}
		else
		{
			hole_list_ = createPolygonHole(p);
			dumpBoundhole();
			drop(p, " BoundHole");
		}
		return;
	}

	if (iph->ttl_-- <= 0)
	{
		drop(p, DROP_RTR_TTL);
		return;
	}

	// add data to packet
	addData(p);

	// ------------ forward packet
	node* nb = getNeighborByBoundhole(&bhh->prev_, &bhh->last_);

	// no neighbor to forward, drop message. it means the network is not interconnected
	if (nb == NULL)
	{
		drop(p, DROP_RTR_NO_ROUTE);
		return;
	}

	// if neighbor already send convex message to that node
	if (iph->saddr() > my_id_)
	{
		for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_)
		{
			if (sa->a_->id_ == nb->id_)
			{
				drop(p, " REPEAT");
				return;
			}
		}
	}

	cmh->direction() = hdr_cmn::DOWN;
	cmh->next_hop_ = nb->id_;
	cmh->last_hop_ = my_id_;

	iph->daddr() = nb->id_;

	bhh->last_ = bhh->prev_;
	bhh->prev_ = *this;

	send(p, 0);
}

node*
DynamicPolygonAgent::getNeighborByBoundhole(Point * p, Point * prev)
{
	Angle max_angle = -1;
	node* nb = NULL;

	for (node * temp = neighbor_list_; temp; temp = temp->next_)
	{
		Angle a = G::angle(this, p, this, temp);
		if (a > max_angle && !G::is_intersect(this, temp, p, prev))
		{
			max_angle = a;
			nb = temp;
		}
	}

	return nb;
}

void
DynamicPolygonAgent::addData(Packet* p)
{
	struct hdr_cmn 	*cmh = HDR_CMN(p);
	DynamicPolygonPacketData *data = (DynamicPolygonPacketData*)p->userdata();

	int lastcount = data->size();

	// add data
	data->addData(*this);

	// check the polygon.
	if (data->size() > 3)
	{
		// only for debug - print data
		for (int i = 0; i < data->size(); i++)
		{
			Point point = data->getData(i);
			printf("%f - %f\n", point.x_, point.y_);
		}

		//remove invalid vertex
		bool mark;
		for (int i = 0; i < data->size(); i++)
		{
			Point point = data->getData(i);

			mark = true;
			for (int j = 0; j < vertex_num_ && mark; j++)
			{
				bool ok = true;

				for (int k = 0; k < data->size() && ok; k++)
				{
					Point sp = data->getData(k);
					if (sp != point && G::angle(G::vector(point, sp), vector_[j]) > M_PI)
					{
						ok = false;
					}
				}

				if (ok)	mark = false;
			}

			if (mark)
			{
				data->removeData(i);
				continue;
			}
		}

		// remove same-line vertex
		for (int i = 0; i < data->size(); i++)
		{
			if (G::is_in_line(data->getData(i), data->getData((i + 1) % data->size()), data->getData((i + 2) % data->size())))
			{
				data->removeData((i + 1) % data->size());
			}
		}
	}

	cmh->size() += (data->size() - lastcount) * sizeof(Point);
}

/**
 * Create a set of vector
 */
void DynamicPolygonAgent::makeVector() {
	vector_ = (Vector*)malloc(vertex_num_ * sizeof(Vector));

	for (int i = 0; i < vertex_num_; i++)
	{
		double k = 2 * i * M_PI / vertex_num_;
		Vector v = G::vector(k);
		vector_[i].a_ = v.a_;
		vector_[i].b_ = v.b_;
	}
}

// ------------------------ Create PolygonHole ------------------------ //

void DynamicPolygonAgent::recvDynamicPolygon(Packet* p)
{

}

polygonHole*
DynamicPolygonAgent::createPolygonHole(Packet* p)
{
	DynamicPolygonPacketData* data = (DynamicPolygonPacketData*)p->userdata();

	// create hole item
	polygonHole * hole_item = new polygonHole();
	hole_item->node_list_ 	= NULL;

	// add node info to hole item
	struct node* item;

	for (int i = 0; i < data->size(); i++)
	{
		Point n = data->getData(i);

		item = new node();
		item->x_	= n.x_;
		item->y_	= n.y_;
		item->next_ = hole_item->node_list_;
		hole_item->node_list_ = item;
	}

	return hole_item;
}

// ------------------------ Tranfer Data ----------------------- //

void DynamicPolygonAgent::sendData(Packet* p)
{

}

void DynamicPolygonAgent::recvData(Packet* p)
{

}

// ------------------------ Dump ------------------------ //

void
DynamicPolygonAgent::dumpTime()
{
	FILE * fp = fopen("Time.tr", "a+");
	fprintf(fp, "%f\n", Scheduler::instance().clock());
	fclose(fp);
}

void
DynamicPolygonAgent::dumpBoundhole()
{
	FILE *fp = fopen("DynamicPolygon.tr", "a+");

	for (polygonHole* p = hole_list_; p != NULL; p = p->next_)
	{
		node* n = p->node_list_;
		do {
			fprintf(fp, "%f	%f\n", n->x_, n->y_);
			n = n->next_;
		} while (n && n != p->node_list_);

		fprintf(fp, "%f	%f\n\n", p->node_list_->x_, p->node_list_->y_);
	}

	fclose(fp);
}
