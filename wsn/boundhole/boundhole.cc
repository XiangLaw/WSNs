/*
 * boundhole.cc
 *
 *  Last edited on Nov 14, 2013
 *  by Trong Nguyen
 */

#include "config.h"
#include "boundhole.h"
#include "boundhole_packet_data.h"
#include "wsn/geomathhelper/geo_math_helper.h"

#include "../include/tcl.h"

int hdr_boundhole::offset_;

static class BoundHoleHeaderClass : public PacketHeaderClass
{
public:
	BoundHoleHeaderClass() : PacketHeaderClass("PacketHeader/BOUNDHOLE", sizeof(hdr_boundhole))
	{
		bind_offset(&hdr_boundhole::offset_);
	}
}class_boundholehdr;

void
BoundHoleTimer::expire(Event *e) {
	(a_->*firing_)();
}

// ------------------------ Agent ------------------------ //

BoundHoleAgent::BoundHoleAgent() : GPSRAgent(),
		findStuck_timer_(this, &BoundHoleAgent::findStuckAngle),
		boundhole_timer_(this, &BoundHoleAgent::sendBoundHole)
{
	stuck_angle_ = NULL;

	bind("range_", &range_);
	bind("storage_opt_", &storage_opt_);
	bind("limit_boundhole_hop_", &limit_hop);
	//bind("limit_min_boundhole_hop_", &limit_min_hop_);
}

int
BoundHoleAgent::command(int argc, const char*const* argv)
{
	if (argc == 2)
	{
		if (strcasecmp(argv[1], "start") == 0)
		{
			startUp();
		}
		if (strcasecmp(argv[1], "boundhole") == 0)
		{
			boundhole_timer_.resched(randSend_.uniform(0.0, 5));
			return TCL_OK;
		}
		if (strcasecmp(argv[1], "bcenergy") == 0)
		{
			dumpBCEnergy();
			return TCL_OK;
		}
	}

	return GPSRAgent::command(argc,argv);
}

// handle the receive packet just of type PT_BOUNDHOLE
void
BoundHoleAgent::recv(Packet *p, Handler *h)
{
	hdr_cmn 		*cmh = HDR_CMN(p);
	hdr_ip  		*iph = HDR_IP(p);
	hdr_boundhole	*bhh = HDR_BOUNDHOLE(p);

	switch (cmh->ptype())
	{
		case PT_HELLO:
			GPSRAgent::recv(p, h);
			break;

		case PT_BOUNDHOLE:
			if (bhh->type_ == BOUNDHOLE_BOUNDHOLE)
			{
				recvBoundHole(p);
			}
			else // bhh->type_ == BOUNDHOLE_REFRESH
			{
				recvRefresh(p);
			}
			break;

		case PT_CBR:
			if (iph->saddr() == my_id_)				// a packet generated by myself
			{
				if (cmh->num_forwards() == 0)		// a new packet
				{
					sendData(p);
				}
				else	//(cmh->num_forwards() > 0)	// routing loop -> drop
				{
					drop(p, DROP_RTR_ROUTE_LOOP);
					return;
				}
			}

			if (iph->ttl_-- <= 0)
			{
				drop(p, DROP_RTR_TTL);
				return;
			}
			recvData(p);
			break;

		default:
			drop(p, " UnknowType");
			break;
	}
}

void
BoundHoleAgent::startUp()
{
	findStuck_timer_.resched(20);

	// clear trace file
	FILE *fp;
	fp = fopen("Neighbors.tr", "w");	fclose(fp);
	fp = fopen("BoundHole.tr", "w");	fclose(fp);
	fp = fopen("BCEnergy.tr", "w");		fclose(fp);
}

// ------------------------ Bound hole ------------------------ //

void
BoundHoleAgent::findStuckAngle()
{
	if (neighbor_list_ == NULL || neighbor_list_->next_ == NULL)
	{
		stuck_angle_ = NULL;
		return;
	}

	node *nb1 = neighbor_list_; //u
	node *nb2 = neighbor_list_->next_; //v

	while (nb2)
	{
		Circle circle = G::circumcenter(this, nb1, nb2);
		Angle a = G::angle(this, nb1, this, &circle); // upO
		Angle b = G::angle(this, nb1, this, nb2); // upv
		Angle c = G::angle(this, &circle, this, nb2); //Opv

		// if O is outside range of node, nb1 and nb2 create a stuck angle with node
		if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
		{
			stuckangle* new_angle = new stuckangle();
			new_angle->a_ = nb1;
			new_angle->b_ = nb2;
			new_angle->next_ = stuck_angle_;
			stuck_angle_ = new_angle;
		}

		nb1 = nb1->next_;
		nb2 = nb1->next_;
	}

	nb2 = neighbor_list_;
	Circle circle = G::circumcenter(this, nb1, nb2);
	Angle a = G::angle(this, nb1, this, &circle);
	Angle b = G::angle(this, nb1, this, nb2);
	Angle c = G::angle(this, &circle, this, nb2);

	// if O is outside range of node, nb1 and nb2 create a stuck angle with node
	if (b >= M_PI || (fabs(a) + fabs(c) == fabs(b) && G::distance(this, circle) > range_))
	{
		stuckangle* new_angle = new stuckangle();
		new_angle->a_ = nb1;
		new_angle->b_ = nb2;
		new_angle->next_ = stuck_angle_;
		stuck_angle_ = new_angle;
	}
}

void BoundHoleAgent::sendBoundHole()
{
	Packet			*p;
	hdr_cmn			*cmh;
	hdr_ip			*iph;
	hdr_boundhole	*bhh;

	for (stuckangle * sa = stuck_angle_; sa; sa = sa->next_)
	{
		p = allocpkt();

		BoundHolePacketData *bhpkt_data = new BoundHolePacketData();
		bhpkt_data->add(sa->b_->id_, sa->b_->x_, sa->b_->y_);
		bhpkt_data->add(my_id_, this->x_, this->y_);
		p->setdata(bhpkt_data);

		cmh = HDR_CMN(p);
		iph = HDR_IP(p);
		bhh = HDR_BOUNDHOLE(p);

		cmh->ptype() 	 = PT_BOUNDHOLE;
		cmh->direction() = hdr_cmn::DOWN;
		cmh->size()		 += IP_HDR_LEN + bhh->size() + bhpkt_data->data_len_;
		cmh->next_hop_	 = sa->a_->id_;
		cmh->last_hop_ 	 = my_id_;
		cmh->addr_type_  = NS_AF_INET;

		iph->saddr() = my_id_;
		iph->daddr() = sa->a_->id_;
		iph->sport() = RT_PORT;
		iph->dport() = RT_PORT;
		iph->ttl_ 	 = limit_hop;			// more than ttl_ hop => boundary => remove

		bhh->prev_ = *this;
		bhh->type_ = BOUNDHOLE_BOUNDHOLE;

		send(p, 0);

		printf("%d\t- Send BoundHole\n", my_id_);
	}
}

void BoundHoleAgent::recvBoundHole(Packet *p)
{
	struct hdr_ip *iph = HDR_IP(p);
	struct hdr_cmn 		 *cmh = HDR_CMN(p);
	struct hdr_boundhole *bhh = HDR_BOUNDHOLE(p);

	BoundHolePacketData *data = (BoundHolePacketData*)p->userdata();

	// if the boundhole packet has came back to the initial node
	if (iph->saddr() == my_id_)
	{
		if (iph->ttl_ > (limit_hop - 5)) // replace 5 = limit_min_hop_
		{
			drop(p, " SmallHole");	// drop hole that have less than 5 hop
		}
		else
		{
			// Only store hole information in control node
			data->dump();
			createHole(p);
			if (storage_opt_ == STORAGE_ONE)
			{
				drop(p, " BOUNDHOLE");
			}
			else // storage_opt_ == STORAGE_ALL
			{
				sendRefresh(p);
			}
		}
		return;
	}

	if (iph->ttl_-- <= 0)
	{
		drop(p, DROP_RTR_TTL);
		return;
	}

//	int lastcount = data->data_len_;

	node n = data->get_data(1);
	if (n.id_ != iph->saddr())
	{
		// if this is second hop => remove "b"
		data->rmv_data(1);
	}
	else
	{
		// get the entry at index n-1
		n = data->get_data(data->size() - 1);
	}

	node* nb = getNeighborByBoundHole(&bhh->prev_, &n);

	// no neighbor to forward, drop message
	// it means the network is not interconnected
	if (nb == NULL)
	{
		drop(p, DROP_RTR_NO_ROUTE);
		return;
	}

	// drop message for loop way
	node temp, next;

	for (int i = 1; i < data->size(); i++)
	{
		temp = data->get_data(i);
		next = data->get_data(i + 1);

		if (G::is_intersect2(this, nb, temp, next))
		{
			if (G::distance(temp, nb) < range_)
			{
				while (data->size() >= (i + 1))
				{
					data->rmv_data(i + 1);
				}

				data->add(nb->id_, nb->x_, nb->y_);
				nb = getNeighborByBoundHole(nb, &temp);

				continue;
			}
			else
			{
				nb = getNeighbor(next.id_);
				continue;
			}
		}
	}

	// if neighbor already send boundhole message to that node
	if (iph->saddr() > my_id_)
	{
		for (stuckangle *sa = stuck_angle_; sa; sa = sa->next_)
		{
			if (sa->a_->id_ == nb->id_)
			{
				drop(p, " REPEAT");
				return;
			}
		}
	}

	data->add(my_id_, this->x_, this->y_);

	cmh->direction() = hdr_cmn::DOWN;
	cmh->next_hop_ = nb->id_;
	cmh->last_hop_ = my_id_;
//	cmh->size_ += (data->data_len_ - lastcount) * data->element_size_;

	iph->daddr() = nb->id_;

	bhh->prev_ = *this;

	send(p, 0);
}

void BoundHoleAgent::sendRefresh(Packet* p)
{
	BoundHolePacketData* 	data = (BoundHolePacketData*)p->userdata();
	hdr_cmn*	 	cmh	= HDR_CMN(p);
	hdr_ip*			iph = HDR_IP(p);
	hdr_boundhole*	bhh = HDR_BOUNDHOLE(p);

	node n = data->get_data(2);

	cmh->direction() 	= hdr_cmn::DOWN;
	cmh->next_hop_ 		= n.id_;
	cmh->last_hop_ 		= my_id_;
	cmh->addr_type_ 	= NS_AF_INET;
	cmh->ptype() 		= PT_BOUNDHOLE;
	cmh->num_forwards() = 0;
	cmh->size()		 += IP_HDR_LEN + bhh->size() + data->data_len_;

	iph->saddr() = my_id_;
	iph->daddr() = n.id_;
	iph->sport() = RT_PORT;
	iph->dport() = RT_PORT;
	iph->ttl_ 	 = IP_DEF_TTL;

	bhh->type_ = BOUNDHOLE_REFRESH;

	send(p, 0);
}

void BoundHoleAgent::recvRefresh(Packet *p)
{
	struct hdr_ip 		*iph = HDR_IP(p);
	BoundHolePacketData *data = (BoundHolePacketData*)p->userdata();

	// create hole item
	createHole(p);

	int i = 1;
//	while (data->get_data(i).id_ != my_id_ && i <= data->size()) i++;
	while (data->get_data(i).id_ != my_id_) i++;

	if (i < data->size())
	{
		nsaddr_t next_id = data->get_data(i+1).id_;

		hdr_cmn *cmh = HDR_CMN(p);
		cmh->direction_ = hdr_cmn::DOWN;
		cmh->last_hop_  = my_id_;
		cmh->next_hop_  = next_id;

		iph->daddr() = next_id;

		send(p, 0);
	}
	else
	{
		drop(p, " BOUNDHOLE");
	}
}

// ------------------------ create PolygonHole ------------------------ //

polygonHole* BoundHoleAgent::createPolygonHole(Packet *p)
{
	BoundHolePacketData* data = (BoundHolePacketData*)p->userdata();

	// create hole item
	polygonHole * hole_item = new polygonHole();
	hole_item->hole_id_ 	= my_id_;
	hole_item->node_list_ 	= NULL;

	// add node info to hole item
	struct node* item;

	for (int i = 1; i <= data->size(); i++)
	{
		node n = data->get_data(i);

		item = new node();
		item->x_	= n.x_;
		item->y_	= n.y_;
		item->next_ = hole_item->node_list_;
		hole_item->node_list_ = item;
	}

	return hole_item;
}

//TODO: considering?
node* BoundHoleAgent::getNeighborByBoundHole(Point * p, Point * prev)
{
	// p = p
	// prev = s
	// this = t1

	Angle max_angle = -1;
	node* nb = NULL;

	for (node * temp = neighbor_list_; temp; temp = temp->next_)
	{
		int i = temp->id_;
		Angle a = G::angle(this, p, this, temp);
		if (a > max_angle && (!G::is_intersect(this, temp, p, prev) ||
				(temp->x_ == p->x_ && temp->y_ == p->y_) ||
				(this->x_ == prev->x_ && this->y_ == prev->y_)))
		{
			max_angle = a;
			nb = temp;
		}
	}

	return nb;

//	FILE *fp;
//	fp = fopen("debug.tr", "a+");
//	fprintf(fp, "%d \t %f \t %f \t %f \t %f \n", my_id_, p->x_, p->y_, prev->x_, prev->y_);
//	fclose(fp);
//	for(node *tmp = neighbor_list_; tmp; tmp = tmp->next_) {
//		// if tmp is right hand side
//		if(G::directedAngle2(tmp, p, this) > M_PI) {
//			continue;
//		}
//
//		if(G::directedAngle2(prev, p, this) > M_PI) { // if (spt1) > pi => return t2
//			return tmp;
//		}
//		else { // else check if t2 is inside forbidden region
//			if(G::distance(this, tmp) < this->range_ && G::directedAngle2(tmp, p, this) > G::directedAngle2(tmp, p, prev)) {
//				continue;
//			}
//		}
//	}
//
//	return NULL;
}

// ------------------------ Dump ------------------------ //

void BoundHoleAgent::dumpBCEnergy()
{
	if (node_->energy_model())
	{
		FILE *fp = fopen("BCEnergy.tr", "a+");
		fprintf(fp, "%d\t%f\t%f\t%f\n", my_id_, this->x_, this->y_, node_->energy_model()->energy());
		fclose(fp);
	}
}
